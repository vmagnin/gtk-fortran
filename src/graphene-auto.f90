! Do not modify this file automatically generated by cfwrapper.py using:
! GTK 4.0.0, GLib 2.67.1, Fedora 34 x86_64
! This file is part of the gtk-fortran library, distributed under
! GNU General Public License version 3.

module graphene
implicit none
interface

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_rect_t * graphene_rect_alloc (void);
function graphene_rect_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_rect_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_free (graphene_rect_t *r);
subroutine graphene_rect_free(r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_rect_t * graphene_rect_init (graphene_rect_t *r, float x, float y, float width, float height);
function graphene_rect_init(r, x, y, width, height) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_rect_init
  type(c_ptr), value :: r
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: width
  real(c_float), value :: height
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_rect_t * graphene_rect_init_from_rect (graphene_rect_t *r, const graphene_rect_t *src);
function graphene_rect_init_from_rect(r, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_rect_init_from_rect
  type(c_ptr), value :: r
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_rect_equal (const graphene_rect_t *a, const graphene_rect_t *b);
function graphene_rect_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_rect_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_rect_t * graphene_rect_normalize (graphene_rect_t *r);
function graphene_rect_normalize(r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_rect_normalize
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_rect_normalize_r (const graphene_rect_t *r, graphene_rect_t *res);
subroutine graphene_rect_normalize_r(r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_get_center (const graphene_rect_t *r, graphene_point_t *p);
subroutine graphene_rect_get_center(r, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_get_top_left (const graphene_rect_t *r, graphene_point_t *p);
subroutine graphene_rect_get_top_left(r, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_get_top_right (const graphene_rect_t *r, graphene_point_t *p);
subroutine graphene_rect_get_top_right(r, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_get_bottom_right (const graphene_rect_t *r, graphene_point_t *p);
subroutine graphene_rect_get_bottom_right(r, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_get_bottom_left (const graphene_rect_t *r, graphene_point_t *p);
subroutine graphene_rect_get_bottom_left(r, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_rect_get_x (const graphene_rect_t *r);
function graphene_rect_get_x(r) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_rect_get_x
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_rect_get_y (const graphene_rect_t *r);
function graphene_rect_get_y(r) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_rect_get_y
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_rect_get_width (const graphene_rect_t *r);
function graphene_rect_get_width(r) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_rect_get_width
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_rect_get_height (const graphene_rect_t *r);
function graphene_rect_get_height(r) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_rect_get_height
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_rect_get_area (const graphene_rect_t *r);
function graphene_rect_get_area(r) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_rect_get_area
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_union (const graphene_rect_t *a, const graphene_rect_t *b, graphene_rect_t *res);
subroutine graphene_rect_union(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_rect_intersection (const graphene_rect_t *a, const graphene_rect_t *b, graphene_rect_t *res);
function graphene_rect_intersection(a, b, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_rect_intersection
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_rect_contains_point (const graphene_rect_t *r, const graphene_point_t *p);
function graphene_rect_contains_point(r, p) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_rect_contains_point
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_rect_contains_rect (const graphene_rect_t *a, const graphene_rect_t *b);
function graphene_rect_contains_rect(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_rect_contains_rect
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_rect_t * graphene_rect_offset (graphene_rect_t *r, float d_x, float d_y);
function graphene_rect_offset(r, d_x, d_y) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_rect_offset
  type(c_ptr), value :: r
  real(c_float), value :: d_x
  real(c_float), value :: d_y
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_rect_offset_r (const graphene_rect_t *r, float d_x, float d_y, graphene_rect_t *res);
subroutine graphene_rect_offset_r(r, d_x, d_y, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: r
  real(c_float), value :: d_x
  real(c_float), value :: d_y
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_rect_t * graphene_rect_inset (graphene_rect_t *r, float d_x, float d_y);
function graphene_rect_inset(r, d_x, d_y) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_rect_inset
  type(c_ptr), value :: r
  real(c_float), value :: d_x
  real(c_float), value :: d_y
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_rect_inset_r (const graphene_rect_t *r, float d_x, float d_y, graphene_rect_t *res);
subroutine graphene_rect_inset_r(r, d_x, d_y, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: r
  real(c_float), value :: d_x
  real(c_float), value :: d_y
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_DEPRECATED_IN_1_4_FOR (graphene_rect_round)
!graphene_rect_t * graphene_rect_round_to_pixel (graphene_rect_t *r);
function graphene_rect_round_to_pixel(r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_rect_round_to_pixel
  type(c_ptr), value :: r
end function

! GRAPHENE_DEPRECATED_IN_1_10_FOR (graphene_rect_round_extents)
!void graphene_rect_round (const graphene_rect_t *r, graphene_rect_t *res);
subroutine graphene_rect_round(r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_rect_round_extents (const graphene_rect_t *r, graphene_rect_t *res);
subroutine graphene_rect_round_extents(r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_rect_interpolate (const graphene_rect_t *a, const graphene_rect_t *b, double factor, graphene_rect_t *res);
subroutine graphene_rect_interpolate(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_rect_expand (const graphene_rect_t *r, const graphene_point_t *p, graphene_rect_t *res);
subroutine graphene_rect_expand(r, p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!const graphene_rect_t * graphene_rect_zero (void);
function graphene_rect_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_rect_zero
end function

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_rect_scale (const graphene_rect_t *r, float s_h, float s_v, graphene_rect_t *res);
subroutine graphene_rect_scale(r, s_h, s_v, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: r
  real(c_float), value :: s_h
  real(c_float), value :: s_v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_point_t * graphene_point_alloc (void);
function graphene_point_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point_free (graphene_point_t *p);
subroutine graphene_point_free(p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_point_t * graphene_point_init (graphene_point_t *p, float x, float y);
function graphene_point_init(p, x, y) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_point_init
  type(c_ptr), value :: p
  real(c_float), value :: x
  real(c_float), value :: y
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_point_t * graphene_point_init_from_point (graphene_point_t *p, const graphene_point_t *src);
function graphene_point_init_from_point(p, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point_init_from_point
  type(c_ptr), value :: p
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_4
!graphene_point_t * graphene_point_init_from_vec2 (graphene_point_t *p, const graphene_vec2_t *src);
function graphene_point_init_from_vec2(p, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point_init_from_vec2
  type(c_ptr), value :: p
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_point_equal (const graphene_point_t *a, const graphene_point_t *b);
function graphene_point_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_point_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_point_distance (const graphene_point_t *a, const graphene_point_t *b, float *d_x, float *d_y);
function graphene_point_distance(a, b, d_x, d_y) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_point_distance
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: d_x
  type(c_ptr), value :: d_y
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_point_near (const graphene_point_t *a, const graphene_point_t *b, float epsilon);
function graphene_point_near(a, b, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_point_near
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point_interpolate (const graphene_point_t *a, const graphene_point_t *b, double factor, graphene_point_t *res);
subroutine graphene_point_interpolate(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_point_to_vec2 (const graphene_point_t *p, graphene_vec2_t *v);
subroutine graphene_point_to_vec2(p, v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_point_t * graphene_point_zero (void);
function graphene_point_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point_zero
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_frustum_t * graphene_frustum_alloc (void);
function graphene_frustum_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_frustum_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_frustum_free (graphene_frustum_t *f);
subroutine graphene_frustum_free(f) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: f
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_frustum_t * graphene_frustum_init (graphene_frustum_t *f, const graphene_plane_t *p0, const graphene_plane_t *p1, const graphene_plane_t *p2, const graphene_plane_t *p3, const graphene_plane_t *p4, const graphene_plane_t *p5);
function graphene_frustum_init(f, p0, p1, p2, p3, p4, p5) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_frustum_init
  type(c_ptr), value :: f
  type(c_ptr), value :: p0
  type(c_ptr), value :: p1
  type(c_ptr), value :: p2
  type(c_ptr), value :: p3
  type(c_ptr), value :: p4
  type(c_ptr), value :: p5
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_frustum_t * graphene_frustum_init_from_frustum (graphene_frustum_t *f, const graphene_frustum_t *src);
function graphene_frustum_init_from_frustum(f, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_frustum_init_from_frustum
  type(c_ptr), value :: f
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_frustum_t * graphene_frustum_init_from_matrix (graphene_frustum_t *f, const graphene_matrix_t *matrix);
function graphene_frustum_init_from_matrix(f, matrix) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_frustum_init_from_matrix
  type(c_ptr), value :: f
  type(c_ptr), value :: matrix
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_frustum_contains_point (const graphene_frustum_t *f, const graphene_point3d_t *point);
function graphene_frustum_contains_point(f, point) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_frustum_contains_point
  type(c_ptr), value :: f
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_frustum_intersects_sphere (const graphene_frustum_t *f, const graphene_sphere_t *sphere);
function graphene_frustum_intersects_sphere(f, sphere) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_frustum_intersects_sphere
  type(c_ptr), value :: f
  type(c_ptr), value :: sphere
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_frustum_intersects_box (const graphene_frustum_t *f, const graphene_box_t *box);
function graphene_frustum_intersects_box(f, box) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_frustum_intersects_box
  type(c_ptr), value :: f
  type(c_ptr), value :: box
end function

! GRAPHENE_AVAILABLE_IN_1_6
!bool graphene_frustum_equal (const graphene_frustum_t *a, const graphene_frustum_t *b);
function graphene_frustum_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_frustum_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_euler_t * graphene_euler_alloc (void);
function graphene_euler_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_euler_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_euler_free (graphene_euler_t *e);
subroutine graphene_euler_free(e) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: e
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init (graphene_euler_t *e, float x, float y, float z);
function graphene_euler_init(e, x, y, z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_euler_init
  type(c_ptr), value :: e
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init_with_order (graphene_euler_t *e, float x, float y, float z, graphene_euler_order_t order);
function graphene_euler_init_with_order(e, x, y, z, order) bind(c)
  use iso_c_binding, only: c_ptr, c_float, c_int
  type(c_ptr) :: graphene_euler_init_with_order
  type(c_ptr), value :: e
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
  integer(c_int), value :: order
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init_from_matrix (graphene_euler_t *e, const graphene_matrix_t *m, graphene_euler_order_t order);
function graphene_euler_init_from_matrix(e, m, order) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_euler_init_from_matrix
  type(c_ptr), value :: e
  type(c_ptr), value :: m
  integer(c_int), value :: order
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init_from_quaternion (graphene_euler_t *e, const graphene_quaternion_t *q, graphene_euler_order_t order);
function graphene_euler_init_from_quaternion(e, q, order) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_euler_init_from_quaternion
  type(c_ptr), value :: e
  type(c_ptr), value :: q
  integer(c_int), value :: order
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init_from_vec3 (graphene_euler_t *e, const graphene_vec3_t *v, graphene_euler_order_t order);
function graphene_euler_init_from_vec3(e, v, order) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_euler_init_from_vec3
  type(c_ptr), value :: e
  type(c_ptr), value :: v
  integer(c_int), value :: order
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_t * graphene_euler_init_from_euler (graphene_euler_t *e, const graphene_euler_t *src);
function graphene_euler_init_from_euler(e, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_euler_init_from_euler
  type(c_ptr), value :: e
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_10
!graphene_euler_t * graphene_euler_init_from_radians (graphene_euler_t *e, float x, float y, float z, graphene_euler_order_t order);
function graphene_euler_init_from_radians(e, x, y, z, order) bind(c)
  use iso_c_binding, only: c_ptr, c_float, c_int
  type(c_ptr) :: graphene_euler_init_from_radians
  type(c_ptr), value :: e
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
  integer(c_int), value :: order
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_euler_equal (const graphene_euler_t *a, const graphene_euler_t *b);
function graphene_euler_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_euler_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_euler_get_x (const graphene_euler_t *e);
function graphene_euler_get_x(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_x
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_euler_get_y (const graphene_euler_t *e);
function graphene_euler_get_y(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_y
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_euler_get_z (const graphene_euler_t *e);
function graphene_euler_get_z(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_z
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_euler_order_t graphene_euler_get_order (const graphene_euler_t *e);
function graphene_euler_get_order(e) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_euler_get_order
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_euler_get_alpha (const graphene_euler_t *e);
function graphene_euler_get_alpha(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_alpha
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_euler_get_beta (const graphene_euler_t *e);
function graphene_euler_get_beta(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_beta
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_euler_get_gamma (const graphene_euler_t *e);
function graphene_euler_get_gamma(e) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_euler_get_gamma
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_euler_to_vec3 (const graphene_euler_t *e, graphene_vec3_t *res);
subroutine graphene_euler_to_vec3(e, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: e
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_euler_to_matrix (const graphene_euler_t *e, graphene_matrix_t *res);
subroutine graphene_euler_to_matrix(e, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: e
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_euler_to_quaternion (const graphene_euler_t *e, graphene_quaternion_t *res);
subroutine graphene_euler_to_quaternion(e, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: e
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_euler_reorder (const graphene_euler_t *e, graphene_euler_order_t order, graphene_euler_t *res);
subroutine graphene_euler_reorder(e, order, res) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: e
  integer(c_int), value :: order
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_vec3_t * graphene_vec3_alloc (void);
function graphene_vec3_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_free (graphene_vec3_t *v);
subroutine graphene_vec3_free(v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec3_t * graphene_vec3_init (graphene_vec3_t *v, float x, float y, float z);
function graphene_vec3_init(v, x, y, z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_vec3_init
  type(c_ptr), value :: v
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec3_t * graphene_vec3_init_from_vec3 (graphene_vec3_t *v, const graphene_vec3_t *src);
function graphene_vec3_init_from_vec3(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_init_from_vec3
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec3_t * graphene_vec3_init_from_float (graphene_vec3_t *v, const float *src);
function graphene_vec3_init_from_float(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_init_from_float
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_to_float (const graphene_vec3_t *v, float *dest);
subroutine graphene_vec3_to_float(v, dest) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: dest
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_add (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_add(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_subtract (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_subtract(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_multiply (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_multiply(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_divide (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_divide(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_cross (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_cross(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec3_dot (const graphene_vec3_t *a, const graphene_vec3_t *b);
function graphene_vec3_dot(a, b) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec3_dot
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec3_length (const graphene_vec3_t *v);
function graphene_vec3_length(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec3_length
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_normalize (const graphene_vec3_t *v, graphene_vec3_t *res);
subroutine graphene_vec3_normalize(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec3_scale (const graphene_vec3_t *v, float factor, graphene_vec3_t *res);
subroutine graphene_vec3_scale(v, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: v
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec3_negate (const graphene_vec3_t *v, graphene_vec3_t *res);
subroutine graphene_vec3_negate(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec3_equal (const graphene_vec3_t *v1, const graphene_vec3_t *v2);
function graphene_vec3_equal(v1, v2) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_vec3_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec3_near (const graphene_vec3_t *v1, const graphene_vec3_t *v2, float epsilon);
function graphene_vec3_near(v1, v2, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_vec3_near
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_min (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_min(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_max (const graphene_vec3_t *a, const graphene_vec3_t *b, graphene_vec3_t *res);
subroutine graphene_vec3_max(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_vec3_interpolate (const graphene_vec3_t *v1, const graphene_vec3_t *v2, double factor, graphene_vec3_t *res);
subroutine graphene_vec3_interpolate(v1, v2, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec3_get_x (const graphene_vec3_t *v);
function graphene_vec3_get_x(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec3_get_x
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec3_get_y (const graphene_vec3_t *v);
function graphene_vec3_get_y(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec3_get_y
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec3_get_z (const graphene_vec3_t *v);
function graphene_vec3_get_z(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec3_get_z
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_get_xy (const graphene_vec3_t *v, graphene_vec2_t *res);
subroutine graphene_vec3_get_xy(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_get_xy0 (const graphene_vec3_t *v, graphene_vec3_t *res);
subroutine graphene_vec3_get_xy0(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_get_xyz0 (const graphene_vec3_t *v, graphene_vec4_t *res);
subroutine graphene_vec3_get_xyz0(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_get_xyz1 (const graphene_vec3_t *v, graphene_vec4_t *res);
subroutine graphene_vec3_get_xyz1(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec3_get_xyzw (const graphene_vec3_t *v, float w, graphene_vec4_t *res);
subroutine graphene_vec3_get_xyzw(v, w, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: v
  real(c_float), value :: w
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec3_t * graphene_vec3_zero (void);
function graphene_vec3_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_zero
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec3_t * graphene_vec3_one (void);
function graphene_vec3_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_one
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec3_t * graphene_vec3_x_axis (void);
function graphene_vec3_x_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_x_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec3_t * graphene_vec3_y_axis (void);
function graphene_vec3_y_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_y_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec3_t * graphene_vec3_z_axis (void);
function graphene_vec3_z_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec3_z_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS void graphene_simd4x4f_transpose_in_place (graphene_simd4x4f_t *s);
subroutine graphene_simd4x4f_transpose_in_place(s) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_vec4_t * graphene_vec4_alloc (void);
function graphene_vec4_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_free (graphene_vec4_t *v);
subroutine graphene_vec4_free(v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec4_t * graphene_vec4_init (graphene_vec4_t *v, float x, float y, float z, float w);
function graphene_vec4_init(v, x, y, z, w) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_vec4_init
  type(c_ptr), value :: v
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
  real(c_float), value :: w
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec4_t * graphene_vec4_init_from_vec4 (graphene_vec4_t *v, const graphene_vec4_t *src);
function graphene_vec4_init_from_vec4(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_init_from_vec4
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec4_t * graphene_vec4_init_from_vec3 (graphene_vec4_t *v, const graphene_vec3_t *src, float w);
function graphene_vec4_init_from_vec3(v, src, w) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_vec4_init_from_vec3
  type(c_ptr), value :: v
  type(c_ptr), value :: src
  real(c_float), value :: w
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec4_t * graphene_vec4_init_from_vec2 (graphene_vec4_t *v, const graphene_vec2_t *src, float z, float w);
function graphene_vec4_init_from_vec2(v, src, z, w) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_vec4_init_from_vec2
  type(c_ptr), value :: v
  type(c_ptr), value :: src
  real(c_float), value :: z
  real(c_float), value :: w
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec4_t * graphene_vec4_init_from_float (graphene_vec4_t *v, const float *src);
function graphene_vec4_init_from_float(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_init_from_float
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_to_float (const graphene_vec4_t *v, float *dest);
subroutine graphene_vec4_to_float(v, dest) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: dest
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_add (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_add(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_subtract (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_subtract(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_multiply (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_multiply(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_divide (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_divide(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_dot (const graphene_vec4_t *a, const graphene_vec4_t *b);
function graphene_vec4_dot(a, b) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_dot
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_length (const graphene_vec4_t *v);
function graphene_vec4_length(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_length
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_normalize (const graphene_vec4_t *v, graphene_vec4_t *res);
subroutine graphene_vec4_normalize(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec4_scale (const graphene_vec4_t *v, float factor, graphene_vec4_t *res);
subroutine graphene_vec4_scale(v, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: v
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec4_negate (const graphene_vec4_t *v, graphene_vec4_t *res);
subroutine graphene_vec4_negate(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec4_equal (const graphene_vec4_t *v1, const graphene_vec4_t *v2);
function graphene_vec4_equal(v1, v2) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_vec4_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec4_near (const graphene_vec4_t *v1, const graphene_vec4_t *v2, float epsilon);
function graphene_vec4_near(v1, v2, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_vec4_near
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_min (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_min(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_max (const graphene_vec4_t *a, const graphene_vec4_t *b, graphene_vec4_t *res);
subroutine graphene_vec4_max(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_vec4_interpolate (const graphene_vec4_t *v1, const graphene_vec4_t *v2, double factor, graphene_vec4_t *res);
subroutine graphene_vec4_interpolate(v1, v2, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_get_x (const graphene_vec4_t *v);
function graphene_vec4_get_x(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_get_x
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_get_y (const graphene_vec4_t *v);
function graphene_vec4_get_y(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_get_y
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_get_z (const graphene_vec4_t *v);
function graphene_vec4_get_z(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_get_z
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec4_get_w (const graphene_vec4_t *v);
function graphene_vec4_get_w(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec4_get_w
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_get_xy (const graphene_vec4_t *v, graphene_vec2_t *res);
subroutine graphene_vec4_get_xy(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec4_get_xyz (const graphene_vec4_t *v, graphene_vec3_t *res);
subroutine graphene_vec4_get_xyz(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_zero (void);
function graphene_vec4_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_zero
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_one (void);
function graphene_vec4_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_one
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_x_axis (void);
function graphene_vec4_x_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_x_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_y_axis (void);
function graphene_vec4_y_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_y_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_z_axis (void);
function graphene_vec4_z_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_z_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec4_t * graphene_vec4_w_axis (void);
function graphene_vec4_w_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec4_w_axis
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_plane_t * graphene_plane_alloc (void);
function graphene_plane_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_plane_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_plane_free (graphene_plane_t *p);
subroutine graphene_plane_free(p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_plane_t * graphene_plane_init (graphene_plane_t *p, const graphene_vec3_t *normal, float constant);
function graphene_plane_init(p, normal, constant) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_plane_init
  type(c_ptr), value :: p
  type(c_ptr), value :: normal
  real(c_float), value :: constant
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_plane_t * graphene_plane_init_from_vec4 (graphene_plane_t *p, const graphene_vec4_t *src);
function graphene_plane_init_from_vec4(p, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_plane_init_from_vec4
  type(c_ptr), value :: p
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_plane_t * graphene_plane_init_from_plane (graphene_plane_t *p, const graphene_plane_t *src);
function graphene_plane_init_from_plane(p, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_plane_init_from_plane
  type(c_ptr), value :: p
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_plane_t * graphene_plane_init_from_point (graphene_plane_t *p, const graphene_vec3_t *normal, const graphene_point3d_t *point);
function graphene_plane_init_from_point(p, normal, point) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_plane_init_from_point
  type(c_ptr), value :: p
  type(c_ptr), value :: normal
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_plane_t * graphene_plane_init_from_points (graphene_plane_t *p, const graphene_point3d_t *a, const graphene_point3d_t *b, const graphene_point3d_t *c);
function graphene_plane_init_from_points(p, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_plane_init_from_points
  type(c_ptr), value :: p
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_plane_normalize (const graphene_plane_t *p, graphene_plane_t *res);
subroutine graphene_plane_normalize(p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_plane_negate (const graphene_plane_t *p, graphene_plane_t *res);
subroutine graphene_plane_negate(p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_plane_equal (const graphene_plane_t *a, const graphene_plane_t *b);
function graphene_plane_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_plane_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_plane_distance (const graphene_plane_t *p, const graphene_point3d_t *point);
function graphene_plane_distance(p, point) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_plane_distance
  type(c_ptr), value :: p
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_plane_get_normal (const graphene_plane_t *p, graphene_vec3_t *normal);
subroutine graphene_plane_get_normal(p, normal) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: normal
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_plane_get_constant (const graphene_plane_t *p);
function graphene_plane_get_constant(p) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_plane_get_constant
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_plane_transform (const graphene_plane_t *p, const graphene_matrix_t *matrix, const graphene_matrix_t *normal_matrix, graphene_plane_t *res);
subroutine graphene_plane_transform(p, matrix, normal_matrix, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: matrix
  type(c_ptr), value :: normal_matrix
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_box_t * graphene_box_alloc (void);
function graphene_box_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_free (graphene_box_t *box);
subroutine graphene_box_free(box) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_box_t * graphene_box_init (graphene_box_t *box, const graphene_point3d_t *min, const graphene_point3d_t *max);
function graphene_box_init(box, min, max) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_init
  type(c_ptr), value :: box
  type(c_ptr), value :: min
  type(c_ptr), value :: max
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_box_t * graphene_box_init_from_points (graphene_box_t *box, unsigned int n_points, const graphene_point3d_t *points);
function graphene_box_init_from_points(box, n_points, points) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_box_init_from_points
  type(c_ptr), value :: box
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_box_t * graphene_box_init_from_vectors (graphene_box_t *box, unsigned int n_vectors, const graphene_vec3_t *vectors);
function graphene_box_init_from_vectors(box, n_vectors, vectors) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_box_init_from_vectors
  type(c_ptr), value :: box
  integer(c_int), value :: n_vectors
  type(c_ptr), value :: vectors
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_box_t * graphene_box_init_from_box (graphene_box_t *box, const graphene_box_t *src);
function graphene_box_init_from_box(box, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_init_from_box
  type(c_ptr), value :: box
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_box_t * graphene_box_init_from_vec3 (graphene_box_t *box, const graphene_vec3_t *min, const graphene_vec3_t *max);
function graphene_box_init_from_vec3(box, min, max) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_init_from_vec3
  type(c_ptr), value :: box
  type(c_ptr), value :: min
  type(c_ptr), value :: max
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_expand (const graphene_box_t *box, const graphene_point3d_t *point, graphene_box_t *res);
subroutine graphene_box_expand(box, point, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: point
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_expand_vec3 (const graphene_box_t *box, const graphene_vec3_t *vec, graphene_box_t *res);
subroutine graphene_box_expand_vec3(box, vec, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: vec
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_expand_scalar (const graphene_box_t *box, float scalar, graphene_box_t *res);
subroutine graphene_box_expand_scalar(box, scalar, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: box
  real(c_float), value :: scalar
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_union (const graphene_box_t *a, const graphene_box_t *b, graphene_box_t *res);
subroutine graphene_box_union(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_box_intersection (const graphene_box_t *a, const graphene_box_t *b, graphene_box_t *res);
function graphene_box_intersection(a, b, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_box_intersection
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_box_get_width (const graphene_box_t *box);
function graphene_box_get_width(box) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_box_get_width
  type(c_ptr), value :: box
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_box_get_height (const graphene_box_t *box);
function graphene_box_get_height(box) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_box_get_height
  type(c_ptr), value :: box
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_box_get_depth (const graphene_box_t *box);
function graphene_box_get_depth(box) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_box_get_depth
  type(c_ptr), value :: box
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_get_size (const graphene_box_t *box, graphene_vec3_t *size);
subroutine graphene_box_get_size(box, size) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: size
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_get_center (const graphene_box_t *box, graphene_point3d_t *center);
subroutine graphene_box_get_center(box, center) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: center
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_get_min (const graphene_box_t *box, graphene_point3d_t *min);
subroutine graphene_box_get_min(box, min) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: min
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_get_max (const graphene_box_t *box, graphene_point3d_t *max);
subroutine graphene_box_get_max(box, max) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: max
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_box_get_bounding_sphere (const graphene_box_t *box, graphene_sphere_t *sphere);
subroutine graphene_box_get_bounding_sphere(box, sphere) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: box
  type(c_ptr), value :: sphere
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_box_contains_point (const graphene_box_t *box, const graphene_point3d_t *point);
function graphene_box_contains_point(box, point) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_box_contains_point
  type(c_ptr), value :: box
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_box_contains_box (const graphene_box_t *a, const graphene_box_t *b);
function graphene_box_contains_box(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_box_contains_box
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_box_equal (const graphene_box_t *a, const graphene_box_t *b);
function graphene_box_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_box_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_zero (void);
function graphene_box_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_zero
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_one (void);
function graphene_box_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_one
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_minus_one (void);
function graphene_box_minus_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_minus_one
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_one_minus_one (void);
function graphene_box_one_minus_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_one_minus_one
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_infinite (void);
function graphene_box_infinite() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_infinite
end function

! GRAPHENE_AVAILABLE_IN_1_2
!const graphene_box_t * graphene_box_empty (void);
function graphene_box_empty() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_box_empty
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_point3d_t * graphene_point3d_alloc (void);
function graphene_point3d_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point3d_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_free (graphene_point3d_t *p);
subroutine graphene_point3d_free(p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_point3d_t * graphene_point3d_init (graphene_point3d_t *p, float x, float y, float z);
function graphene_point3d_init(p, x, y, z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_point3d_init
  type(c_ptr), value :: p
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_point3d_t * graphene_point3d_init_from_point (graphene_point3d_t *p, const graphene_point3d_t *src);
function graphene_point3d_init_from_point(p, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point3d_init_from_point
  type(c_ptr), value :: p
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_point3d_t * graphene_point3d_init_from_vec3 (graphene_point3d_t *p, const graphene_vec3_t *v);
function graphene_point3d_init_from_vec3(p, v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point3d_init_from_vec3
  type(c_ptr), value :: p
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_to_vec3 (const graphene_point3d_t *p, graphene_vec3_t *v);
subroutine graphene_point3d_to_vec3(p, v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_point3d_equal (const graphene_point3d_t *a, const graphene_point3d_t *b);
function graphene_point3d_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_point3d_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_point3d_near (const graphene_point3d_t *a, const graphene_point3d_t *b, float epsilon);
function graphene_point3d_near(a, b, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_point3d_near
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_scale (const graphene_point3d_t *p, float factor, graphene_point3d_t *res);
subroutine graphene_point3d_scale(p, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: p
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_cross (const graphene_point3d_t *a, const graphene_point3d_t *b, graphene_point3d_t *res);
subroutine graphene_point3d_cross(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_point3d_dot (const graphene_point3d_t *a, const graphene_point3d_t *b);
function graphene_point3d_dot(a, b) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_point3d_dot
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_point3d_length (const graphene_point3d_t *p);
function graphene_point3d_length(p) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_point3d_length
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_normalize (const graphene_point3d_t *p, graphene_point3d_t *res);
subroutine graphene_point3d_normalize(p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!float graphene_point3d_distance (const graphene_point3d_t *a, const graphene_point3d_t *b, graphene_vec3_t *delta);
function graphene_point3d_distance(a, b, delta) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_point3d_distance
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: delta
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_point3d_interpolate (const graphene_point3d_t *a, const graphene_point3d_t *b, double factor, graphene_point3d_t *res);
subroutine graphene_point3d_interpolate(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_point3d_normalize_viewport (const graphene_point3d_t *p, const graphene_rect_t *viewport, float z_near, float z_far, graphene_point3d_t *res);
subroutine graphene_point3d_normalize_viewport(p, viewport, z_near, z_far, res)&
& bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: p
  type(c_ptr), value :: viewport
  real(c_float), value :: z_near
  real(c_float), value :: z_far
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_point3d_t * graphene_point3d_zero (void);
function graphene_point3d_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_point3d_zero
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_sphere_t * graphene_sphere_alloc (void);
function graphene_sphere_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_sphere_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_sphere_free (graphene_sphere_t *s);
subroutine graphene_sphere_free(s) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_sphere_t * graphene_sphere_init (graphene_sphere_t *s, const graphene_point3d_t *center, float radius);
function graphene_sphere_init(s, center, radius) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_sphere_init
  type(c_ptr), value :: s
  type(c_ptr), value :: center
  real(c_float), value :: radius
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_sphere_t * graphene_sphere_init_from_points (graphene_sphere_t *s, unsigned int n_points, const graphene_point3d_t *points, const graphene_point3d_t *center);
function graphene_sphere_init_from_points(s, n_points, points, center) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_sphere_init_from_points
  type(c_ptr), value :: s
  integer(c_int), value :: n_points
  type(c_ptr), value :: points
  type(c_ptr), value :: center
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_sphere_t * graphene_sphere_init_from_vectors (graphene_sphere_t *s, unsigned int n_vectors, const graphene_vec3_t *vectors, const graphene_point3d_t *center);
function graphene_sphere_init_from_vectors(s, n_vectors, vectors, center)&
& bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_sphere_init_from_vectors
  type(c_ptr), value :: s
  integer(c_int), value :: n_vectors
  type(c_ptr), value :: vectors
  type(c_ptr), value :: center
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_sphere_get_center (const graphene_sphere_t *s, graphene_point3d_t *center);
subroutine graphene_sphere_get_center(s, center) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: center
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_sphere_get_radius (const graphene_sphere_t *s);
function graphene_sphere_get_radius(s) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_sphere_get_radius
  type(c_ptr), value :: s
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_sphere_is_empty (const graphene_sphere_t *s);
function graphene_sphere_is_empty(s) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_sphere_is_empty
  type(c_ptr), value :: s
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_sphere_equal (const graphene_sphere_t *a, const graphene_sphere_t *b);
function graphene_sphere_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_sphere_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_sphere_contains_point (const graphene_sphere_t *s, const graphene_point3d_t *point);
function graphene_sphere_contains_point(s, point) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_sphere_contains_point
  type(c_ptr), value :: s
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_sphere_distance (const graphene_sphere_t *s, const graphene_point3d_t *point);
function graphene_sphere_distance(s, point) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_sphere_distance
  type(c_ptr), value :: s
  type(c_ptr), value :: point
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_sphere_get_bounding_box (const graphene_sphere_t *s, graphene_box_t *box);
subroutine graphene_sphere_get_bounding_box(s, box) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: box
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_sphere_translate (const graphene_sphere_t *s, const graphene_point3d_t *point, graphene_sphere_t *res);
subroutine graphene_sphere_translate(s, point, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
  type(c_ptr), value :: point
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_size_t * graphene_size_alloc (void);
function graphene_size_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_size_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_size_free (graphene_size_t *s);
subroutine graphene_size_free(s) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: s
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_size_t * graphene_size_init (graphene_size_t *s, float width, float height);
function graphene_size_init(s, width, height) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_size_init
  type(c_ptr), value :: s
  real(c_float), value :: width
  real(c_float), value :: height
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_size_t * graphene_size_init_from_size (graphene_size_t *s, const graphene_size_t *src);
function graphene_size_init_from_size(s, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_size_init_from_size
  type(c_ptr), value :: s
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_size_equal (const graphene_size_t *a, const graphene_size_t *b);
function graphene_size_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_size_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_size_scale (const graphene_size_t *s, float factor, graphene_size_t *res);
subroutine graphene_size_scale(s, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: s
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_size_interpolate (const graphene_size_t *a, const graphene_size_t *b, double factor, graphene_size_t *res);
subroutine graphene_size_interpolate(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_size_t * graphene_size_zero (void);
function graphene_size_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_size_zero
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GRAPHENE_BEGIN_DECLS graphene_triangle_t * graphene_triangle_alloc (void);
function graphene_triangle_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_triangle_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_free (graphene_triangle_t *t);
subroutine graphene_triangle_free(t) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_triangle_t * graphene_triangle_init_from_point3d (graphene_triangle_t *t, const graphene_point3d_t *a, const graphene_point3d_t *b, const graphene_point3d_t *c);
function graphene_triangle_init_from_point3d(t, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_triangle_init_from_point3d
  type(c_ptr), value :: t
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_triangle_t * graphene_triangle_init_from_vec3 (graphene_triangle_t *t, const graphene_vec3_t *a, const graphene_vec3_t *b, const graphene_vec3_t *c);
function graphene_triangle_init_from_vec3(t, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_triangle_init_from_vec3
  type(c_ptr), value :: t
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end function

! GRAPHENE_AVAILABLE_IN_1_10
!graphene_triangle_t * graphene_triangle_init_from_float (graphene_triangle_t *t, const float *a, const float *b, const float *c);
function graphene_triangle_init_from_float(t, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_triangle_init_from_float
  type(c_ptr), value :: t
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_points (const graphene_triangle_t *t, graphene_point3d_t *a, graphene_point3d_t *b, graphene_point3d_t *c);
subroutine graphene_triangle_get_points(t, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_vertices (const graphene_triangle_t *t, graphene_vec3_t *a, graphene_vec3_t *b, graphene_vec3_t *c);
subroutine graphene_triangle_get_vertices(t, a, b, c) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: c
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!float graphene_triangle_get_area (const graphene_triangle_t *t);
function graphene_triangle_get_area(t) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_triangle_get_area
  type(c_ptr), value :: t
end function

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_midpoint (const graphene_triangle_t *t, graphene_point3d_t *res);
subroutine graphene_triangle_get_midpoint(t, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_normal (const graphene_triangle_t *t, graphene_vec3_t *res);
subroutine graphene_triangle_get_normal(t, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_plane (const graphene_triangle_t *t, graphene_plane_t *res);
subroutine graphene_triangle_get_plane(t, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_triangle_get_bounding_box (const graphene_triangle_t *t, graphene_box_t *res);
subroutine graphene_triangle_get_bounding_box(t, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: t
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_triangle_get_barycoords (const graphene_triangle_t *t, const graphene_point3d_t *p, graphene_vec2_t *res);
function graphene_triangle_get_barycoords(t, p, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_triangle_get_barycoords
  type(c_ptr), value :: t
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_triangle_get_uv (const graphene_triangle_t *t, const graphene_point3d_t *p, const graphene_vec2_t *uv_a, const graphene_vec2_t *uv_b, const graphene_vec2_t *uv_c, graphene_vec2_t *res);
function graphene_triangle_get_uv(t, p, uv_a, uv_b, uv_c, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_triangle_get_uv
  type(c_ptr), value :: t
  type(c_ptr), value :: p
  type(c_ptr), value :: uv_a
  type(c_ptr), value :: uv_b
  type(c_ptr), value :: uv_c
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_triangle_contains_point (const graphene_triangle_t *t, const graphene_point3d_t *p);
function graphene_triangle_contains_point(t, p) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_triangle_contains_point
  type(c_ptr), value :: t
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_triangle_equal (const graphene_triangle_t *a, const graphene_triangle_t *b);
function graphene_triangle_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_triangle_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_matrix_t * graphene_matrix_alloc (void);
function graphene_matrix_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_free (graphene_matrix_t *m);
subroutine graphene_matrix_free(m) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_identity (graphene_matrix_t *m);
function graphene_matrix_init_identity(m) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_identity
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_from_float (graphene_matrix_t *m, const float *v);
function graphene_matrix_init_from_float(m, v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_from_float
  type(c_ptr), value :: m
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_from_vec4 (graphene_matrix_t *m, const graphene_vec4_t *v0, const graphene_vec4_t *v1, const graphene_vec4_t *v2, const graphene_vec4_t *v3);
function graphene_matrix_init_from_vec4(m, v0, v1, v2, v3) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_from_vec4
  type(c_ptr), value :: m
  type(c_ptr), value :: v0
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  type(c_ptr), value :: v3
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_from_matrix (graphene_matrix_t *m, const graphene_matrix_t *src);
function graphene_matrix_init_from_matrix(m, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_from_matrix
  type(c_ptr), value :: m
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_perspective (graphene_matrix_t *m, float fovy, float aspect, float z_near, float z_far);
function graphene_matrix_init_perspective(m, fovy, aspect, z_near, z_far)&
& bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_perspective
  type(c_ptr), value :: m
  real(c_float), value :: fovy
  real(c_float), value :: aspect
  real(c_float), value :: z_near
  real(c_float), value :: z_far
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_ortho (graphene_matrix_t *m, float left, float right, float top, float bottom, float z_near, float z_far);
function graphene_matrix_init_ortho(m, left, right, top, bottom, z_near, z_far)&
& bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_ortho
  type(c_ptr), value :: m
  real(c_float), value :: left
  real(c_float), value :: right
  real(c_float), value :: top
  real(c_float), value :: bottom
  real(c_float), value :: z_near
  real(c_float), value :: z_far
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_look_at (graphene_matrix_t *m, const graphene_vec3_t *eye, const graphene_vec3_t *center, const graphene_vec3_t *up);
function graphene_matrix_init_look_at(m, eye, center, up) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_look_at
  type(c_ptr), value :: m
  type(c_ptr), value :: eye
  type(c_ptr), value :: center
  type(c_ptr), value :: up
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_matrix_t * graphene_matrix_init_frustum (graphene_matrix_t *m, float left, float right, float bottom, float top, float z_near, float z_far);
function graphene_matrix_init_frustum(m, left, right, bottom, top, z_near,&
& z_far) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_frustum
  type(c_ptr), value :: m
  real(c_float), value :: left
  real(c_float), value :: right
  real(c_float), value :: bottom
  real(c_float), value :: top
  real(c_float), value :: z_near
  real(c_float), value :: z_far
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_scale (graphene_matrix_t *m, float x, float y, float z);
function graphene_matrix_init_scale(m, x, y, z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_scale
  type(c_ptr), value :: m
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_translate (graphene_matrix_t *m, const graphene_point3d_t *p);
function graphene_matrix_init_translate(m, p) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_matrix_init_translate
  type(c_ptr), value :: m
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_rotate (graphene_matrix_t *m, float angle, const graphene_vec3_t *axis);
function graphene_matrix_init_rotate(m, angle, axis) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_rotate
  type(c_ptr), value :: m
  real(c_float), value :: angle
  type(c_ptr), value :: axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_skew (graphene_matrix_t *m, float x_skew, float y_skew);
function graphene_matrix_init_skew(m, x_skew, y_skew) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_matrix_init_skew
  type(c_ptr), value :: m
  real(c_float), value :: x_skew
  real(c_float), value :: y_skew
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_matrix_t * graphene_matrix_init_from_2d (graphene_matrix_t *m, double xx, double yx, double xy, double yy, double x_0, double y_0);
function graphene_matrix_init_from_2d(m, xx, yx, xy, yy, x_0, y_0) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: graphene_matrix_init_from_2d
  type(c_ptr), value :: m
  real(c_double), value :: xx
  real(c_double), value :: yx
  real(c_double), value :: xy
  real(c_double), value :: yy
  real(c_double), value :: x_0
  real(c_double), value :: y_0
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_is_identity (const graphene_matrix_t *m);
function graphene_matrix_is_identity(m) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_is_identity
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_is_2d (const graphene_matrix_t *m);
function graphene_matrix_is_2d(m) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_is_2d
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_is_backface_visible (const graphene_matrix_t *m);
function graphene_matrix_is_backface_visible(m) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_is_backface_visible
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_is_singular (const graphene_matrix_t *m);
function graphene_matrix_is_singular(m) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_is_singular
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_to_float (const graphene_matrix_t *m, float *v);
subroutine graphene_matrix_to_float(m, v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_to_2d (const graphene_matrix_t *m, double *xx, double *yx, double *xy, double *yy, double *x_0, double *y_0);
function graphene_matrix_to_2d(m, xx, yx, xy, yy, x_0, y_0) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_to_2d
  type(c_ptr), value :: m
  type(c_ptr), value :: xx
  type(c_ptr), value :: yx
  type(c_ptr), value :: xy
  type(c_ptr), value :: yy
  type(c_ptr), value :: x_0
  type(c_ptr), value :: y_0
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_get_row (const graphene_matrix_t *m, unsigned int index_, graphene_vec4_t *res);
subroutine graphene_matrix_get_row(m, index_, res) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: m
  integer(c_int), value :: index_
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_matrix_get_value (const graphene_matrix_t *m, unsigned int row, unsigned int col);
function graphene_matrix_get_value(m, row, col) bind(c)
  use iso_c_binding, only: c_float, c_ptr, c_int
  real(c_float) :: graphene_matrix_get_value
  type(c_ptr), value :: m
  integer(c_int), value :: row
  integer(c_int), value :: col
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_multiply (const graphene_matrix_t *a, const graphene_matrix_t *b, graphene_matrix_t *res);
subroutine graphene_matrix_multiply(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_matrix_determinant (const graphene_matrix_t *m);
function graphene_matrix_determinant(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_determinant
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transform_vec4 (const graphene_matrix_t *m, const graphene_vec4_t *v, graphene_vec4_t *res);
subroutine graphene_matrix_transform_vec4(m, v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transform_vec3 (const graphene_matrix_t *m, const graphene_vec3_t *v, graphene_vec3_t *res);
subroutine graphene_matrix_transform_vec3(m, v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transform_point (const graphene_matrix_t *m, const graphene_point_t *p, graphene_point_t *res);
subroutine graphene_matrix_transform_point(m, p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_transform_point3d (const graphene_matrix_t *m, const graphene_point3d_t *p, graphene_point3d_t *res);
subroutine graphene_matrix_transform_point3d(m, p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transform_rect (const graphene_matrix_t *m, const graphene_rect_t *r, graphene_quad_t *res);
subroutine graphene_matrix_transform_rect(m, r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transform_bounds (const graphene_matrix_t *m, const graphene_rect_t *r, graphene_rect_t *res);
subroutine graphene_matrix_transform_bounds(m, r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_transform_sphere (const graphene_matrix_t *m, const graphene_sphere_t *s, graphene_sphere_t *res);
subroutine graphene_matrix_transform_sphere(m, s, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: s
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_transform_box (const graphene_matrix_t *m, const graphene_box_t *b, graphene_box_t *res);
subroutine graphene_matrix_transform_box(m, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_matrix_transform_ray (const graphene_matrix_t *m, const graphene_ray_t *r, graphene_ray_t *res);
subroutine graphene_matrix_transform_ray(m, r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_project_point (const graphene_matrix_t *m, const graphene_point_t *p, graphene_point_t *res);
subroutine graphene_matrix_project_point(m, p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_project_rect_bounds (const graphene_matrix_t *m, const graphene_rect_t *r, graphene_rect_t *res);
subroutine graphene_matrix_project_rect_bounds(m, r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_project_rect (const graphene_matrix_t *m, const graphene_rect_t *r, graphene_quad_t *res);
subroutine graphene_matrix_project_rect(m, r, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_untransform_point (const graphene_matrix_t *m, const graphene_point_t *p, const graphene_rect_t *bounds, graphene_point_t *res);
function graphene_matrix_untransform_point(m, p, bounds, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_untransform_point
  type(c_ptr), value :: m
  type(c_ptr), value :: p
  type(c_ptr), value :: bounds
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_untransform_bounds (const graphene_matrix_t *m, const graphene_rect_t *r, const graphene_rect_t *bounds, graphene_rect_t *res);
subroutine graphene_matrix_untransform_bounds(m, r, bounds, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: r
  type(c_ptr), value :: bounds
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_unproject_point3d (const graphene_matrix_t *projection, const graphene_matrix_t *modelview, const graphene_point3d_t *point, graphene_point3d_t *res);
subroutine graphene_matrix_unproject_point3d(projection, modelview, point, res)&
& bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: projection
  type(c_ptr), value :: modelview
  type(c_ptr), value :: point
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_translate (graphene_matrix_t *m, const graphene_point3d_t *pos);
subroutine graphene_matrix_translate(m, pos) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: pos
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_rotate (graphene_matrix_t *m, float angle, const graphene_vec3_t *axis);
subroutine graphene_matrix_rotate(m, angle, axis) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: angle
  type(c_ptr), value :: axis
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_rotate_x (graphene_matrix_t *m, float angle);
subroutine graphene_matrix_rotate_x(m, angle) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: angle
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_rotate_y (graphene_matrix_t *m, float angle);
subroutine graphene_matrix_rotate_y(m, angle) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: angle
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_rotate_z (graphene_matrix_t *m, float angle);
subroutine graphene_matrix_rotate_z(m, angle) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: angle
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_rotate_quaternion (graphene_matrix_t *m, const graphene_quaternion_t *q);
subroutine graphene_matrix_rotate_quaternion(m, q) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: q
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_matrix_rotate_euler (graphene_matrix_t *m, const graphene_euler_t *e);
subroutine graphene_matrix_rotate_euler(m, e) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: e
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_scale (graphene_matrix_t *m, float factor_x, float factor_y, float factor_z);
subroutine graphene_matrix_scale(m, factor_x, factor_y, factor_z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: factor_x
  real(c_float), value :: factor_y
  real(c_float), value :: factor_z
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_skew_xy (graphene_matrix_t *m, float factor);
subroutine graphene_matrix_skew_xy(m, factor) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: factor
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_skew_xz (graphene_matrix_t *m, float factor);
subroutine graphene_matrix_skew_xz(m, factor) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: factor
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_skew_yz (graphene_matrix_t *m, float factor);
subroutine graphene_matrix_skew_yz(m, factor) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: factor
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_transpose (const graphene_matrix_t *m, graphene_matrix_t *res);
subroutine graphene_matrix_transpose(m, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_matrix_inverse (const graphene_matrix_t *m, graphene_matrix_t *res);
function graphene_matrix_inverse(m, res) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_inverse
  type(c_ptr), value :: m
  type(c_ptr), value :: res
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_perspective (const graphene_matrix_t *m, float depth, graphene_matrix_t *res);
subroutine graphene_matrix_perspective(m, depth, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: m
  real(c_float), value :: depth
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_normalize (const graphene_matrix_t *m, graphene_matrix_t *res);
subroutine graphene_matrix_normalize(m, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_matrix_get_x_translation (const graphene_matrix_t *m);
function graphene_matrix_get_x_translation(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_x_translation
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_matrix_get_y_translation (const graphene_matrix_t *m);
function graphene_matrix_get_y_translation(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_y_translation
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_10
!float graphene_matrix_get_z_translation (const graphene_matrix_t *m);
function graphene_matrix_get_z_translation(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_z_translation
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_matrix_get_x_scale (const graphene_matrix_t *m);
function graphene_matrix_get_x_scale(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_x_scale
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_matrix_get_y_scale (const graphene_matrix_t *m);
function graphene_matrix_get_y_scale(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_y_scale
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_matrix_get_z_scale (const graphene_matrix_t *m);
function graphene_matrix_get_z_scale(m) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_matrix_get_z_scale
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_interpolate (const graphene_matrix_t *a, const graphene_matrix_t *b, double factor, graphene_matrix_t *res);
subroutine graphene_matrix_interpolate(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_matrix_near (const graphene_matrix_t *a, const graphene_matrix_t *b, float epsilon);
function graphene_matrix_near(a, b, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_matrix_near
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_matrix_equal (const graphene_matrix_t *a, const graphene_matrix_t *b);
function graphene_matrix_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_matrix_equal_fast (const graphene_matrix_t *a, const graphene_matrix_t *b);
function graphene_matrix_equal_fast(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_equal_fast
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_matrix_print (const graphene_matrix_t *m);
subroutine graphene_matrix_print(m) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: m
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_matrix_decompose (const graphene_matrix_t *m, graphene_vec3_t *translate, graphene_vec3_t *scale, graphene_quaternion_t *rotate, graphene_vec3_t *shear, graphene_vec4_t *perspective);
function graphene_matrix_decompose(m, translate, scale, rotate, shear,&
& perspective) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_matrix_decompose
  type(c_ptr), value :: m
  type(c_ptr), value :: translate
  type(c_ptr), value :: scale
  type(c_ptr), value :: rotate
  type(c_ptr), value :: shear
  type(c_ptr), value :: perspective
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_point_get_type (void);
function graphene_point_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_point_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_point3d_get_type (void);
function graphene_point3d_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_point3d_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_size_get_type (void);
function graphene_size_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_size_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_rect_get_type (void);
function graphene_rect_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_rect_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_vec2_get_type (void);
function graphene_vec2_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_vec2_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_vec3_get_type (void);
function graphene_vec3_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_vec3_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_vec4_get_type (void);
function graphene_vec4_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_vec4_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_quad_get_type (void);
function graphene_quad_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_quad_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_quaternion_get_type (void);
function graphene_quaternion_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_quaternion_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GType graphene_matrix_get_type (void);
function graphene_matrix_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_matrix_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_plane_get_type (void);
function graphene_plane_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_plane_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_frustum_get_type (void);
function graphene_frustum_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_frustum_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_sphere_get_type (void);
function graphene_sphere_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_sphere_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_box_get_type (void);
function graphene_box_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_box_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_triangle_get_type (void);
function graphene_triangle_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_triangle_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_2
!GType graphene_euler_get_type (void);
function graphene_euler_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_euler_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_4
!GType graphene_ray_get_type (void);
function graphene_ray_get_type() bind(c)
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: graphene_ray_get_type
end function

! GRAPHENE_AVAILABLE_IN_1_4
!GRAPHENE_BEGIN_DECLS graphene_ray_t * graphene_ray_alloc (void);
function graphene_ray_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_ray_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_ray_free (graphene_ray_t *r);
subroutine graphene_ray_free(r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!graphene_ray_t * graphene_ray_init (graphene_ray_t *r, const graphene_point3d_t *origin, const graphene_vec3_t *direction);
function graphene_ray_init(r, origin, direction) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_ray_init
  type(c_ptr), value :: r
  type(c_ptr), value :: origin
  type(c_ptr), value :: direction
end function

! GRAPHENE_AVAILABLE_IN_1_4
!graphene_ray_t * graphene_ray_init_from_ray (graphene_ray_t *r, const graphene_ray_t *src);
function graphene_ray_init_from_ray(r, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_ray_init_from_ray
  type(c_ptr), value :: r
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_4
!graphene_ray_t * graphene_ray_init_from_vec3 (graphene_ray_t *r, const graphene_vec3_t *origin, const graphene_vec3_t *direction);
function graphene_ray_init_from_vec3(r, origin, direction) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_ray_init_from_vec3
  type(c_ptr), value :: r
  type(c_ptr), value :: origin
  type(c_ptr), value :: direction
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_ray_get_origin (const graphene_ray_t *r, graphene_point3d_t *origin);
subroutine graphene_ray_get_origin(r, origin) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: origin
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_ray_get_direction (const graphene_ray_t *r, graphene_vec3_t *direction);
subroutine graphene_ray_get_direction(r, direction) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: direction
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_ray_get_position_at (const graphene_ray_t *r, float t, graphene_point3d_t *position);
subroutine graphene_ray_get_position_at(r, t, position) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: r
  real(c_float), value :: t
  type(c_ptr), value :: position
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!float graphene_ray_get_distance_to_point (const graphene_ray_t *r, const graphene_point3d_t *p);
function graphene_ray_get_distance_to_point(r, p) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_ray_get_distance_to_point
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_4
!float graphene_ray_get_distance_to_plane (const graphene_ray_t *r, const graphene_plane_t *p);
function graphene_ray_get_distance_to_plane(r, p) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_ray_get_distance_to_plane
  type(c_ptr), value :: r
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_4
!bool graphene_ray_equal (const graphene_ray_t *a, const graphene_ray_t *b);
function graphene_ray_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_ray_get_closest_point_to_point (const graphene_ray_t *r, const graphene_point3d_t *p, graphene_point3d_t *res);
subroutine graphene_ray_get_closest_point_to_point(r, p, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: r
  type(c_ptr), value :: p
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!graphene_ray_intersection_kind_t graphene_ray_intersect_sphere (const graphene_ray_t *r, const graphene_sphere_t *s, float *t_out);
function graphene_ray_intersect_sphere(r, s, t_out) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersect_sphere
  type(c_ptr), value :: r
  type(c_ptr), value :: s
  type(c_ptr), value :: t_out
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_ray_intersects_sphere (const graphene_ray_t *r, const graphene_sphere_t *s);
function graphene_ray_intersects_sphere(r, s) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersects_sphere
  type(c_ptr), value :: r
  type(c_ptr), value :: s
end function

! GRAPHENE_AVAILABLE_IN_1_10
!graphene_ray_intersection_kind_t graphene_ray_intersect_box (const graphene_ray_t *r, const graphene_box_t *b, float *t_out);
function graphene_ray_intersect_box(r, b, t_out) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersect_box
  type(c_ptr), value :: r
  type(c_ptr), value :: b
  type(c_ptr), value :: t_out
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_ray_intersects_box (const graphene_ray_t *r, const graphene_box_t *b);
function graphene_ray_intersects_box(r, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersects_box
  type(c_ptr), value :: r
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_10
!graphene_ray_intersection_kind_t graphene_ray_intersect_triangle (const graphene_ray_t *r, const graphene_triangle_t *t, float *t_out);
function graphene_ray_intersect_triangle(r, t, t_out) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersect_triangle
  type(c_ptr), value :: r
  type(c_ptr), value :: t
  type(c_ptr), value :: t_out
end function

! GRAPHENE_AVAILABLE_IN_1_10
!bool graphene_ray_intersects_triangle (const graphene_ray_t *r, const graphene_triangle_t *t);
function graphene_ray_intersects_triangle(r, t) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_ray_intersects_triangle
  type(c_ptr), value :: r
  type(c_ptr), value :: t
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_quad_t * graphene_quad_alloc (void);
function graphene_quad_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quad_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quad_free (graphene_quad_t *q);
subroutine graphene_quad_free(q) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quad_t * graphene_quad_init (graphene_quad_t *q, const graphene_point_t *p1, const graphene_point_t *p2, const graphene_point_t *p3, const graphene_point_t *p4);
function graphene_quad_init(q, p1, p2, p3, p4) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quad_init
  type(c_ptr), value :: q
  type(c_ptr), value :: p1
  type(c_ptr), value :: p2
  type(c_ptr), value :: p3
  type(c_ptr), value :: p4
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quad_t * graphene_quad_init_from_rect (graphene_quad_t *q, const graphene_rect_t *r);
function graphene_quad_init_from_rect(q, r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quad_init_from_rect
  type(c_ptr), value :: q
  type(c_ptr), value :: r
end function

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_quad_contains (const graphene_quad_t *q, const graphene_point_t *p);
function graphene_quad_contains(q, p) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_quad_contains
  type(c_ptr), value :: q
  type(c_ptr), value :: p
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quad_bounds (const graphene_quad_t *q, graphene_rect_t *r);
subroutine graphene_quad_bounds(q, r) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: r
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_point_t *graphene_quad_get_point (const graphene_quad_t *q, unsigned int index_);
function graphene_quad_get_point(q, index_) bind(c)
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: graphene_quad_get_point
  type(c_ptr), value :: q
  integer(c_int), value :: index_
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_vec2_t * graphene_vec2_alloc (void);
function graphene_vec2_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_free (graphene_vec2_t *v);
subroutine graphene_vec2_free(v) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec2_t * graphene_vec2_init (graphene_vec2_t *v, float x, float y);
function graphene_vec2_init(v, x, y) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_vec2_init
  type(c_ptr), value :: v
  real(c_float), value :: x
  real(c_float), value :: y
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec2_t * graphene_vec2_init_from_vec2 (graphene_vec2_t *v, const graphene_vec2_t *src);
function graphene_vec2_init_from_vec2(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_init_from_vec2
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_vec2_t * graphene_vec2_init_from_float (graphene_vec2_t *v, const float *src);
function graphene_vec2_init_from_float(v, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_init_from_float
  type(c_ptr), value :: v
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_to_float (const graphene_vec2_t *v, float *dest);
subroutine graphene_vec2_to_float(v, dest) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: dest
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_add (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_add(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_subtract (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_subtract(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_multiply (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_multiply(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_divide (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_divide(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec2_dot (const graphene_vec2_t *a, const graphene_vec2_t *b);
function graphene_vec2_dot(a, b) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec2_dot
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec2_length (const graphene_vec2_t *v);
function graphene_vec2_length(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec2_length
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_normalize (const graphene_vec2_t *v, graphene_vec2_t *res);
subroutine graphene_vec2_normalize(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec2_scale (const graphene_vec2_t *v, float factor, graphene_vec2_t *res);
subroutine graphene_vec2_scale(v, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: v
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_vec2_negate (const graphene_vec2_t *v, graphene_vec2_t *res);
subroutine graphene_vec2_negate(v, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: v
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec2_near (const graphene_vec2_t *v1, const graphene_vec2_t *v2, float epsilon);
function graphene_vec2_near(v1, v2, epsilon) bind(c)
  use iso_c_binding, only: c_int, c_ptr, c_float
  integer(c_int) :: graphene_vec2_near
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_float), value :: epsilon
end function

! GRAPHENE_AVAILABLE_IN_1_2
!bool graphene_vec2_equal (const graphene_vec2_t *v1, const graphene_vec2_t *v2);
function graphene_vec2_equal(v1, v2) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_vec2_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_min (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_min(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_vec2_max (const graphene_vec2_t *a, const graphene_vec2_t *b, graphene_vec2_t *res);
subroutine graphene_vec2_max(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_vec2_interpolate (const graphene_vec2_t *v1, const graphene_vec2_t *v2, double factor, graphene_vec2_t *res);
subroutine graphene_vec2_interpolate(v1, v2, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
  real(c_double), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec2_get_x (const graphene_vec2_t *v);
function graphene_vec2_get_x(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec2_get_x
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_vec2_get_y (const graphene_vec2_t *v);
function graphene_vec2_get_y(v) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_vec2_get_y
  type(c_ptr), value :: v
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec2_t * graphene_vec2_zero (void);
function graphene_vec2_zero() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_zero
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec2_t * graphene_vec2_one (void);
function graphene_vec2_one() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_one
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec2_t * graphene_vec2_x_axis (void);
function graphene_vec2_x_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_x_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!const graphene_vec2_t * graphene_vec2_y_axis (void);
function graphene_vec2_y_axis() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_vec2_y_axis
end function

! GRAPHENE_AVAILABLE_IN_1_0
!GRAPHENE_BEGIN_DECLS graphene_quaternion_t * graphene_quaternion_alloc (void);
function graphene_quaternion_alloc() bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_alloc
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_free (graphene_quaternion_t *q);
subroutine graphene_quaternion_free(q) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init (graphene_quaternion_t *q, float x, float y, float z, float w);
function graphene_quaternion_init(q, x, y, z, w) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_quaternion_init
  type(c_ptr), value :: q
  real(c_float), value :: x
  real(c_float), value :: y
  real(c_float), value :: z
  real(c_float), value :: w
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_identity (graphene_quaternion_t *q);
function graphene_quaternion_init_identity(q) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_init_identity
  type(c_ptr), value :: q
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_from_quaternion (graphene_quaternion_t *q, const graphene_quaternion_t *src);
function graphene_quaternion_init_from_quaternion(q, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_init_from_quaternion
  type(c_ptr), value :: q
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_from_vec4 (graphene_quaternion_t *q, const graphene_vec4_t *src);
function graphene_quaternion_init_from_vec4(q, src) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_init_from_vec4
  type(c_ptr), value :: q
  type(c_ptr), value :: src
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_from_matrix (graphene_quaternion_t *q, const graphene_matrix_t *m);
function graphene_quaternion_init_from_matrix(q, m) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_init_from_matrix
  type(c_ptr), value :: q
  type(c_ptr), value :: m
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_from_angles (graphene_quaternion_t *q, float deg_x, float deg_y, float deg_z);
function graphene_quaternion_init_from_angles(q, deg_x, deg_y, deg_z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_quaternion_init_from_angles
  type(c_ptr), value :: q
  real(c_float), value :: deg_x
  real(c_float), value :: deg_y
  real(c_float), value :: deg_z
end function

! GRAPHENE_AVAILABLE_IN_1_4
!graphene_quaternion_t * graphene_quaternion_init_from_radians (graphene_quaternion_t *q, float rad_x, float rad_y, float rad_z);
function graphene_quaternion_init_from_radians(q, rad_x, rad_y, rad_z) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_quaternion_init_from_radians
  type(c_ptr), value :: q
  real(c_float), value :: rad_x
  real(c_float), value :: rad_y
  real(c_float), value :: rad_z
end function

! GRAPHENE_AVAILABLE_IN_1_0
!graphene_quaternion_t * graphene_quaternion_init_from_angle_vec3 (graphene_quaternion_t *q, float angle, const graphene_vec3_t *axis);
function graphene_quaternion_init_from_angle_vec3(q, angle, axis) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr) :: graphene_quaternion_init_from_angle_vec3
  type(c_ptr), value :: q
  real(c_float), value :: angle
  type(c_ptr), value :: axis
end function

! GRAPHENE_AVAILABLE_IN_1_2
!graphene_quaternion_t * graphene_quaternion_init_from_euler (graphene_quaternion_t *q, const graphene_euler_t *e);
function graphene_quaternion_init_from_euler(q, e) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: graphene_quaternion_init_from_euler
  type(c_ptr), value :: q
  type(c_ptr), value :: e
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_to_vec4 (const graphene_quaternion_t *q, graphene_vec4_t *res);
subroutine graphene_quaternion_to_vec4(q, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_to_matrix (const graphene_quaternion_t *q, graphene_matrix_t *m);
subroutine graphene_quaternion_to_matrix(q, m) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: m
end subroutine

! GRAPHENE_AVAILABLE_IN_1_2
!void graphene_quaternion_to_angles (const graphene_quaternion_t *q, float *deg_x, float *deg_y, float *deg_z);
subroutine graphene_quaternion_to_angles(q, deg_x, deg_y, deg_z) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: deg_x
  type(c_ptr), value :: deg_y
  type(c_ptr), value :: deg_z
end subroutine

! GRAPHENE_AVAILABLE_IN_1_4
!void graphene_quaternion_to_radians (const graphene_quaternion_t *q, float *rad_x, float *rad_y, float *rad_z);
subroutine graphene_quaternion_to_radians(q, rad_x, rad_y, rad_z) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: rad_x
  type(c_ptr), value :: rad_y
  type(c_ptr), value :: rad_z
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_to_angle_vec3 (const graphene_quaternion_t *q, float *angle, graphene_vec3_t *axis);
subroutine graphene_quaternion_to_angle_vec3(q, angle, axis) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: angle
  type(c_ptr), value :: axis
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!bool graphene_quaternion_equal (const graphene_quaternion_t *a, const graphene_quaternion_t *b);
function graphene_quaternion_equal(a, b) bind(c)
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: graphene_quaternion_equal
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!float graphene_quaternion_dot (const graphene_quaternion_t *a, const graphene_quaternion_t *b);
function graphene_quaternion_dot(a, b) bind(c)
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: graphene_quaternion_dot
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_invert (const graphene_quaternion_t *q, graphene_quaternion_t *res);
subroutine graphene_quaternion_invert(q, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_normalize (const graphene_quaternion_t *q, graphene_quaternion_t *res);
subroutine graphene_quaternion_normalize(q, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: q
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_0
!void graphene_quaternion_slerp (const graphene_quaternion_t *a, const graphene_quaternion_t *b, float factor, graphene_quaternion_t *res);
subroutine graphene_quaternion_slerp(a, b, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_quaternion_multiply (const graphene_quaternion_t *a, const graphene_quaternion_t *b, graphene_quaternion_t *res);
subroutine graphene_quaternion_multiply(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_quaternion_scale (const graphene_quaternion_t *q, float factor, graphene_quaternion_t *res);
subroutine graphene_quaternion_scale(q, factor, res) bind(c)
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: q
  real(c_float), value :: factor
  type(c_ptr), value :: res
end subroutine

! GRAPHENE_AVAILABLE_IN_1_10
!void graphene_quaternion_add (const graphene_quaternion_t *a, const graphene_quaternion_t *b, graphene_quaternion_t *res);
subroutine graphene_quaternion_add(a, b, res) bind(c)
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
  type(c_ptr), value :: res
end subroutine

end interface
end module graphene
