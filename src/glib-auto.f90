! Automatically generated by cfwrapper.py on Wed Feb 20 02:32:27 2013
! Please do not modify.
! This file is part of the gtk-fortran GTK+ Fortran Interface library.
! GNU General Public License version 3

module g
implicit none
interface

!   gboolean g_module_supported (void) G_GNUC_CONST;
function g_module_supported() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_module_supported
end function

!  gboolean g_module_close (GModule *module);
function g_module_close(module) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_module_close
  type(c_ptr), value :: module
end function

!  void g_module_make_resident (GModule *module);
subroutine g_module_make_resident(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  G_CONST_RETURN gchar* g_module_error (void);
function g_module_error() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_module_error
end function

!  gboolean g_module_symbol (GModule *module, const gchar *symbol_name, gpointer *symbol);
function g_module_symbol(module, symbol_name, symbol) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_module_symbol
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: symbol_name
  type(c_ptr), value :: symbol
end function

!  gchar* g_module_build_path (const gchar *directory, const gchar *module_name);
function g_module_build_path(directory, module_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_module_build_path
  character(kind=c_char), dimension(*) :: directory
  character(kind=c_char), dimension(*) :: module_name
end function

!   guint g_bus_watch_name (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name(bus_type, name, flags, name_appeared_handler, name_va&
&nished_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_watch_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! guint g_bus_watch_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GBusNameAppearedCallback name_appeared_handler, GBusNameVanishedCallback name_vanished_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_watch_name_on_connection(connection, name, flags, name_appeared_&
&handler, name_vanished_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_watch_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_appeared_handler
  type(c_funptr), value :: name_vanished_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! guint g_bus_watch_name_with_closures (GBusType bus_type, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_with_closures(bus_type, name, flags, name_appeared_cl&
&osure, name_vanished_closure) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_watch_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! guint g_bus_watch_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameWatcherFlags flags, GClosure *name_appeared_closure, GClosure *name_vanished_closure);
function g_bus_watch_name_on_connection_with_closures(connection, name, flags, &
&name_appeared_closure, name_vanished_closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_watch_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_appeared_closure
  type(c_ptr), value :: name_vanished_closure
end function

! void g_bus_unwatch_name (guint watcher_id);
subroutine g_bus_unwatch_name(watcher_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: watcher_id
end subroutine

!   GType g_zlib_compressor_get_type (void) G_GNUC_CONST;
function g_zlib_compressor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_compressor_get_type
end function

!  GZlibCompressor *g_zlib_compressor_new (GZlibCompressorFormat format, int level);
function g_zlib_compressor_new(format, level) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_zlib_compressor_new
  integer(c_int), value :: format
  integer(c_int), value :: level
end function

!  GFileInfo *g_zlib_compressor_get_file_info (GZlibCompressor *compressor);
function g_zlib_compressor_get_file_info(compressor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_zlib_compressor_get_file_info
  type(c_ptr), value :: compressor
end function

! void g_zlib_compressor_set_file_info (GZlibCompressor *compressor, GFileInfo *file_info);
subroutine g_zlib_compressor_set_file_info(compressor, file_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: compressor
  type(c_ptr), value :: file_info
end subroutine

!   GType g_native_volume_monitor_get_type (void) G_GNUC_CONST;
function g_native_volume_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_native_volume_monitor_get_type
end function

!   GType g_emblem_get_type (void) G_GNUC_CONST;
function g_emblem_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblem_get_type
end function

!  GEmblem *g_emblem_new (GIcon *icon);
function g_emblem_new(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblem_new
  type(c_ptr), value :: icon
end function

! GEmblem *g_emblem_new_with_origin (GIcon *icon, GEmblemOrigin origin);
function g_emblem_new_with_origin(icon, origin) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_emblem_new_with_origin
  type(c_ptr), value :: icon
  integer(c_int), value :: origin
end function

! GIcon *g_emblem_get_icon (GEmblem *emblem);
function g_emblem_get_icon(emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblem_get_icon
  type(c_ptr), value :: emblem
end function

! GEmblemOrigin g_emblem_get_origin (GEmblem *emblem);
function g_emblem_get_origin(emblem) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_emblem_get_origin
  type(c_ptr), value :: emblem
end function

!   GType g_file_get_type (void) G_GNUC_CONST;
function g_file_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_get_type
end function

!  GFile * g_file_new_for_path (const char *path);
function g_file_new_for_path(path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_path
  character(kind=c_char), dimension(*) :: path
end function

! GFile * g_file_new_for_uri (const char *uri);
function g_file_new_for_uri(uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_uri
  character(kind=c_char), dimension(*) :: uri
end function

! GFile * g_file_new_for_commandline_arg (const char *arg);
function g_file_new_for_commandline_arg(arg) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_new_for_commandline_arg
  character(kind=c_char), dimension(*) :: arg
end function

! GFile * g_file_parse_name (const char *parse_name);
function g_file_parse_name(parse_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_parse_name
  character(kind=c_char), dimension(*) :: parse_name
end function

! GFile * g_file_dup (GFile *file);
function g_file_dup(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_dup
  type(c_ptr), value :: file
end function

! guint g_file_hash (gconstpointer file);
function g_file_hash(file) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_hash
  type(c_ptr), value :: file
end function

! gboolean g_file_equal (GFile *file1, GFile *file2);
function g_file_equal(file1, file2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_equal
  type(c_ptr), value :: file1
  type(c_ptr), value :: file2
end function

! char * g_file_get_basename (GFile *file);
function g_file_get_basename(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_basename
  type(c_ptr), value :: file
end function

! char * g_file_get_path (GFile *file);
function g_file_get_path(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_path
  type(c_ptr), value :: file
end function

! char * g_file_get_uri (GFile *file);
function g_file_get_uri(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_uri
  type(c_ptr), value :: file
end function

! char * g_file_get_parse_name (GFile *file);
function g_file_get_parse_name(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_parse_name
  type(c_ptr), value :: file
end function

! GFile * g_file_get_parent (GFile *file);
function g_file_get_parent(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_parent
  type(c_ptr), value :: file
end function

! gboolean g_file_has_parent (GFile *file, GFile *parent);
function g_file_has_parent(file, parent) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_has_parent
  type(c_ptr), value :: file
  type(c_ptr), value :: parent
end function

! GFile * g_file_get_child (GFile *file, const char *name);
function g_file_get_child(file, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_get_child
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: name
end function

! GFile * g_file_get_child_for_display_name (GFile *file, const char *display_name, GError **error);
function g_file_get_child_for_display_name(file, display_name, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_get_child_for_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: error
end function

! gboolean g_file_has_prefix (GFile *file, GFile *prefix);
function g_file_has_prefix(file, prefix) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_has_prefix
  type(c_ptr), value :: file
  type(c_ptr), value :: prefix
end function

! char * g_file_get_relative_path (GFile *parent, GFile *descendant);
function g_file_get_relative_path(parent, descendant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_relative_path
  type(c_ptr), value :: parent
  type(c_ptr), value :: descendant
end function

! GFile * g_file_resolve_relative_path (GFile *file, const char *relative_path);
function g_file_resolve_relative_path(file, relative_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_resolve_relative_path
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: relative_path
end function

! gboolean g_file_is_native (GFile *file);
function g_file_is_native(file) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_is_native
  type(c_ptr), value :: file
end function

! gboolean g_file_has_uri_scheme (GFile *file, const char *uri_scheme);
function g_file_has_uri_scheme(file, uri_scheme) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_has_uri_scheme
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: uri_scheme
end function

! char * g_file_get_uri_scheme (GFile *file);
function g_file_get_uri_scheme(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_get_uri_scheme
  type(c_ptr), value :: file
end function

! GFileInputStream * g_file_read (GFile *file, GCancellable *cancellable, GError **error);
function g_file_read(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_read
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_read_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_read_async(file, io_priority, cancellable, callback, user_dat&
&a) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInputStream * g_file_read_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_read_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_read_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_append_to (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_append_to(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_append_to
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_create (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_create
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileOutputStream * g_file_replace (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace(file, etag, make_backup, flags, cancellable, error) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_replace
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_append_to_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_append_to_async(file, flags, io_priority, cancellable, callba&
&ck, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_append_to_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_append_to_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_append_to_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_file_create_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_async(file, flags, io_priority, cancellable, callback,&
& user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_create_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_create_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_file_replace_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_async(file, etag, make_backup, flags, io_priority, ca&
&ncellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileOutputStream * g_file_replace_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_replace_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_open_readwrite (GFile *file, GCancellable *cancellable, GError **error);
function g_file_open_readwrite(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_open_readwrite
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_open_readwrite_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_open_readwrite_async(file, io_priority, cancellable, callback&
&, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_open_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_open_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_open_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_create_readwrite (GFile *file, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_create_readwrite(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_create_readwrite
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_create_readwrite_async (GFile *file, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_create_readwrite_async(file, flags, io_priority, cancellable,&
& callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_create_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_create_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_create_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileIOStream * g_file_replace_readwrite (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GError **error);
function g_file_replace_readwrite(file, etag, make_backup, flags, cancellable, &
&error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_replace_readwrite
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_replace_readwrite_async (GFile *file, const char *etag, gboolean make_backup, GFileCreateFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_readwrite_async(file, etag, make_backup, flags, io_pr&
&iority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileIOStream * g_file_replace_readwrite_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_replace_readwrite_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_replace_readwrite_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_query_exists (GFile *file, GCancellable *cancellable);
function g_file_query_exists(file, cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_query_exists
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
end function

! GFileType g_file_query_file_type (GFile *file, GFileQueryInfoFlags flags, GCancellable *cancellable);
function g_file_query_file_type(file, flags, cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_query_file_type
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
end function

! GFileInfo * g_file_query_info (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_query_info(file, attributes, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_query_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_query_info_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_info_async(file, attributes, flags, io_priority, cancel&
&lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo * g_file_query_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_info_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileInfo * g_file_query_filesystem_info (GFile *file, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_query_filesystem_info(file, attributes, cancellable, error) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_query_filesystem_info
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_query_filesystem_info_async (GFile *file, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_query_filesystem_info_async(file, attributes, io_priority, ca&
&ncellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo * g_file_query_filesystem_info_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_query_filesystem_info_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_filesystem_info_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GMount * g_file_find_enclosing_mount (GFile *file, GCancellable *cancellable, GError **error);
function g_file_find_enclosing_mount(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_find_enclosing_mount_async (GFile *file, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_find_enclosing_mount_async(file, io_priority, cancellable, ca&
&llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GMount * g_file_find_enclosing_mount_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_find_enclosing_mount_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_find_enclosing_mount_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFileEnumerator * g_file_enumerate_children (GFile *file, const char *attributes, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_enumerate_children(file, attributes, flags, cancellable, error)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_file_enumerate_children
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_enumerate_children_async (GFile *file, const char *attributes, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerate_children_async(file, attributes, flags, io_priority&
&, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileEnumerator * g_file_enumerate_children_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_enumerate_children_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerate_children_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GFile * g_file_set_display_name (GFile *file, const char *display_name, GCancellable *cancellable, GError **error);
function g_file_set_display_name(file, display_name, cancellable, error) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_set_display_name
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_set_display_name_async (GFile *file, const char *display_name, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_display_name_async(file, display_name, io_priority, cance&
&llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: display_name
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFile * g_file_set_display_name_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_set_display_name_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_set_display_name_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_delete (GFile *file, GCancellable *cancellable, GError **error);
function g_file_delete(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_delete
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_trash (GFile *file, GCancellable *cancellable, GError **error);
function g_file_trash(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_trash
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_copy (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_copy(source, destination, flags, cancellable, progress_callback&
&, progress_callback_data, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_file_copy
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! void g_file_copy_async (GFile *source, GFile *destination, GFileCopyFlags flags, int io_priority, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_copy_async(source, destination, flags, io_priority, cancellab&
&le, progress_callback, progress_callback_data, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_copy_finish (GFile *file, GAsyncResult *res, GError **error);
function g_file_copy_finish(file, res, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_copy_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_file_move (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GFileProgressCallback progress_callback, gpointer progress_callback_data, GError **error);
function g_file_move(source, destination, flags, cancellable, progress_callback&
&, progress_callback_data, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_file_move
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: progress_callback
  type(c_ptr), value :: progress_callback_data
  type(c_ptr), value :: error
end function

! gboolean g_file_make_directory (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_make_directory
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_make_directory_with_parents (GFile *file, GCancellable *cancellable, GError **error);
function g_file_make_directory_with_parents(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_make_directory_with_parents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_make_symbolic_link (GFile *file, const char *symlink_value, GCancellable *cancellable, GError **error);
function g_file_make_symbolic_link(file, symlink_value, cancellable, error) bin&
&d(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_make_symbolic_link
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: symlink_value
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileAttributeInfoList *g_file_query_settable_attributes (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_settable_attributes(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_settable_attributes
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileAttributeInfoList *g_file_query_writable_namespaces (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_writable_namespaces(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_writable_namespaces
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute (GFile *file, const char *attribute, GFileAttributeType type, gpointer value_p, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute(file, attribute, type, value_p, flags, cancellabl&
&e, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attributes_from_info (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attributes_from_info(file, info, flags, cancellable, error)&
& bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_set_attributes_from_info
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_set_attributes_async (GFile *file, GFileInfo *info, GFileQueryInfoFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_set_attributes_async(file, info, flags, io_priority, cancella&
&ble, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: info
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_set_attributes_finish (GFile *file, GAsyncResult *result, GFileInfo **info, GError **error);
function g_file_set_attributes_finish(file, result, info, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_set_attributes_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: info
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_string(file, attribute, value, flags, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_byte_string (GFile *file, const char *attribute, const char *value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_byte_string(file, attribute, value, flags, cancel&
&lable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_set_attribute_byte_string
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_uint32 (GFile *file, const char *attribute, guint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint32(file, attribute, value, flags, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_int32_t
  integer(c_int) :: g_file_set_attribute_uint32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_int32 (GFile *file, const char *attribute, gint32 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int32(file, attribute, value, flags, cancellable,&
& error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_int32_t
  integer(c_int) :: g_file_set_attribute_int32
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_uint64 (GFile *file, const char *attribute, guint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_uint64(file, attribute, value, flags, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_file_set_attribute_uint64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_set_attribute_int64 (GFile *file, const char *attribute, gint64 value, GFileQueryInfoFlags flags, GCancellable *cancellable, GError **error);
function g_file_set_attribute_int64(file, attribute, value, flags, cancellable,&
& error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_int64_t
  integer(c_int) :: g_file_set_attribute_int64
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: value
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_mount_enclosing_volume (GFile *location, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_enclosing_volume(location, flags, mount_operation, canc&
&ellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: location
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_mount_enclosing_volume_finish (GFile *location, GAsyncResult *result, GError **error);
function g_file_mount_enclosing_volume_finish(location, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_mount_enclosing_volume_finish
  type(c_ptr), value :: location
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_mount_mountable (GFile *file, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_mount_mountable(file, flags, mount_operation, cancellable, ca&
&llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFile * g_file_mount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_mount_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_mount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_unmount_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable(file, flags, cancellable, callback, user_da&
&ta) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_unmount_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_unmount_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_unmount_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_unmount_mountable_with_operation(file, flags, mount_operation&
&, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_unmount_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_unmount_mountable_with_operation_finish(file, result, error) bi&
&nd(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_unmount_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_eject_mountable (GFile *file, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable(file, flags, cancellable, callback, user_data&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_eject_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_eject_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_eject_mountable_with_operation (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_eject_mountable_with_operation(file, flags, mount_operation, &
&cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_eject_mountable_with_operation_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_eject_mountable_with_operation_finish(file, result, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_eject_mountable_with_operation_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_file_copy_attributes (GFile *source, GFile *destination, GFileCopyFlags flags, GCancellable *cancellable, GError **error);
function g_file_copy_attributes(source, destination, flags, cancellable, error)&
& bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_copy_attributes
  type(c_ptr), value :: source
  type(c_ptr), value :: destination
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  GFileMonitor* g_file_monitor_directory (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_directory(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_directory
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileMonitor* g_file_monitor_file (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor_file(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor_file
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GFileMonitor* g_file_monitor (GFile *file, GFileMonitorFlags flags, GCancellable *cancellable, GError **error);
function g_file_monitor(file, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_file_monitor
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_file_start_mountable (GFile *file, GDriveStartFlags flags, GMountOperation *start_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_start_mountable(file, flags, start_operation, cancellable, ca&
&llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: start_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_start_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_start_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_start_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_stop_mountable (GFile *file, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_stop_mountable(file, flags, mount_operation, cancellable, cal&
&lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_stop_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_stop_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_stop_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_file_poll_mountable (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_poll_mountable(file, cancellable, callback, user_data) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_poll_mountable_finish (GFile *file, GAsyncResult *result, GError **error);
function g_file_poll_mountable_finish(file, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_poll_mountable_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  GAppInfo *g_file_query_default_handler (GFile *file, GCancellable *cancellable, GError **error);
function g_file_query_default_handler(file, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_query_default_handler
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_load_contents (GFile *file, GCancellable *cancellable, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents(file, cancellable, contents, length, etag_out, er&
&ror) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_load_contents
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! void g_file_load_contents_async (GFile *file, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_contents_async(file, cancellable, callback, user_data) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_load_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_contents_finish(file, res, contents, length, etag_out, err&
&or) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_load_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! void g_file_load_partial_contents_async (GFile *file, GCancellable *cancellable, GFileReadMoreCallback read_more_callback, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_load_partial_contents_async(file, cancellable, read_more_call&
&back, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: file
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: read_more_callback
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_load_partial_contents_finish (GFile *file, GAsyncResult *res, char **contents, gsize *length, char **etag_out, GError **error);
function g_file_load_partial_contents_finish(file, res, contents, length, etag_&
&out, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_load_partial_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: contents
  type(c_ptr), value :: length
  type(c_ptr), dimension(*) :: etag_out
  type(c_ptr), value :: error
end function

! gboolean g_file_replace_contents (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, char **new_etag, GCancellable *cancellable, GError **error);
function g_file_replace_contents(file, contents, length, etag, make_backup, fla&
&gs, new_etag, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_file_replace_contents
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), dimension(*) :: new_etag
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_replace_contents_async (GFile *file, const char *contents, gsize length, const char *etag, gboolean make_backup, GFileCreateFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_replace_contents_async(file, contents, length, etag, make_bac&
&kup, flags, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  character(kind=c_char), dimension(*) :: etag
  integer(c_int), value :: make_backup
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_replace_contents_finish (GFile *file, GAsyncResult *res, char **new_etag, GError **error);
function g_file_replace_contents_finish(file, res, new_etag, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_replace_contents_finish
  type(c_ptr), value :: file
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: new_etag
  type(c_ptr), value :: error
end function

!  gboolean g_file_supports_thread_contexts (GFile *file);
function g_file_supports_thread_contexts(file) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_supports_thread_contexts
  type(c_ptr), value :: file
end function

!   GType g_socket_address_enumerator_get_type (void) G_GNUC_CONST;
function g_socket_address_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_address_enumerator_get_type
end function

!  GSocketAddress *g_socket_address_enumerator_next (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_socket_address_enumerator_next(enumerator, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_socket_address_enumerator_next_async (GSocketAddressEnumerator *enumerator, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_address_enumerator_next_async(enumerator, cancellable, call&
&back, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketAddress *g_socket_address_enumerator_next_finish (GSocketAddressEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_socket_address_enumerator_next_finish(enumerator, result, error) bin&
&d(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_address_enumerator_next_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_tls_connection_get_type (void) G_GNUC_CONST;
function g_tls_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_connection_get_type
end function

!  void g_tls_connection_set_use_system_certdb (GTlsConnection *conn, gboolean use_system_certdb);
subroutine g_tls_connection_set_use_system_certdb(conn, use_system_certdb) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: use_system_certdb
end subroutine

! gboolean g_tls_connection_get_use_system_certdb (GTlsConnection *conn);
function g_tls_connection_get_use_system_certdb(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_use_system_certdb
  type(c_ptr), value :: conn
end function

!  void g_tls_connection_set_certificate (GTlsConnection *conn, GTlsCertificate *certificate);
subroutine g_tls_connection_set_certificate(conn, certificate) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: certificate
end subroutine

! GTlsCertificate *g_tls_connection_get_certificate (GTlsConnection *conn);
function g_tls_connection_get_certificate(conn) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_connection_get_certificate
  type(c_ptr), value :: conn
end function

!  GTlsCertificate *g_tls_connection_get_peer_certificate (GTlsConnection *conn);
function g_tls_connection_get_peer_certificate(conn) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_connection_get_peer_certificate
  type(c_ptr), value :: conn
end function

! GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors (GTlsConnection *conn);
function g_tls_connection_get_peer_certificate_errors(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_peer_certificate_errors
  type(c_ptr), value :: conn
end function

!  void g_tls_connection_set_require_close_notify (GTlsConnection *conn, gboolean require_close_notify);
subroutine g_tls_connection_set_require_close_notify(conn, require_close_notify&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: require_close_notify
end subroutine

! gboolean g_tls_connection_get_require_close_notify (GTlsConnection *conn);
function g_tls_connection_get_require_close_notify(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_require_close_notify
  type(c_ptr), value :: conn
end function

!  void g_tls_connection_set_rehandshake_mode (GTlsConnection *conn, GTlsRehandshakeMode mode);
subroutine g_tls_connection_set_rehandshake_mode(conn, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: mode
end subroutine

! GTlsRehandshakeMode g_tls_connection_get_rehandshake_mode (GTlsConnection *conn);
function g_tls_connection_get_rehandshake_mode(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_get_rehandshake_mode
  type(c_ptr), value :: conn
end function

!  gboolean g_tls_connection_handshake (GTlsConnection *conn, GCancellable *cancellable, GError **error);
function g_tls_connection_handshake(conn, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_handshake
  type(c_ptr), value :: conn
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_tls_connection_handshake_async (GTlsConnection *conn, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_tls_connection_handshake_async(conn, io_priority, cancellable, cal&
&lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: conn
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_tls_connection_handshake_finish (GTlsConnection *conn, GAsyncResult *result, GError **error);
function g_tls_connection_handshake_finish(conn, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_handshake_finish
  type(c_ptr), value :: conn
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  GQuark g_tls_error_quark (void);
function g_tls_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_tls_error_quark
end function

!  gboolean g_tls_connection_emit_accept_certificate (GTlsConnection *conn, GTlsCertificate *peer_cert, GTlsCertificateFlags errors);
function g_tls_connection_emit_accept_certificate(conn, peer_cert, errors) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_connection_emit_accept_certificate
  type(c_ptr), value :: conn
  type(c_ptr), value :: peer_cert
  integer(c_int), value :: errors
end function

!   GType g_filter_output_stream_get_type (void) G_GNUC_CONST;
function g_filter_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filter_output_stream_get_type
end function

! GOutputStream * g_filter_output_stream_get_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filter_output_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! gboolean g_filter_output_stream_get_close_base_stream (GFilterOutputStream *stream);
function g_filter_output_stream_get_close_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_filter_output_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! void g_filter_output_stream_set_close_base_stream (GFilterOutputStream *stream, gboolean close_base);
subroutine g_filter_output_stream_set_close_base_stream(stream, close_base) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: close_base
end subroutine

!   GType g_seekable_get_type (void) G_GNUC_CONST;
function g_seekable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_seekable_get_type
end function

!  goffset g_seekable_tell (GSeekable *seekable);
function g_seekable_tell(seekable) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_seekable_tell
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_can_seek (GSeekable *seekable);
function g_seekable_can_seek(seekable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_seekable_can_seek
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_seek (GSeekable *seekable, goffset offset, GSeekType type, GCancellable *cancellable, GError **error);
function g_seekable_seek(seekable, offset, type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_seekable_seek
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  integer(c_int), value :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_seekable_can_truncate (GSeekable *seekable);
function g_seekable_can_truncate(seekable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_seekable_can_truncate
  type(c_ptr), value :: seekable
end function

! gboolean g_seekable_truncate (GSeekable *seekable, goffset offset, GCancellable *cancellable, GError **error);
function g_seekable_truncate(seekable, offset, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_seekable_truncate
  type(c_ptr), value :: seekable
  integer(c_int64_t), value :: offset
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_simple_async_result_get_type (void) G_GNUC_CONST;
function g_simple_async_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_async_result_get_type
end function

!  GSimpleAsyncResult *g_simple_async_result_new (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, gpointer source_tag);
function g_simple_async_result_new(source_object, callback, user_data, source_t&
&ag) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: source_tag
end function

! GSimpleAsyncResult *g_simple_async_result_new_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GQuark domain, gint code, const char *format, ...) G_GNUC_PRINTF (6, 7);
function g_simple_async_result_new_error() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_new_error
end function

! GSimpleAsyncResult *g_simple_async_result_new_from_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
function g_simple_async_result_new_from_error(source_object, callback, user_dat&
&a, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new_from_error
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! GSimpleAsyncResult *g_simple_async_result_new_take_error (GObject *source_object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
function g_simple_async_result_new_take_error(source_object, callback, user_dat&
&a, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_simple_async_result_new_take_error
  type(c_ptr), value :: source_object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

!  void g_simple_async_result_set_op_res_gpointer (GSimpleAsyncResult *simple, gpointer op_res, GDestroyNotify destroy_op_res);
subroutine g_simple_async_result_set_op_res_gpointer(simple, op_res, destroy_op&
&_res) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: op_res
  type(c_funptr), value :: destroy_op_res
end subroutine

! gpointer g_simple_async_result_get_op_res_gpointer (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gpointer(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_get_op_res_gpointer
  type(c_ptr), value :: simple
end function

!  void g_simple_async_result_set_op_res_gssize (GSimpleAsyncResult *simple, gssize op_res);
subroutine g_simple_async_result_set_op_res_gssize(simple, op_res) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: simple
  integer(c_size_t), value :: op_res
end subroutine

! gssize g_simple_async_result_get_op_res_gssize (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gssize(simple) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_simple_async_result_get_op_res_gssize
  type(c_ptr), value :: simple
end function

!  void g_simple_async_result_set_op_res_gboolean (GSimpleAsyncResult *simple, gboolean op_res);
subroutine g_simple_async_result_set_op_res_gboolean(simple, op_res) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: op_res
end subroutine

! gboolean g_simple_async_result_get_op_res_gboolean (GSimpleAsyncResult *simple);
function g_simple_async_result_get_op_res_gboolean(simple) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_get_op_res_gboolean
  type(c_ptr), value :: simple
end function

!  gpointer g_simple_async_result_get_source_tag (GSimpleAsyncResult *simple);
function g_simple_async_result_get_source_tag(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_async_result_get_source_tag
  type(c_ptr), value :: simple
end function

! void g_simple_async_result_set_handle_cancellation (GSimpleAsyncResult *simple, gboolean handle_cancellation);
subroutine g_simple_async_result_set_handle_cancellation(simple, handle_cancell&
&ation) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: handle_cancellation
end subroutine

! void g_simple_async_result_complete (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
end subroutine

! void g_simple_async_result_complete_in_idle (GSimpleAsyncResult *simple);
subroutine g_simple_async_result_complete_in_idle(simple) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
end subroutine

! void g_simple_async_result_run_in_thread (GSimpleAsyncResult *simple, GSimpleAsyncThreadFunc func, int io_priority, GCancellable *cancellable);
subroutine g_simple_async_result_run_in_thread(simple, func, io_priority, cance&
&llable) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr), value :: simple
  type(c_funptr), value :: func
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! void g_simple_async_result_set_from_error (GSimpleAsyncResult *simple, const GError *error);
subroutine g_simple_async_result_set_from_error(simple, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: error
end subroutine

! void g_simple_async_result_take_error (GSimpleAsyncResult *simple, GError *error);
subroutine g_simple_async_result_take_error(simple, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: error
end subroutine

! gboolean g_simple_async_result_propagate_error (GSimpleAsyncResult *simple, GError **dest);
function g_simple_async_result_propagate_error(simple, dest) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_propagate_error
  type(c_ptr), value :: simple
  type(c_ptr), value :: dest
end function

! void g_simple_async_result_set_error (GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, ...) G_GNUC_PRINTF (4, 5);
subroutine g_simple_async_result_set_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_simple_async_result_set_error_va (GSimpleAsyncResult *simple, GQuark domain, gint code, const char *format, va_list args);
subroutine g_simple_async_result_set_error_va(simple, domain, code, format, arg&
&s) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: simple
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! gboolean g_simple_async_result_is_valid (GAsyncResult *result, GObject *source, gpointer source_tag);
function g_simple_async_result_is_valid(result, source, source_tag) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_simple_async_result_is_valid
  type(c_ptr), value :: result
  type(c_ptr), value :: source
  type(c_ptr), value :: source_tag
end function

! void g_simple_async_report_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, const GError *error);
subroutine g_simple_async_report_gerror_in_idle(object, callback, user_data, er&
&ror) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end subroutine

! void g_simple_async_report_take_gerror_in_idle (GObject *object, GAsyncReadyCallback callback, gpointer user_data, GError *error);
subroutine g_simple_async_report_take_gerror_in_idle(object, callback, user_dat&
&a, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end subroutine

!   GType g_io_stream_get_type (void) G_GNUC_CONST;
function g_io_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_stream_get_type
end function

!  GInputStream * g_io_stream_get_input_stream (GIOStream *stream);
function g_io_stream_get_input_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_stream_get_input_stream
  type(c_ptr), value :: stream
end function

! GOutputStream *g_io_stream_get_output_stream (GIOStream *stream);
function g_io_stream_get_output_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_stream_get_output_stream
  type(c_ptr), value :: stream
end function

!  void g_io_stream_splice_async (GIOStream *stream1, GIOStream *stream2, GIOStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_io_stream_splice_async(stream1, stream2, flags, io_priority, cance&
&llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream1
  type(c_ptr), value :: stream2
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  gboolean g_io_stream_splice_finish (GAsyncResult *result, GError **error);
function g_io_stream_splice_finish(result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_splice_finish
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_io_stream_close (GIOStream *stream, GCancellable *cancellable, GError **error);
function g_io_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_io_stream_close_async (GIOStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_io_stream_close_async(stream, io_priority, cancellable, callback, &
&user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_io_stream_close_finish (GIOStream *stream, GAsyncResult *result, GError **error);
function g_io_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_io_stream_is_closed (GIOStream *stream);
function g_io_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_io_stream_has_pending (GIOStream *stream);
function g_io_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_io_stream_set_pending (GIOStream *stream, GError **error);
function g_io_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_io_stream_clear_pending (GIOStream *stream);
subroutine g_io_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GQuark g_dbus_error_quark (void);
function g_dbus_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_dbus_error_quark
end function

!  gboolean g_dbus_error_is_remote_error (const GError *error);
function g_dbus_error_is_remote_error(error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_error_is_remote_error
  type(c_ptr), value :: error
end function

! gchar *g_dbus_error_get_remote_error (const GError *error);
function g_dbus_error_get_remote_error(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_error_get_remote_error
  type(c_ptr), value :: error
end function

! gboolean g_dbus_error_strip_remote_error (GError *error);
function g_dbus_error_strip_remote_error(error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_error_strip_remote_error
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_error_register_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_register_error(error_domain, error_code, dbus_error_name)&
& bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_char
  integer(c_int) :: g_dbus_error_register_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! gboolean g_dbus_error_unregister_error (GQuark error_domain, gint error_code, const gchar *dbus_error_name);
function g_dbus_error_unregister_error(error_domain, error_code, dbus_error_nam&
&e) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_char
  integer(c_int) :: g_dbus_error_unregister_error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
  character(kind=c_char), dimension(*) :: dbus_error_name
end function

! void g_dbus_error_register_error_domain (const gchar *error_domain_quark_name, volatile gsize *quark_volatile, const GDBusErrorEntry *entries, guint num_entries);
subroutine g_dbus_error_register_error_domain(error_domain_quark_name, quark_vo&
&latile, entries, num_entries) bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_int
  character(kind=c_char), dimension(*) :: error_domain_quark_name
  type(c_ptr), value :: quark_volatile
  integer(c_int), value :: entries
  integer(c_int), value :: num_entries
end subroutine

!  GError *g_dbus_error_new_for_dbus_error (const gchar *dbus_error_name, const gchar *dbus_error_message);
function g_dbus_error_new_for_dbus_error(dbus_error_name, dbus_error_message) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_error_new_for_dbus_error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
end function

! void g_dbus_error_set_dbus_error_valist (GError **error, const gchar *dbus_error_name, const gchar *dbus_error_message, const gchar *format, va_list var_args);
subroutine g_dbus_error_set_dbus_error_valist(error, dbus_error_name, dbus_erro&
&r_message, format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: error
  character(kind=c_char), dimension(*) :: dbus_error_name
  character(kind=c_char), dimension(*) :: dbus_error_message
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! gchar *g_dbus_error_encode_gerror (const GError *error);
function g_dbus_error_encode_gerror(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_error_encode_gerror
  type(c_ptr), value :: error
end function

!   GType g_socket_listener_get_type (void) G_GNUC_CONST;
function g_socket_listener_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_listener_get_type
end function

!  GSocketListener * g_socket_listener_new (void);
function g_socket_listener_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_new
end function

!  void g_socket_listener_set_backlog (GSocketListener *listener, int listen_backlog);
subroutine g_socket_listener_set_backlog(listener, listen_backlog) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: listener
  integer(c_int), value :: listen_backlog
end subroutine

!  gboolean g_socket_listener_add_socket (GSocketListener *listener, GSocket *socket, GObject *source_object, GError **error);
function g_socket_listener_add_socket(listener, socket, source_object, error) b&
&ind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_listener_add_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: socket
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! gboolean g_socket_listener_add_address (GSocketListener *listener, GSocketAddress *address, GSocketType type, GSocketProtocol protocol, GObject *source_object, GSocketAddress **effective_address, GError **error);
function g_socket_listener_add_address(listener, address, type, protocol, sourc&
&e_object, effective_address, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_listener_add_address
  type(c_ptr), value :: listener
  type(c_ptr), value :: address
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: source_object
  type(c_ptr), value :: effective_address
  type(c_ptr), value :: error
end function

! gboolean g_socket_listener_add_inet_port (GSocketListener *listener, guint16 port, GObject *source_object, GError **error);
function g_socket_listener_add_inet_port(listener, port, source_object, error) &
&bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_socket_listener_add_inet_port
  type(c_ptr), value :: listener
  integer(c_int16_t), value :: port
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

! guint16 g_socket_listener_add_any_inet_port (GSocketListener *listener, GObject *source_object, GError **error);
function g_socket_listener_add_any_inet_port(listener, source_object, error) bi&
&nd(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_socket_listener_add_any_inet_port
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  GSocket * g_socket_listener_accept_socket (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept_socket(listener, source_object, cancellable, &
&error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_socket_listener_accept_socket_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_socket_async(listener, cancellable, callbac&
&k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocket * g_socket_listener_accept_socket_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_socket_finish(listener, result, source_object&
&, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_socket_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  GSocketConnection * g_socket_listener_accept (GSocketListener *listener, GObject **source_object, GCancellable *cancellable, GError **error);
function g_socket_listener_accept(listener, source_object, cancellable, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept
  type(c_ptr), value :: listener
  type(c_ptr), value :: source_object
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_socket_listener_accept_async (GSocketListener *listener, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_listener_accept_async(listener, cancellable, callback, user&
&_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: listener
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GSocketConnection * g_socket_listener_accept_finish (GSocketListener *listener, GAsyncResult *result, GObject **source_object, GError **error);
function g_socket_listener_accept_finish(listener, result, source_object, error&
&) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_listener_accept_finish
  type(c_ptr), value :: listener
  type(c_ptr), value :: result
  type(c_ptr), value :: source_object
  type(c_ptr), value :: error
end function

!  void g_socket_listener_close (GSocketListener *listener);
subroutine g_socket_listener_close(listener) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: listener
end subroutine

!   GType g_action_get_type (void) G_GNUC_CONST;
function g_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_action_get_type
end function

!  const gchar * g_action_get_name (GAction *action);
function g_action_get_name(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_get_name
  type(c_ptr), value :: action
end function

! const GVariantType * g_action_get_parameter_type (GAction *action);
function g_action_get_parameter_type(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_get_parameter_type
  type(c_ptr), value :: action
end function

! const GVariantType * g_action_get_state_type (GAction *action);
function g_action_get_state_type(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_get_state_type
  type(c_ptr), value :: action
end function

! GVariant * g_action_get_state_hint (GAction *action);
function g_action_get_state_hint(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_get_state_hint
  type(c_ptr), value :: action
end function

!  gboolean g_action_get_enabled (GAction *action);
function g_action_get_enabled(action) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_action_get_enabled
  type(c_ptr), value :: action
end function

! GVariant * g_action_get_state (GAction *action);
function g_action_get_state(action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_get_state
  type(c_ptr), value :: action
end function

! void g_action_set_state (GAction *action, GVariant *value);
subroutine g_action_set_state(action, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: value
end subroutine

!  void g_action_activate (GAction *action, GVariant *parameter);
subroutine g_action_activate(action, parameter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: action
  type(c_ptr), value :: parameter
end subroutine

!   GType g_tls_certificate_get_type (void) G_GNUC_CONST;
function g_tls_certificate_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_certificate_get_type
end function

!  GTlsCertificate *g_tls_certificate_new_from_pem (const gchar *data, gssize length, GError **error);
function g_tls_certificate_new_from_pem(data, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_tls_certificate_new_from_pem
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

!  GTlsCertificate *g_tls_certificate_new_from_file (const gchar *file, GError **error);
function g_tls_certificate_new_from_file(file, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), value :: error
end function

! GTlsCertificate *g_tls_certificate_new_from_files (const gchar *cert_file, const gchar *key_file, GError **error);
function g_tls_certificate_new_from_files(cert_file, key_file, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_new_from_files
  character(kind=c_char), dimension(*) :: cert_file
  character(kind=c_char), dimension(*) :: key_file
  type(c_ptr), value :: error
end function

! GList *g_tls_certificate_list_new_from_file (const gchar *file, GError **error);
function g_tls_certificate_list_new_from_file(file, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_tls_certificate_list_new_from_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), value :: error
end function

!  GTlsCertificate *g_tls_certificate_get_issuer (GTlsCertificate *cert);
function g_tls_certificate_get_issuer(cert) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_certificate_get_issuer
  type(c_ptr), value :: cert
end function

!  GTlsCertificateFlags g_tls_certificate_verify (GTlsCertificate *cert, GSocketConnectable *identity, GTlsCertificate *trusted_ca);
function g_tls_certificate_verify(cert, identity, trusted_ca) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_certificate_verify
  type(c_ptr), value :: cert
  type(c_ptr), value :: identity
  type(c_ptr), value :: trusted_ca
end function

!   GType g_buffered_input_stream_get_type (void) G_GNUC_CONST;
function g_buffered_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_buffered_input_stream_get_type
end function

! GInputStream* g_buffered_input_stream_new (GInputStream *base_stream);
function g_buffered_input_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_buffered_input_stream_new
  type(c_ptr), value :: base_stream
end function

! GInputStream* g_buffered_input_stream_new_sized (GInputStream *base_stream, gsize size);
function g_buffered_input_stream_new_sized(base_stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_input_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

!  gsize g_buffered_input_stream_get_buffer_size (GBufferedInputStream *stream);
function g_buffered_input_stream_get_buffer_size(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! void g_buffered_input_stream_set_buffer_size (GBufferedInputStream *stream, gsize size);
subroutine g_buffered_input_stream_set_buffer_size(stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! gsize g_buffered_input_stream_get_available (GBufferedInputStream *stream);
function g_buffered_input_stream_get_available(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_get_available
  type(c_ptr), value :: stream
end function

! gsize g_buffered_input_stream_peek (GBufferedInputStream *stream, void *buffer, gsize offset, gsize count);
function g_buffered_input_stream_peek(stream, buffer, offset, count) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_peek
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: offset
  integer(c_size_t), value :: count
end function

! const void* g_buffered_input_stream_peek_buffer (GBufferedInputStream *stream, gsize *count);
function g_buffered_input_stream_peek_buffer(stream, count) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_buffered_input_stream_peek_buffer
  type(c_ptr), value :: stream
  type(c_ptr), value :: count
end function

!  gssize g_buffered_input_stream_fill (GBufferedInputStream *stream, gssize count, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_fill(stream, count, cancellable, error) bind(c&
&) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_buffered_input_stream_fill_async (GBufferedInputStream *stream, gssize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_buffered_input_stream_fill_async(stream, count, io_priority, cance&
&llable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_buffered_input_stream_fill_finish (GBufferedInputStream *stream, GAsyncResult *result, GError **error);
function g_buffered_input_stream_fill_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_input_stream_fill_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  int g_buffered_input_stream_read_byte (GBufferedInputStream *stream, GCancellable *cancellable, GError **error);
function g_buffered_input_stream_read_byte(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_buffered_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_network_address_get_type (void) G_GNUC_CONST;
function g_network_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_network_address_get_type
end function

!  GSocketConnectable *g_network_address_new (const gchar *hostname, guint16 port);
function g_network_address_new(hostname, port) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
end function

! GSocketConnectable *g_network_address_parse (const gchar *host_and_port, guint16 default_port, GError **error);
function g_network_address_parse(host_and_port, default_port, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! GSocketConnectable *g_network_address_parse_uri (const gchar *uri, guint16 default_port, GError **error);
function g_network_address_parse_uri(uri, default_port, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_network_address_parse_uri
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: error
end function

! const gchar *g_network_address_get_hostname (GNetworkAddress *addr);
function g_network_address_get_hostname(addr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_address_get_hostname
  type(c_ptr), value :: addr
end function

! guint16 g_network_address_get_port (GNetworkAddress *addr);
function g_network_address_get_port(addr) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_network_address_get_port
  type(c_ptr), value :: addr
end function

! const gchar *g_network_address_get_scheme (GNetworkAddress *addr);
function g_network_address_get_scheme(addr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_address_get_scheme
  type(c_ptr), value :: addr
end function

!   GType g_cancellable_get_type (void) G_GNUC_CONST;
function g_cancellable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_cancellable_get_type
end function

!  GCancellable *g_cancellable_new (void);
function g_cancellable_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cancellable_new
end function

!  gboolean g_cancellable_is_cancelled (GCancellable *cancellable);
function g_cancellable_is_cancelled(cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_cancellable_is_cancelled
  type(c_ptr), value :: cancellable
end function

! gboolean g_cancellable_set_error_if_cancelled (GCancellable *cancellable, GError **error);
function g_cancellable_set_error_if_cancelled(cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_cancellable_set_error_if_cancelled
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  int g_cancellable_get_fd (GCancellable *cancellable);
function g_cancellable_get_fd(cancellable) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_cancellable_get_fd
  type(c_ptr), value :: cancellable
end function

! gboolean g_cancellable_make_pollfd (GCancellable *cancellable, GPollFD *pollfd);
function g_cancellable_make_pollfd(cancellable, pollfd) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_cancellable_make_pollfd
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: pollfd
end function

! void g_cancellable_release_fd (GCancellable *cancellable);
subroutine g_cancellable_release_fd(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

!  GSource * g_cancellable_source_new (GCancellable *cancellable);
function g_cancellable_source_new(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cancellable_source_new
  type(c_ptr), value :: cancellable
end function

!  GCancellable *g_cancellable_get_current (void);
function g_cancellable_get_current() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cancellable_get_current
end function

! void g_cancellable_push_current (GCancellable *cancellable);
subroutine g_cancellable_push_current(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! void g_cancellable_pop_current (GCancellable *cancellable);
subroutine g_cancellable_pop_current(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! void g_cancellable_reset (GCancellable *cancellable);
subroutine g_cancellable_reset(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

! gulong g_cancellable_connect (GCancellable *cancellable, GCallback callback, gpointer data, GDestroyNotify data_destroy_func);
function g_cancellable_connect(cancellable, callback, data, data_destroy_func) &
&bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_funptr
  integer(c_long) :: g_cancellable_connect
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: data
  type(c_funptr), value :: data_destroy_func
end function

! void g_cancellable_disconnect (GCancellable *cancellable, gulong handler_id);
subroutine g_cancellable_disconnect(cancellable, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: cancellable
  integer(c_long), value :: handler_id
end subroutine

!  void g_cancellable_cancel (GCancellable *cancellable);
subroutine g_cancellable_cancel(cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cancellable
end subroutine

!   guint g_bus_own_name (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GBusAcquiredCallback bus_acquired_handler, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name(bus_type, name, flags, bus_acquired_handler, name_acqui&
&red_handler, name_lost_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_bus_own_name
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: bus_acquired_handler
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  guint g_bus_own_name_on_connection (GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GBusNameAcquiredCallback name_acquired_handler, GBusNameLostCallback name_lost_handler, gpointer user_data, GDestroyNotify user_data_free_func);
function g_bus_own_name_on_connection(connection, name, flags, name_acquired_ha&
&ndler, name_lost_handler, user_data, user_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_bus_own_name_on_connection
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_funptr), value :: name_acquired_handler
  type(c_funptr), value :: name_lost_handler
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  guint g_bus_own_name_with_closures (GBusType bus_type, const gchar *name, GBusNameOwnerFlags flags, GClosure *bus_acquired_closure, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_with_closures(bus_type, name, flags, bus_acquired_closu&
&re, name_acquired_closure, name_lost_closure) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_bus_own_name_with_closures
  integer(c_int), value :: bus_type
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: bus_acquired_closure
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

!  guint g_bus_own_name_on_connection_with_closures ( GDBusConnection *connection, const gchar *name, GBusNameOwnerFlags flags, GClosure *name_acquired_closure, GClosure *name_lost_closure);
function g_bus_own_name_on_connection_with_closures(connection, name, flags, na&
&me_acquired_closure, name_lost_closure) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bus_own_name_on_connection_with_closures
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: flags
  type(c_ptr), value :: name_acquired_closure
  type(c_ptr), value :: name_lost_closure
end function

!  void g_bus_unown_name (guint owner_id);
subroutine g_bus_unown_name(owner_id) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: owner_id
end subroutine

!   GType g_output_stream_get_type (void) G_GNUC_CONST;
function g_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_output_stream_get_type
end function

!  gssize g_output_stream_write (GOutputStream *stream, const void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_output_stream_write(stream, buffer, count, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_write_all (GOutputStream *stream, const void *buffer, gsize count, gsize *bytes_written, GCancellable *cancellable, GError **error);
function g_output_stream_write_all(stream, buffer, count, bytes_written, cancel&
&lable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_output_stream_write_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_output_stream_splice (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, GCancellable *cancellable, GError **error);
function g_output_stream_splice(stream, source, flags, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_output_stream_splice
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_flush (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_flush(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_flush
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_output_stream_close (GOutputStream *stream, GCancellable *cancellable, GError **error);
function g_output_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_output_stream_write_async (GOutputStream *stream, const void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_write_async(stream, buffer, count, io_priority, canc&
&ellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_output_stream_write_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_write_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_write_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_splice_async (GOutputStream *stream, GInputStream *source, GOutputStreamSpliceFlags flags, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_splice_async(stream, source, flags, io_priority, can&
&cellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: source
  integer(c_int), value :: flags
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_output_stream_splice_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_splice_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_output_stream_splice_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_flush_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_flush_async(stream, io_priority, cancellable, callba&
&ck, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_output_stream_flush_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_flush_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_flush_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_output_stream_close_async (GOutputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_output_stream_close_async(stream, io_priority, cancellable, callba&
&ck, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_output_stream_close_finish (GOutputStream *stream, GAsyncResult *result, GError **error);
function g_output_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_output_stream_is_closed (GOutputStream *stream);
function g_output_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_is_closing (GOutputStream *stream);
function g_output_stream_is_closing(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_is_closing
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_has_pending (GOutputStream *stream);
function g_output_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_output_stream_set_pending (GOutputStream *stream, GError **error);
function g_output_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_output_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_output_stream_clear_pending (GOutputStream *stream);
subroutine g_output_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GType g_tcp_wrapper_connection_get_type (void) G_GNUC_CONST;
function g_tcp_wrapper_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tcp_wrapper_connection_get_type
end function

!  GSocketConnection *g_tcp_wrapper_connection_new (GIOStream *base_io_stream, GSocket *socket);
function g_tcp_wrapper_connection_new(base_io_stream, socket) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tcp_wrapper_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: socket
end function

! GIOStream *g_tcp_wrapper_connection_get_base_io_stream (GTcpWrapperConnection *conn);
function g_tcp_wrapper_connection_get_base_io_stream(conn) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tcp_wrapper_connection_get_base_io_stream
  type(c_ptr), value :: conn
end function

!   GType g_socket_connectable_get_type (void) G_GNUC_CONST;
function g_socket_connectable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_connectable_get_type
end function

!  GSocketAddressEnumerator *g_socket_connectable_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_enumerate(connectable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connectable_enumerate
  type(c_ptr), value :: connectable
end function

!  GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate (GSocketConnectable *connectable);
function g_socket_connectable_proxy_enumerate(connectable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connectable_proxy_enumerate
  type(c_ptr), value :: connectable
end function

!   GType g_mount_get_type (void) G_GNUC_CONST;
function g_mount_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_get_type
end function

!  GFile * g_mount_get_root (GMount *mount);
function g_mount_get_root(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_root
  type(c_ptr), value :: mount
end function

! GFile * g_mount_get_default_location (GMount *mount);
function g_mount_get_default_location(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_default_location
  type(c_ptr), value :: mount
end function

! char * g_mount_get_name (GMount *mount);
function g_mount_get_name(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_name
  type(c_ptr), value :: mount
end function

! GIcon * g_mount_get_icon (GMount *mount);
function g_mount_get_icon(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_icon
  type(c_ptr), value :: mount
end function

! char * g_mount_get_uuid (GMount *mount);
function g_mount_get_uuid(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_uuid
  type(c_ptr), value :: mount
end function

! GVolume * g_mount_get_volume (GMount *mount);
function g_mount_get_volume(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_volume
  type(c_ptr), value :: mount
end function

! GDrive * g_mount_get_drive (GMount *mount);
function g_mount_get_drive(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_get_drive
  type(c_ptr), value :: mount
end function

! gboolean g_mount_can_unmount (GMount *mount);
function g_mount_can_unmount(mount) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_can_unmount
  type(c_ptr), value :: mount
end function

! gboolean g_mount_can_eject (GMount *mount);
function g_mount_can_eject(mount) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_can_eject
  type(c_ptr), value :: mount
end function

!  void g_mount_unmount (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount(mount, flags, cancellable, callback, user_data) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_unmount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_unmount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_eject (GMount *mount, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject(mount, flags, cancellable, callback, user_data) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_eject_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_eject_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_remount (GMount *mount, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_remount(mount, flags, mount_operation, cancellable, callback&
&, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_remount_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_remount_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_remount_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_guess_content_type (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_guess_content_type(mount, force_rescan, cancellable, callbac&
&k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar ** g_mount_guess_content_type_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_guess_content_type_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_guess_content_type_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! gchar ** g_mount_guess_content_type_sync (GMount *mount, gboolean force_rescan, GCancellable *cancellable, GError **error);
function g_mount_guess_content_type_sync(mount, force_rescan, cancellable, erro&
&r) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_mount_guess_content_type_sync
  type(c_ptr), value :: mount
  integer(c_int), value :: force_rescan
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_mount_is_shadowed (GMount *mount);
function g_mount_is_shadowed(mount) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_is_shadowed
  type(c_ptr), value :: mount
end function

! void g_mount_shadow (GMount *mount);
subroutine g_mount_shadow(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mount
end subroutine

! void g_mount_unshadow (GMount *mount);
subroutine g_mount_unshadow(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mount
end subroutine

!  void g_mount_unmount_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_unmount_with_operation(mount, flags, mount_operation, cancel&
&lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_unmount_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_unmount_with_operation_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_unmount_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_mount_eject_with_operation (GMount *mount, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_mount_eject_with_operation(mount, flags, mount_operation, cancella&
&ble, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: mount
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_mount_eject_with_operation_finish (GMount *mount, GAsyncResult *result, GError **error);
function g_mount_eject_with_operation_finish(mount, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_eject_with_operation_finish
  type(c_ptr), value :: mount
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_application_get_type (void) G_GNUC_CONST;
function g_application_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_application_get_type
end function

!  gboolean g_application_id_is_valid (const gchar *application_id);
function g_application_id_is_valid(application_id) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_application_id_is_valid
  character(kind=c_char), dimension(*) :: application_id
end function

!  GApplication * g_application_new (const gchar *application_id, GApplicationFlags flags);
function g_application_new(application_id, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_application_new
  character(kind=c_char), dimension(*) :: application_id
  integer(c_int), value :: flags
end function

!  const gchar * g_application_get_application_id (GApplication *application);
function g_application_get_application_id(application) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_application_get_application_id
  type(c_ptr), value :: application
end function

! void g_application_set_application_id (GApplication *application, const gchar *application_id);
subroutine g_application_set_application_id(application, application_id) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: application
  character(kind=c_char), dimension(*) :: application_id
end subroutine

!  guint g_application_get_inactivity_timeout (GApplication *application);
function g_application_get_inactivity_timeout(application) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_get_inactivity_timeout
  type(c_ptr), value :: application
end function

! void g_application_set_inactivity_timeout (GApplication *application, guint inactivity_timeout);
subroutine g_application_set_inactivity_timeout(application, inactivity_timeout&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: application
  integer(c_int), value :: inactivity_timeout
end subroutine

!  GApplicationFlags g_application_get_flags (GApplication *application);
function g_application_get_flags(application) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_get_flags
  type(c_ptr), value :: application
end function

! void g_application_set_flags (GApplication *application, GApplicationFlags flags);
subroutine g_application_set_flags(application, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: application
  integer(c_int), value :: flags
end subroutine

!  void g_application_set_action_group (GApplication *application, GActionGroup *action_group);
subroutine g_application_set_action_group(application, action_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: application
  type(c_ptr), value :: action_group
end subroutine

!  gboolean g_application_get_is_registered (GApplication *application);
function g_application_get_is_registered(application) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_get_is_registered
  type(c_ptr), value :: application
end function

! gboolean g_application_get_is_remote (GApplication *application);
function g_application_get_is_remote(application) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_get_is_remote
  type(c_ptr), value :: application
end function

!  gboolean g_application_register (GApplication *application, GCancellable *cancellable, GError **error);
function g_application_register(application, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_register
  type(c_ptr), value :: application
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_application_hold (GApplication *application);
subroutine g_application_hold(application) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: application
end subroutine

! void g_application_release (GApplication *application);
subroutine g_application_release(application) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: application
end subroutine

!  void g_application_activate (GApplication *application);
subroutine g_application_activate(application) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: application
end subroutine

!  void g_application_open (GApplication *application, GFile **files, gint n_files, const gchar *hint);
subroutine g_application_open(application, files, n_files, hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: application
  type(c_ptr), value :: files
  integer(c_int), value :: n_files
  character(kind=c_char), dimension(*) :: hint
end subroutine

!  int g_application_run (GApplication *application, int argc, char **argv);
function g_application_run(application, argc, argv) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_run
  type(c_ptr), value :: application
  integer(c_int), value :: argc
  type(c_ptr), dimension(*) :: argv
end function

!   GType g_drive_get_type (void) G_GNUC_CONST;
function g_drive_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_get_type
end function

!  char * g_drive_get_name (GDrive *drive);
function g_drive_get_name(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_name
  type(c_ptr), value :: drive
end function

! GIcon * g_drive_get_icon (GDrive *drive);
function g_drive_get_icon(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_icon
  type(c_ptr), value :: drive
end function

! gboolean g_drive_has_volumes (GDrive *drive);
function g_drive_has_volumes(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_has_volumes
  type(c_ptr), value :: drive
end function

! GList * g_drive_get_volumes (GDrive *drive);
function g_drive_get_volumes(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_get_volumes
  type(c_ptr), value :: drive
end function

! gboolean g_drive_is_media_removable (GDrive *drive);
function g_drive_is_media_removable(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_is_media_removable
  type(c_ptr), value :: drive
end function

! gboolean g_drive_has_media (GDrive *drive);
function g_drive_has_media(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_has_media
  type(c_ptr), value :: drive
end function

! gboolean g_drive_is_media_check_automatic (GDrive *drive);
function g_drive_is_media_check_automatic(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_is_media_check_automatic
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_poll_for_media (GDrive *drive);
function g_drive_can_poll_for_media(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_can_poll_for_media
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_eject (GDrive *drive);
function g_drive_can_eject(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_can_eject
  type(c_ptr), value :: drive
end function

!  void g_drive_eject (GDrive *drive, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject(drive, flags, cancellable, callback, user_data) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_eject_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_eject_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_drive_poll_for_media (GDrive *drive, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_poll_for_media(drive, cancellable, callback, user_data) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: drive
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_poll_for_media_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_poll_for_media_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_poll_for_media_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_drive_get_identifier (GDrive *drive, const char *kind);
function g_drive_get_identifier(drive, kind) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_drive_get_identifier
  type(c_ptr), value :: drive
  character(kind=c_char), dimension(*) :: kind
end function

! char ** g_drive_enumerate_identifiers (GDrive *drive);
function g_drive_enumerate_identifiers(drive) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_drive_enumerate_identifiers
  type(c_ptr), value :: drive
end function

!  GDriveStartStopType g_drive_get_start_stop_type (GDrive *drive);
function g_drive_get_start_stop_type(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_get_start_stop_type
  type(c_ptr), value :: drive
end function

!  gboolean g_drive_can_start (GDrive *drive);
function g_drive_can_start(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_can_start
  type(c_ptr), value :: drive
end function

! gboolean g_drive_can_start_degraded (GDrive *drive);
function g_drive_can_start_degraded(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_can_start_degraded
  type(c_ptr), value :: drive
end function

! void g_drive_start (GDrive *drive, GDriveStartFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_start(drive, flags, mount_operation, cancellable, callback, &
&user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_start_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_start_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_start_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_drive_can_stop (GDrive *drive);
function g_drive_can_stop(drive) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_can_stop
  type(c_ptr), value :: drive
end function

! void g_drive_stop (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_stop(drive, flags, mount_operation, cancellable, callback, u&
&ser_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_stop_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_stop_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_stop_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_drive_eject_with_operation (GDrive *drive, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_drive_eject_with_operation(drive, flags, mount_operation, cancella&
&ble, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: drive
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_drive_eject_with_operation_finish (GDrive *drive, GAsyncResult *result, GError **error);
function g_drive_eject_with_operation_finish(drive, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_drive_eject_with_operation_finish
  type(c_ptr), value :: drive
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_resolver_get_type (void) G_GNUC_CONST;
function g_resolver_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_resolver_get_type
end function

! GResolver *g_resolver_get_default (void);
function g_resolver_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_get_default
end function

! void g_resolver_set_default (GResolver *resolver);
subroutine g_resolver_set_default(resolver) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: resolver
end subroutine

!  GList *g_resolver_lookup_by_name (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_name(resolver, hostname, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_by_name
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_by_name_async (GResolver *resolver, const gchar *hostname, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_name_async(resolver, hostname, cancellable, cal&
&lback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: hostname
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList *g_resolver_lookup_by_name_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_name_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_name_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_resolver_free_addresses (GList *addresses);
subroutine g_resolver_free_addresses(addresses) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: addresses
end subroutine

!  gchar *g_resolver_lookup_by_address (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GError **error);
function g_resolver_lookup_by_address(resolver, address, cancellable, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_by_address_async (GResolver *resolver, GInetAddress *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_by_address_async(resolver, address, cancellable, c&
&allback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: resolver
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar *g_resolver_lookup_by_address_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_by_address_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_by_address_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  GList *g_resolver_lookup_service (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GError **error);
function g_resolver_lookup_service(resolver, service, protocol, domain, cancell&
&able, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_resolver_lookup_service
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_resolver_lookup_service_async (GResolver *resolver, const gchar *service, const gchar *protocol, const gchar *domain, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_resolver_lookup_service_async(resolver, service, protocol, domain,&
& cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList *g_resolver_lookup_service_finish (GResolver *resolver, GAsyncResult *result, GError **error);
function g_resolver_lookup_service_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_resolver_lookup_service_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_resolver_free_targets (GList *targets);
subroutine g_resolver_free_targets(targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: targets
end subroutine

!  GQuark g_resolver_error_quark (void);
function g_resolver_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_resolver_error_quark
end function

!   GType g_simple_action_get_type (void) G_GNUC_CONST;
function g_simple_action_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_action_get_type
end function

!  GSimpleAction * g_simple_action_new (const gchar *name, const GVariantType *parameter_type);
function g_simple_action_new(name, parameter_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_simple_action_new
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: parameter_type
end function

!  GSimpleAction * g_simple_action_new_stateful (const gchar *name, const GVariantType *parameter_type, GVariant *state);
function g_simple_action_new_stateful(name, parameter_type, state) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_simple_action_new_stateful
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: parameter_type
  type(c_ptr), value :: state
end function

!  void g_simple_action_set_enabled (GSimpleAction *simple, gboolean enabled);
subroutine g_simple_action_set_enabled(simple, enabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: simple
  integer(c_int), value :: enabled
end subroutine

!   GType g_buffered_output_stream_get_type (void) G_GNUC_CONST;
function g_buffered_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_buffered_output_stream_get_type
end function

! GOutputStream* g_buffered_output_stream_new (GOutputStream *base_stream);
function g_buffered_output_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_buffered_output_stream_new
  type(c_ptr), value :: base_stream
end function

! GOutputStream* g_buffered_output_stream_new_sized (GOutputStream *base_stream, gsize size);
function g_buffered_output_stream_new_sized(base_stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_buffered_output_stream_new_sized
  type(c_ptr), value :: base_stream
  integer(c_size_t), value :: size
end function

! gsize g_buffered_output_stream_get_buffer_size (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_buffer_size(stream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_buffered_output_stream_get_buffer_size
  type(c_ptr), value :: stream
end function

! void g_buffered_output_stream_set_buffer_size (GBufferedOutputStream *stream, gsize size);
subroutine g_buffered_output_stream_set_buffer_size(stream, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: stream
  integer(c_size_t), value :: size
end subroutine

! gboolean g_buffered_output_stream_get_auto_grow (GBufferedOutputStream *stream);
function g_buffered_output_stream_get_auto_grow(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_buffered_output_stream_get_auto_grow
  type(c_ptr), value :: stream
end function

! void g_buffered_output_stream_set_auto_grow (GBufferedOutputStream *stream, gboolean auto_grow);
subroutine g_buffered_output_stream_set_auto_grow(stream, auto_grow) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: auto_grow
end subroutine

!   GType g_memory_output_stream_get_type (void) G_GNUC_CONST;
function g_memory_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_memory_output_stream_get_type
end function

!  GOutputStream *g_memory_output_stream_new (gpointer data, gsize size, GReallocFunc realloc_function, GDestroyNotify destroy_function);
function g_memory_output_stream_new(data, size, realloc_function, destroy_funct&
&ion) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_output_stream_new
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  type(c_funptr), value :: realloc_function
  type(c_funptr), value :: destroy_function
end function

! gpointer g_memory_output_stream_get_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data(ostream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_output_stream_get_data
  type(c_ptr), value :: ostream
end function

! gsize g_memory_output_stream_get_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_size(ostream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_size
  type(c_ptr), value :: ostream
end function

! gsize g_memory_output_stream_get_data_size (GMemoryOutputStream *ostream);
function g_memory_output_stream_get_data_size(ostream) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_memory_output_stream_get_data_size
  type(c_ptr), value :: ostream
end function

! gpointer g_memory_output_stream_steal_data (GMemoryOutputStream *ostream);
function g_memory_output_stream_steal_data(ostream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_output_stream_steal_data
  type(c_ptr), value :: ostream
end function

!   GQuark g_io_error_quark (void);
function g_io_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_io_error_quark
end function

! GIOErrorEnum g_io_error_from_errno (gint err_no);
function g_io_error_from_errno(err_no) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_io_error_from_errno
  integer(c_int), value :: err_no
end function

!  GIOErrorEnum g_io_error_from_win32_error (gint error_code);
function g_io_error_from_win32_error(error_code) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_io_error_from_win32_error
  integer(c_int), value :: error_code
end function

!   GType g_file_monitor_get_type (void) G_GNUC_CONST;
function g_file_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_get_type
end function

!  gboolean g_file_monitor_cancel (GFileMonitor *monitor);
function g_file_monitor_cancel(monitor) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_monitor_cancel
  type(c_ptr), value :: monitor
end function

! gboolean g_file_monitor_is_cancelled (GFileMonitor *monitor);
function g_file_monitor_is_cancelled(monitor) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_monitor_is_cancelled
  type(c_ptr), value :: monitor
end function

! void g_file_monitor_set_rate_limit (GFileMonitor *monitor, gint limit_msecs);
subroutine g_file_monitor_set_rate_limit(monitor, limit_msecs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: monitor
  integer(c_int), value :: limit_msecs
end subroutine

!  void g_file_monitor_emit_event (GFileMonitor *monitor, GFile *child, GFile *other_file, GFileMonitorEvent event_type);
subroutine g_file_monitor_emit_event(monitor, child, other_file, event_type) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: monitor
  type(c_ptr), value :: child
  type(c_ptr), value :: other_file
  integer(c_int), value :: event_type
end subroutine

!   GType g_icon_get_type (void) G_GNUC_CONST;
function g_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_icon_get_type
end function

!  guint g_icon_hash (gconstpointer icon);
function g_icon_hash(icon) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_icon_hash
  type(c_ptr), value :: icon
end function

! gboolean g_icon_equal (GIcon *icon1, GIcon *icon2);
function g_icon_equal(icon1, icon2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_icon_equal
  type(c_ptr), value :: icon1
  type(c_ptr), value :: icon2
end function

! gchar *g_icon_to_string (GIcon *icon);
function g_icon_to_string(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_icon_to_string
  type(c_ptr), value :: icon
end function

! GIcon *g_icon_new_for_string (const gchar *str, GError **error);
function g_icon_new_for_string(str, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_icon_new_for_string
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: error
end function

!   GType g_tls_backend_get_type (void) G_GNUC_CONST;
function g_tls_backend_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_backend_get_type
end function

!  GTlsBackend *g_tls_backend_get_default (void);
function g_tls_backend_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_backend_get_default
end function

!  gboolean g_tls_backend_supports_tls (GTlsBackend *backend);
function g_tls_backend_supports_tls(backend) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_backend_supports_tls
  type(c_ptr), value :: backend
end function

!  GType g_tls_backend_get_certificate_type (GTlsBackend *backend);
function g_tls_backend_get_certificate_type(backend) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_certificate_type
  type(c_ptr), value :: backend
end function

! GType g_tls_backend_get_client_connection_type (GTlsBackend *backend);
function g_tls_backend_get_client_connection_type(backend) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_client_connection_type
  type(c_ptr), value :: backend
end function

! GType g_tls_backend_get_server_connection_type (GTlsBackend *backend);
function g_tls_backend_get_server_connection_type(backend) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_tls_backend_get_server_connection_type
  type(c_ptr), value :: backend
end function

!   GType g_socket_service_get_type (void);
function g_socket_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_service_get_type
end function

!  GSocketService *g_socket_service_new (void);
function g_socket_service_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_service_new
end function

! void g_socket_service_start (GSocketService *service);
subroutine g_socket_service_start(service) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: service
end subroutine

! void g_socket_service_stop (GSocketService *service);
subroutine g_socket_service_stop(service) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: service
end subroutine

! gboolean g_socket_service_is_active (GSocketService *service);
function g_socket_service_is_active(service) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_service_is_active
  type(c_ptr), value :: service
end function

!   GType g_file_output_stream_get_type (void) G_GNUC_CONST;
function g_file_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_output_stream_get_type
end function

!  GFileInfo *g_file_output_stream_query_info (GFileOutputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_output_stream_query_info(stream, attributes, cancellable, error&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_output_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_output_stream_query_info_async (GFileOutputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_output_stream_query_info_async(stream, attributes, io_priorit&
&y, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_output_stream_query_info_finish (GFileOutputStream *stream, GAsyncResult *result, GError **error);
function g_file_output_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_output_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_file_output_stream_get_etag (GFileOutputStream *stream);
function g_file_output_stream_get_etag(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_output_stream_get_etag
  type(c_ptr), value :: stream
end function

!   GType g_mount_operation_get_type (void) G_GNUC_CONST;
function g_mount_operation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_operation_get_type
end function

! GMountOperation * g_mount_operation_new (void);
function g_mount_operation_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_new
end function

!  const char * g_mount_operation_get_username (GMountOperation *op);
function g_mount_operation_get_username(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_username
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_username (GMountOperation *op, const char *username);
subroutine g_mount_operation_set_username(op, username) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: username
end subroutine

! const char * g_mount_operation_get_password (GMountOperation *op);
function g_mount_operation_get_password(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_password
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_password (GMountOperation *op, const char *password);
subroutine g_mount_operation_set_password(op, password) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: password
end subroutine

! gboolean g_mount_operation_get_anonymous (GMountOperation *op);
function g_mount_operation_get_anonymous(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_anonymous
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_anonymous (GMountOperation *op, gboolean anonymous);
subroutine g_mount_operation_set_anonymous(op, anonymous) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: anonymous
end subroutine

! const char * g_mount_operation_get_domain (GMountOperation *op);
function g_mount_operation_get_domain(op) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mount_operation_get_domain
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_domain (GMountOperation *op, const char *domain);
subroutine g_mount_operation_set_domain(op, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: op
  character(kind=c_char), dimension(*) :: domain
end subroutine

! GPasswordSave g_mount_operation_get_password_save (GMountOperation *op);
function g_mount_operation_get_password_save(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_password_save
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_password_save (GMountOperation *op, GPasswordSave save);
subroutine g_mount_operation_set_password_save(op, save) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: save
end subroutine

! int g_mount_operation_get_choice (GMountOperation *op);
function g_mount_operation_get_choice(op) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_mount_operation_get_choice
  type(c_ptr), value :: op
end function

! void g_mount_operation_set_choice (GMountOperation *op, int choice);
subroutine g_mount_operation_set_choice(op, choice) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: choice
end subroutine

! void g_mount_operation_reply (GMountOperation *op, GMountOperationResult result);
subroutine g_mount_operation_reply(op, result) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: op
  integer(c_int), value :: result
end subroutine

!   GType g_socket_address_get_type (void) G_GNUC_CONST;
function g_socket_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_address_get_type
end function

!  GSocketFamily g_socket_address_get_family (GSocketAddress *address);
function g_socket_address_get_family(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_address_get_family
  type(c_ptr), value :: address
end function

!  GSocketAddress * g_socket_address_new_from_native (gpointer native, gsize len);
function g_socket_address_new_from_native(native, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_socket_address_new_from_native
  type(c_ptr), value :: native
  integer(c_size_t), value :: len
end function

!  gboolean g_socket_address_to_native (GSocketAddress *address, gpointer dest, gsize destlen, GError **error);
function g_socket_address_to_native(address, dest, destlen, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_socket_address_to_native
  type(c_ptr), value :: address
  type(c_ptr), value :: dest
  integer(c_size_t), value :: destlen
  type(c_ptr), value :: error
end function

!  gssize g_socket_address_get_native_size (GSocketAddress *address);
function g_socket_address_get_native_size(address) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_address_get_native_size
  type(c_ptr), value :: address
end function

!   GType g_dbus_server_get_type (void) G_GNUC_CONST;
function g_dbus_server_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_server_get_type
end function

! GDBusServer *g_dbus_server_new_sync (const gchar *address, GDBusServerFlags flags, const gchar *guid, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_server_new_sync(address, flags, guid, observer, cancellable, er&
&ror) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_server_new_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  character(kind=c_char), dimension(*) :: guid
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! const gchar *g_dbus_server_get_client_address (GDBusServer *server);
function g_dbus_server_get_client_address(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_server_get_client_address
  type(c_ptr), value :: server
end function

! const gchar *g_dbus_server_get_guid (GDBusServer *server);
function g_dbus_server_get_guid(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_server_get_guid
  type(c_ptr), value :: server
end function

! GDBusServerFlags g_dbus_server_get_flags (GDBusServer *server);
function g_dbus_server_get_flags(server) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_server_get_flags
  type(c_ptr), value :: server
end function

! void g_dbus_server_start (GDBusServer *server);
subroutine g_dbus_server_start(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: server
end subroutine

! void g_dbus_server_stop (GDBusServer *server);
subroutine g_dbus_server_stop(server) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: server
end subroutine

! gboolean g_dbus_server_is_active (GDBusServer *server);
function g_dbus_server_is_active(server) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_server_is_active
  type(c_ptr), value :: server
end function

!   GType g_proxy_get_type (void) G_GNUC_CONST;
function g_proxy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_get_type
end function

!  GProxy *g_proxy_get_default_for_protocol (const gchar *protocol);
function g_proxy_get_default_for_protocol(protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_proxy_get_default_for_protocol
  character(kind=c_char), dimension(*) :: protocol
end function

!  GIOStream *g_proxy_connect (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GError **error);
function g_proxy_connect(proxy, connection, proxy_address, cancellable, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_connect
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_proxy_connect_async (GProxy *proxy, GIOStream *connection, GProxyAddress *proxy_address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_connect_async(proxy, connection, proxy_address, cancellable,&
& callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: connection
  type(c_ptr), value :: proxy_address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GIOStream *g_proxy_connect_finish (GProxy *proxy, GAsyncResult *result, GError **error);
function g_proxy_connect_finish(proxy, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_connect_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_proxy_supports_hostname (GProxy *proxy);
function g_proxy_supports_hostname(proxy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_proxy_supports_hostname
  type(c_ptr), value :: proxy
end function

!   GType g_vfs_get_type (void) G_GNUC_CONST;
function g_vfs_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_vfs_get_type
end function

!  gboolean g_vfs_is_active (GVfs *vfs);
function g_vfs_is_active(vfs) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_vfs_is_active
  type(c_ptr), value :: vfs
end function

! GFile * g_vfs_get_file_for_path (GVfs *vfs, const char *path);
function g_vfs_get_file_for_path(vfs, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_path
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: path
end function

! GFile * g_vfs_get_file_for_uri (GVfs *vfs, const char *uri);
function g_vfs_get_file_for_uri(vfs, uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_get_file_for_uri
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: uri
end function

! const gchar* const * g_vfs_get_supported_uri_schemes (GVfs *vfs);
function g_vfs_get_supported_uri_schemes(vfs) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_supported_uri_schemes
  type(c_ptr), value :: vfs
end function

!  GFile * g_vfs_parse_name (GVfs *vfs, const char *parse_name);
function g_vfs_parse_name(vfs, parse_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_vfs_parse_name
  type(c_ptr), value :: vfs
  character(kind=c_char), dimension(*) :: parse_name
end function

!  GVfs * g_vfs_get_default (void);
function g_vfs_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_default
end function

! GVfs * g_vfs_get_local (void);
function g_vfs_get_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_vfs_get_local
end function

!   GType g_proxy_address_enumerator_get_type (void) G_GNUC_CONST;
function g_proxy_address_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_address_enumerator_get_type
end function

!   GType g_socket_control_message_get_type (void) G_GNUC_CONST;
function g_socket_control_message_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_control_message_get_type
end function

! gsize g_socket_control_message_get_size (GSocketControlMessage *message);
function g_socket_control_message_get_size(message) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_socket_control_message_get_size
  type(c_ptr), value :: message
end function

! int g_socket_control_message_get_level (GSocketControlMessage *message);
function g_socket_control_message_get_level(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_level
  type(c_ptr), value :: message
end function

! int g_socket_control_message_get_msg_type (GSocketControlMessage *message);
function g_socket_control_message_get_msg_type(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_control_message_get_msg_type
  type(c_ptr), value :: message
end function

! void g_socket_control_message_serialize (GSocketControlMessage *message, gpointer data);
subroutine g_socket_control_message_serialize(message, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: data
end subroutine

! GSocketControlMessage *g_socket_control_message_deserialize (int level, int type, gsize size, gpointer data);
function g_socket_control_message_deserialize(level, type, size, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_size_t
  type(c_ptr) :: g_socket_control_message_deserialize
  integer(c_int), value :: level
  integer(c_int), value :: type
  integer(c_size_t), value :: size
  type(c_ptr), value :: data
end function

!   GType g_io_module_get_type (void) G_GNUC_CONST;
function g_io_module_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_module_get_type
end function

! GIOModule *g_io_module_new (const gchar *filename);
function g_io_module_new(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_module_new
  character(kind=c_char), dimension(*) :: filename
end function

!  void g_io_modules_scan_all_in_directory (const char *dirname);
subroutine g_io_modules_scan_all_in_directory(dirname) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: dirname
end subroutine

! GList *g_io_modules_load_all_in_directory (const gchar *dirname);
function g_io_modules_load_all_in_directory(dirname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_modules_load_all_in_directory
  character(kind=c_char), dimension(*) :: dirname
end function

!  GIOExtensionPoint *g_io_extension_point_register (const char *name);
function g_io_extension_point_register(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_register
  character(kind=c_char), dimension(*) :: name
end function

! GIOExtensionPoint *g_io_extension_point_lookup (const char *name);
function g_io_extension_point_lookup(name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_lookup
  character(kind=c_char), dimension(*) :: name
end function

! void g_io_extension_point_set_required_type (GIOExtensionPoint *extension_point, GType type);
subroutine g_io_extension_point_set_required_type(extension_point, type) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: extension_point
  integer(c_size_t), value :: type
end subroutine

! GType g_io_extension_point_get_required_type (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_required_type(extension_point) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_point_get_required_type
  type(c_ptr), value :: extension_point
end function

! GList *g_io_extension_point_get_extensions (GIOExtensionPoint *extension_point);
function g_io_extension_point_get_extensions(extension_point) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_point_get_extensions
  type(c_ptr), value :: extension_point
end function

! GIOExtension * g_io_extension_point_get_extension_by_name (GIOExtensionPoint *extension_point, const char *name);
function g_io_extension_point_get_extension_by_name(extension_point, name) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_io_extension_point_get_extension_by_name
  type(c_ptr), value :: extension_point
  character(kind=c_char), dimension(*) :: name
end function

! GIOExtension * g_io_extension_point_implement (const char *extension_point_name, GType type, const char *extension_name, gint priority);
function g_io_extension_point_implement(extension_point_name, type, extension_n&
&ame, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_io_extension_point_implement
  character(kind=c_char), dimension(*) :: extension_point_name
  integer(c_size_t), value :: type
  character(kind=c_char), dimension(*) :: extension_name
  integer(c_int), value :: priority
end function

!  GType g_io_extension_get_type (GIOExtension *extension);
function g_io_extension_get_type(extension) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_io_extension_get_type
  type(c_ptr), value :: extension
end function

! const char * g_io_extension_get_name (GIOExtension *extension);
function g_io_extension_get_name(extension) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_get_name
  type(c_ptr), value :: extension
end function

! gint g_io_extension_get_priority (GIOExtension *extension);
function g_io_extension_get_priority(extension) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_io_extension_get_priority
  type(c_ptr), value :: extension
end function

! GTypeClass* g_io_extension_ref_class (GIOExtension *extension);
function g_io_extension_ref_class(extension) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_extension_ref_class
  type(c_ptr), value :: extension
end function

!  void g_io_module_load (GIOModule *module);
subroutine g_io_module_load(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  void g_io_module_unload (GIOModule *module);
subroutine g_io_module_unload(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

!  char **g_io_module_query (void);
function g_io_module_query() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_io_module_query
end function

!   GType g_socket_client_get_type (void) G_GNUC_CONST;
function g_socket_client_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_client_get_type
end function

!  GSocketClient *g_socket_client_new (void);
function g_socket_client_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_new
end function

!  GSocketFamily g_socket_client_get_family (GSocketClient *client);
function g_socket_client_get_family(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_family
  type(c_ptr), value :: client
end function

! void g_socket_client_set_family (GSocketClient *client, GSocketFamily family);
subroutine g_socket_client_set_family(client, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: family
end subroutine

! GSocketType g_socket_client_get_socket_type (GSocketClient *client);
function g_socket_client_get_socket_type(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_socket_type
  type(c_ptr), value :: client
end function

! void g_socket_client_set_socket_type (GSocketClient *client, GSocketType type);
subroutine g_socket_client_set_socket_type(client, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: type
end subroutine

! GSocketProtocol g_socket_client_get_protocol (GSocketClient *client);
function g_socket_client_get_protocol(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_protocol
  type(c_ptr), value :: client
end function

! void g_socket_client_set_protocol (GSocketClient *client, GSocketProtocol protocol);
subroutine g_socket_client_set_protocol(client, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: protocol
end subroutine

! GSocketAddress *g_socket_client_get_local_address (GSocketClient *client);
function g_socket_client_get_local_address(client) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_get_local_address
  type(c_ptr), value :: client
end function

! void g_socket_client_set_local_address (GSocketClient *client, GSocketAddress *address);
subroutine g_socket_client_set_local_address(client, address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: client
  type(c_ptr), value :: address
end subroutine

! guint g_socket_client_get_timeout (GSocketClient *client);
function g_socket_client_get_timeout(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_timeout
  type(c_ptr), value :: client
end function

! void g_socket_client_set_timeout (GSocketClient *client, guint timeout);
subroutine g_socket_client_set_timeout(client, timeout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: timeout
end subroutine

! gboolean g_socket_client_get_enable_proxy (GSocketClient *client);
function g_socket_client_get_enable_proxy(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_enable_proxy
  type(c_ptr), value :: client
end function

! void g_socket_client_set_enable_proxy (GSocketClient *client, gboolean enable);
subroutine g_socket_client_set_enable_proxy(client, enable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: enable
end subroutine

!  gboolean g_socket_client_get_tls (GSocketClient *client);
function g_socket_client_get_tls(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_tls
  type(c_ptr), value :: client
end function

! void g_socket_client_set_tls (GSocketClient *client, gboolean tls);
subroutine g_socket_client_set_tls(client, tls) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: tls
end subroutine

! GTlsCertificateFlags g_socket_client_get_tls_validation_flags (GSocketClient *client);
function g_socket_client_get_tls_validation_flags(client) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_client_get_tls_validation_flags
  type(c_ptr), value :: client
end function

! void g_socket_client_set_tls_validation_flags (GSocketClient *client, GTlsCertificateFlags flags);
subroutine g_socket_client_set_tls_validation_flags(client, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: client
  integer(c_int), value :: flags
end subroutine

!  GSocketConnection * g_socket_client_connect (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GError **error);
function g_socket_client_connect(client, connectable, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_host (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_host(client, host_and_port, default_port, c&
&ancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_host
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_service (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_service(client, domain, service, cancellabl&
&e, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_socket_client_connect_to_service
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocketConnection * g_socket_client_connect_to_uri (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GError **error);
function g_socket_client_connect_to_uri(client, uri, default_port, cancellable,&
& error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_socket_client_connect_to_uri
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_async (GSocketClient *client, GSocketConnectable *connectable, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_async(client, connectable, cancellable, call&
&back, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: client
  type(c_ptr), value :: connectable
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_to_host_async (GSocketClient *client, const gchar *host_and_port, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_host_async(client, host_and_port, default&
&_port, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: host_and_port
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_host_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_host_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_host_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_socket_client_connect_to_service_async (GSocketClient *client, const gchar *domain, const gchar *service, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_service_async(client, domain, service, ca&
&ncellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: service
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_service_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_service_finish(client, result, error) bind(&
&c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_service_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_connect_to_uri_async (GSocketClient *client, const gchar *uri, guint16 default_port, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_socket_client_connect_to_uri_async(client, uri, default_port, canc&
&ellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t, c_funptr
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: uri
  integer(c_int16_t), value :: default_port
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GSocketConnection * g_socket_client_connect_to_uri_finish (GSocketClient *client, GAsyncResult *result, GError **error);
function g_socket_client_connect_to_uri_finish(client, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_client_connect_to_uri_finish
  type(c_ptr), value :: client
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_socket_client_add_application_proxy (GSocketClient *client, const gchar *protocol);
subroutine g_socket_client_add_application_proxy(client, protocol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: client
  character(kind=c_char), dimension(*) :: protocol
end subroutine

!   GType g_socket_get_type (void) G_GNUC_CONST;
function g_socket_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_get_type
end function

! GSocket * g_socket_new (GSocketFamily family, GSocketType type, GSocketProtocol protocol, GError **error);
function g_socket_new(family, type, protocol, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_new
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
  type(c_ptr), value :: error
end function

! GSocket * g_socket_new_from_fd (gint fd, GError **error);
function g_socket_new_from_fd(fd, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_new_from_fd
  integer(c_int), value :: fd
  type(c_ptr), value :: error
end function

! int g_socket_get_fd (GSocket *socket);
function g_socket_get_fd(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_fd
  type(c_ptr), value :: socket
end function

! GSocketFamily g_socket_get_family (GSocket *socket);
function g_socket_get_family(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_family
  type(c_ptr), value :: socket
end function

! GSocketType g_socket_get_socket_type (GSocket *socket);
function g_socket_get_socket_type(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_socket_type
  type(c_ptr), value :: socket
end function

! GSocketProtocol g_socket_get_protocol (GSocket *socket);
function g_socket_get_protocol(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_protocol
  type(c_ptr), value :: socket
end function

! GSocketAddress * g_socket_get_local_address (GSocket *socket, GError **error);
function g_socket_get_local_address(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_local_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GSocketAddress * g_socket_get_remote_address (GSocket *socket, GError **error);
function g_socket_get_remote_address(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_remote_address
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! void g_socket_set_blocking (GSocket *socket, gboolean blocking);
subroutine g_socket_set_blocking(socket, blocking) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: blocking
end subroutine

! gboolean g_socket_get_blocking (GSocket *socket);
function g_socket_get_blocking(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_blocking
  type(c_ptr), value :: socket
end function

! void g_socket_set_keepalive (GSocket *socket, gboolean keepalive);
subroutine g_socket_set_keepalive(socket, keepalive) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: keepalive
end subroutine

! gboolean g_socket_get_keepalive (GSocket *socket);
function g_socket_get_keepalive(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_keepalive
  type(c_ptr), value :: socket
end function

! gint g_socket_get_listen_backlog (GSocket *socket);
function g_socket_get_listen_backlog(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_listen_backlog
  type(c_ptr), value :: socket
end function

! void g_socket_set_listen_backlog (GSocket *socket, gint backlog);
subroutine g_socket_set_listen_backlog(socket, backlog) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: backlog
end subroutine

! guint g_socket_get_timeout (GSocket *socket);
function g_socket_get_timeout(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_get_timeout
  type(c_ptr), value :: socket
end function

! void g_socket_set_timeout (GSocket *socket, guint timeout);
subroutine g_socket_set_timeout(socket, timeout) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: socket
  integer(c_int), value :: timeout
end subroutine

! gboolean g_socket_is_connected (GSocket *socket);
function g_socket_is_connected(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_is_connected
  type(c_ptr), value :: socket
end function

! gboolean g_socket_bind (GSocket *socket, GSocketAddress *address, gboolean allow_reuse, GError **error);
function g_socket_bind(socket, address, allow_reuse, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_bind
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  integer(c_int), value :: allow_reuse
  type(c_ptr), value :: error
end function

! gboolean g_socket_connect (GSocket *socket, GSocketAddress *address, GCancellable *cancellable, GError **error);
function g_socket_connect(socket, address, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_connect
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_check_connect_result (GSocket *socket, GError **error);
function g_socket_check_connect_result(socket, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_check_connect_result
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! GIOCondition g_socket_condition_check (GSocket *socket, GIOCondition condition);
function g_socket_condition_check(socket, condition) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_condition_check
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
end function

! gboolean g_socket_condition_wait (GSocket *socket, GIOCondition condition, GCancellable *cancellable, GError **error);
function g_socket_condition_wait(socket, condition, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_condition_wait
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GSocket * g_socket_accept (GSocket *socket, GCancellable *cancellable, GError **error);
function g_socket_accept(socket, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_accept
  type(c_ptr), value :: socket
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_listen (GSocket *socket, GError **error);
function g_socket_listen(socket, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_listen
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! gssize g_socket_receive (GSocket *socket, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive(socket, buffer, size, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_receive_from (GSocket *socket, GSocketAddress **address, gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_receive_from(socket, address, buffer, size, cancellable, erro&
&r) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_receive_from
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send (GSocket *socket, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send(socket, buffer, size, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_to (GSocket *socket, GSocketAddress *address, const gchar *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_socket_send_to(socket, address, buffer, size, cancellable, error) bi&
&nd(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_socket_send_to
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_receive_message (GSocket *socket, GSocketAddress **address, GInputVector *vectors, gint num_vectors, GSocketControlMessage ***messages, gint *num_messages, gint *flags, GCancellable *cancellable, GError **error);
function g_socket_receive_message(socket, address, vectors, num_vectors, messag&
&es, num_messages, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_receive_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  type(c_ptr), value :: num_messages
  type(c_ptr), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_message (GSocket *socket, GSocketAddress *address, GOutputVector *vectors, gint num_vectors, GSocketControlMessage **messages, gint num_messages, gint flags, GCancellable *cancellable, GError **error);
function g_socket_send_message(socket, address, vectors, num_vectors, messages,&
& num_messages, flags, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_int
  integer(c_size_t) :: g_socket_send_message
  type(c_ptr), value :: socket
  type(c_ptr), value :: address
  type(c_ptr), value :: vectors
  integer(c_int), value :: num_vectors
  type(c_ptr), value :: messages
  integer(c_int), value :: num_messages
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_socket_close (GSocket *socket, GError **error);
function g_socket_close(socket, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_close
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

! gboolean g_socket_shutdown (GSocket *socket, gboolean shutdown_read, gboolean shutdown_write, GError **error);
function g_socket_shutdown(socket, shutdown_read, shutdown_write, error) bind(c&
&) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_shutdown
  type(c_ptr), value :: socket
  integer(c_int), value :: shutdown_read
  integer(c_int), value :: shutdown_write
  type(c_ptr), value :: error
end function

! gboolean g_socket_is_closed (GSocket *socket);
function g_socket_is_closed(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_is_closed
  type(c_ptr), value :: socket
end function

! GSource * g_socket_create_source (GSocket *socket, GIOCondition condition, GCancellable *cancellable);
function g_socket_create_source(socket, condition, cancellable) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_socket_create_source
  type(c_ptr), value :: socket
  integer(c_int), value :: condition
  type(c_ptr), value :: cancellable
end function

! gboolean g_socket_speaks_ipv4 (GSocket *socket);
function g_socket_speaks_ipv4(socket) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_socket_speaks_ipv4
  type(c_ptr), value :: socket
end function

! GCredentials *g_socket_get_credentials (GSocket *socket, GError **error);
function g_socket_get_credentials(socket, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_get_credentials
  type(c_ptr), value :: socket
  type(c_ptr), value :: error
end function

!  gssize g_socket_receive_with_blocking (GSocket *socket, gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_receive_with_blocking(socket, buffer, size, blocking, cancell&
&able, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_socket_receive_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_socket_send_with_blocking (GSocket *socket, const gchar *buffer, gsize size, gboolean blocking, GCancellable *cancellable, GError **error);
function g_socket_send_with_blocking(socket, buffer, size, blocking, cancellabl&
&e, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_socket_send_with_blocking
  type(c_ptr), value :: socket
  character(kind=c_char), dimension(*) :: buffer
  integer(c_size_t), value :: size
  integer(c_int), value :: blocking
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_credentials_get_type (void) G_GNUC_CONST;
function g_credentials_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_credentials_get_type
end function

!  GCredentials *g_credentials_new (void);
function g_credentials_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_credentials_new
end function

!  gchar *g_credentials_to_string (GCredentials *credentials);
function g_credentials_to_string(credentials) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_credentials_to_string
  type(c_ptr), value :: credentials
end function

!  gpointer g_credentials_get_native (GCredentials *credentials, GCredentialsType native_type);
function g_credentials_get_native(credentials, native_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_credentials_get_native
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
end function

!  void g_credentials_set_native (GCredentials *credentials, GCredentialsType native_type, gpointer native);
subroutine g_credentials_set_native(credentials, native_type, native) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: credentials
  integer(c_int), value :: native_type
  type(c_ptr), value :: native
end subroutine

!  gboolean g_credentials_is_same_user (GCredentials *credentials, GCredentials *other_credentials, GError **error);
function g_credentials_is_same_user(credentials, other_credentials, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_credentials_is_same_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: other_credentials
  type(c_ptr), value :: error
end function

!  uid_t g_credentials_get_unix_user (GCredentials *credentials, GError **error);
function g_credentials_get_unix_user(credentials, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_credentials_get_unix_user
  type(c_ptr), value :: credentials
  type(c_ptr), value :: error
end function

! gboolean g_credentials_set_unix_user (GCredentials *credentials, uid_t uid, GError **error);
function g_credentials_set_unix_user(credentials, uid, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_credentials_set_unix_user
  type(c_ptr), value :: credentials
  integer(c_int32_t), value :: uid
  type(c_ptr), value :: error
end function

!   GType g_volume_get_type (void) G_GNUC_CONST;
function g_volume_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_volume_get_type
end function

!  char * g_volume_get_name (GVolume *volume);
function g_volume_get_name(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_name
  type(c_ptr), value :: volume
end function

! GIcon * g_volume_get_icon (GVolume *volume);
function g_volume_get_icon(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_icon
  type(c_ptr), value :: volume
end function

! char * g_volume_get_uuid (GVolume *volume);
function g_volume_get_uuid(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_uuid
  type(c_ptr), value :: volume
end function

! GDrive * g_volume_get_drive (GVolume *volume);
function g_volume_get_drive(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_drive
  type(c_ptr), value :: volume
end function

! GMount * g_volume_get_mount (GVolume *volume);
function g_volume_get_mount(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_mount
  type(c_ptr), value :: volume
end function

! gboolean g_volume_can_mount (GVolume *volume);
function g_volume_can_mount(volume) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_can_mount
  type(c_ptr), value :: volume
end function

! gboolean g_volume_can_eject (GVolume *volume);
function g_volume_can_eject(volume) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_can_eject
  type(c_ptr), value :: volume
end function

! gboolean g_volume_should_automount (GVolume *volume);
function g_volume_should_automount(volume) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_should_automount
  type(c_ptr), value :: volume
end function

! void g_volume_mount (GVolume *volume, GMountMountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_mount(volume, flags, mount_operation, cancellable, callback&
&, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_mount_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_mount_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_mount_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  void g_volume_eject (GVolume *volume, GMountUnmountFlags flags, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject(volume, flags, cancellable, callback, user_data) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_eject_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_eject_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  char * g_volume_get_identifier (GVolume *volume, const char *kind);
function g_volume_get_identifier(volume, kind) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_get_identifier
  type(c_ptr), value :: volume
  character(kind=c_char), dimension(*) :: kind
end function

! char ** g_volume_enumerate_identifiers (GVolume *volume);
function g_volume_enumerate_identifiers(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_enumerate_identifiers
  type(c_ptr), value :: volume
end function

!  GFile * g_volume_get_activation_root (GVolume *volume);
function g_volume_get_activation_root(volume) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_get_activation_root
  type(c_ptr), value :: volume
end function

!  void g_volume_eject_with_operation (GVolume *volume, GMountUnmountFlags flags, GMountOperation *mount_operation, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_volume_eject_with_operation(volume, flags, mount_operation, cancel&
&lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: volume
  integer(c_int), value :: flags
  type(c_ptr), value :: mount_operation
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_volume_eject_with_operation_finish (GVolume *volume, GAsyncResult *result, GError **error);
function g_volume_eject_with_operation_finish(volume, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_volume_eject_with_operation_finish
  type(c_ptr), value :: volume
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_async_result_get_type (void) G_GNUC_CONST;
function g_async_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_async_result_get_type
end function

!  gpointer g_async_result_get_user_data (GAsyncResult *res);
function g_async_result_get_user_data(res) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_result_get_user_data
  type(c_ptr), value :: res
end function

! GObject *g_async_result_get_source_object (GAsyncResult *res);
function g_async_result_get_source_object(res) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_result_get_source_object
  type(c_ptr), value :: res
end function

!   GType g_loadable_icon_get_type (void) G_GNUC_CONST;
function g_loadable_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_loadable_icon_get_type
end function

!  GInputStream *g_loadable_icon_load (GLoadableIcon *icon, int size, char **type, GCancellable *cancellable, GError **error);
function g_loadable_icon_load(icon, size, type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_loadable_icon_load
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  type(c_ptr), dimension(*) :: type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_loadable_icon_load_async (GLoadableIcon *icon, int size, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_loadable_icon_load_async(icon, size, cancellable, callback, user_d&
&ata) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: icon
  integer(c_int), value :: size
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GInputStream *g_loadable_icon_load_finish (GLoadableIcon *icon, GAsyncResult *res, char **type, GError **error);
function g_loadable_icon_load_finish(icon, res, type, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_loadable_icon_load_finish
  type(c_ptr), value :: icon
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: type
  type(c_ptr), value :: error
end function

!   GType g_tls_server_connection_get_type (void) G_GNUC_CONST;
function g_tls_server_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_server_connection_get_type
end function

!  GIOStream * g_tls_server_connection_new (GIOStream *base_io_stream, GTlsCertificate *certificate, GError **error);
function g_tls_server_connection_new(base_io_stream, certificate, error) bind(c&
&) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_server_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: certificate
  type(c_ptr), value :: error
end function

!   GType g_socket_connection_get_type (void) G_GNUC_CONST;
function g_socket_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_connection_get_type
end function

!  GSocket *g_socket_connection_get_socket (GSocketConnection *connection);
function g_socket_connection_get_socket(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_socket
  type(c_ptr), value :: connection
end function

! GSocketAddress *g_socket_connection_get_local_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_local_address(connection, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_local_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! GSocketAddress *g_socket_connection_get_remote_address (GSocketConnection *connection, GError **error);
function g_socket_connection_get_remote_address(connection, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_get_remote_address
  type(c_ptr), value :: connection
  type(c_ptr), value :: error
end function

! void g_socket_connection_factory_register_type (GType g_type, GSocketFamily family, GSocketType type, gint protocol);
subroutine g_socket_connection_factory_register_type(g_type, family, type, prot&
&ocol) bind(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t), value :: g_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol
end subroutine

! GType g_socket_connection_factory_lookup_type (GSocketFamily family, GSocketType type, gint protocol_id);
function g_socket_connection_factory_lookup_type(family, type, protocol_id) bin&
&d(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t) :: g_socket_connection_factory_lookup_type
  integer(c_int), value :: family
  integer(c_int), value :: type
  integer(c_int), value :: protocol_id
end function

! GSocketConnection *g_socket_connection_factory_create_connection (GSocket *socket);
function g_socket_connection_factory_create_connection(socket) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_socket_connection_factory_create_connection
  type(c_ptr), value :: socket
end function

!   GType g_filename_completer_get_type (void) G_GNUC_CONST;
function g_filename_completer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filename_completer_get_type
end function

!  GFilenameCompleter *g_filename_completer_new (void);
function g_filename_completer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filename_completer_new
end function

!  char * g_filename_completer_get_completion_suffix (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completion_suffix(completer, initial_text) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completion_suffix
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! char ** g_filename_completer_get_completions (GFilenameCompleter *completer, const char *initial_text);
function g_filename_completer_get_completions(completer, initial_text) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_completer_get_completions
  type(c_ptr), value :: completer
  character(kind=c_char), dimension(*) :: initial_text
end function

! void g_filename_completer_set_dirs_only (GFilenameCompleter *completer, gboolean dirs_only);
subroutine g_filename_completer_set_dirs_only(completer, dirs_only) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: completer
  integer(c_int), value :: dirs_only
end subroutine

!   GType g_file_io_stream_get_type (void) G_GNUC_CONST;
function g_file_io_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_io_stream_get_type
end function

!  GFileInfo *g_file_io_stream_query_info (GFileIOStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_io_stream_query_info(stream, attributes, cancellable, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_io_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_io_stream_query_info_async (GFileIOStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_io_stream_query_info_async(stream, attributes, io_priority, c&
&ancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_io_stream_query_info_finish (GFileIOStream *stream, GAsyncResult *result, GError **error);
function g_file_io_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_io_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! char * g_file_io_stream_get_etag (GFileIOStream *stream);
function g_file_io_stream_get_etag(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_io_stream_get_etag
  type(c_ptr), value :: stream
end function

!   GType g_converter_input_stream_get_type (void) G_GNUC_CONST;
function g_converter_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_input_stream_get_type
end function

! GInputStream *g_converter_input_stream_new (GInputStream *base_stream, GConverter *converter);
function g_converter_input_stream_new(base_stream, converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_input_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GConverter *g_converter_input_stream_get_converter (GConverterInputStream *converter_stream);
function g_converter_input_stream_get_converter(converter_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_input_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!   GType g_network_service_get_type (void) G_GNUC_CONST;
function g_network_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_network_service_get_type
end function

!  GSocketConnectable *g_network_service_new (const gchar *service, const gchar *protocol, const gchar *domain);
function g_network_service_new(service, protocol, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_network_service_new
  character(kind=c_char), dimension(*) :: service
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: domain
end function

!  const gchar *g_network_service_get_service (GNetworkService *srv);
function g_network_service_get_service(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_service
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_protocol (GNetworkService *srv);
function g_network_service_get_protocol(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_protocol
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_domain (GNetworkService *srv);
function g_network_service_get_domain(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_domain
  type(c_ptr), value :: srv
end function

! const gchar *g_network_service_get_scheme (GNetworkService *srv);
function g_network_service_get_scheme(srv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_network_service_get_scheme
  type(c_ptr), value :: srv
end function

! void g_network_service_set_scheme (GNetworkService *srv, const gchar *scheme);
subroutine g_network_service_set_scheme(srv, scheme) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: srv
  character(kind=c_char), dimension(*) :: scheme
end subroutine

!   GType g_app_info_create_flags_get_type (void) G_GNUC_CONST;
function g_app_info_create_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_info_create_flags_get_type
end function

!  GType g_converter_flags_get_type (void) G_GNUC_CONST;
function g_converter_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_flags_get_type
end function

!  GType g_converter_result_get_type (void) G_GNUC_CONST;
function g_converter_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_result_get_type
end function

!  GType g_data_stream_byte_order_get_type (void) G_GNUC_CONST;
function g_data_stream_byte_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_stream_byte_order_get_type
end function

!  GType g_data_stream_newline_type_get_type (void) G_GNUC_CONST;
function g_data_stream_newline_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_stream_newline_type_get_type
end function

!  GType g_file_attribute_type_get_type (void) G_GNUC_CONST;
function g_file_attribute_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_type_get_type
end function

!  GType g_file_attribute_info_flags_get_type (void) G_GNUC_CONST;
function g_file_attribute_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_info_flags_get_type
end function

!  GType g_file_attribute_status_get_type (void) G_GNUC_CONST;
function g_file_attribute_status_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_status_get_type
end function

!  GType g_file_query_info_flags_get_type (void) G_GNUC_CONST;
function g_file_query_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_query_info_flags_get_type
end function

!  GType g_file_create_flags_get_type (void) G_GNUC_CONST;
function g_file_create_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_create_flags_get_type
end function

!  GType g_mount_mount_flags_get_type (void) G_GNUC_CONST;
function g_mount_mount_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_mount_flags_get_type
end function

!  GType g_mount_unmount_flags_get_type (void) G_GNUC_CONST;
function g_mount_unmount_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_unmount_flags_get_type
end function

!  GType g_drive_start_flags_get_type (void) G_GNUC_CONST;
function g_drive_start_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_start_flags_get_type
end function

!  GType g_drive_start_stop_type_get_type (void) G_GNUC_CONST;
function g_drive_start_stop_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_drive_start_stop_type_get_type
end function

!  GType g_file_copy_flags_get_type (void) G_GNUC_CONST;
function g_file_copy_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_copy_flags_get_type
end function

!  GType g_file_monitor_flags_get_type (void) G_GNUC_CONST;
function g_file_monitor_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_flags_get_type
end function

!  GType g_file_type_get_type (void) G_GNUC_CONST;
function g_file_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_type_get_type
end function

!  GType g_filesystem_preview_type_get_type (void) G_GNUC_CONST;
function g_filesystem_preview_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filesystem_preview_type_get_type
end function

!  GType g_file_monitor_event_get_type (void) G_GNUC_CONST;
function g_file_monitor_event_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_monitor_event_get_type
end function

!  GType g_io_error_enum_get_type (void) G_GNUC_CONST;
function g_io_error_enum_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_error_enum_get_type
end function

!  GType g_ask_password_flags_get_type (void) G_GNUC_CONST;
function g_ask_password_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_ask_password_flags_get_type
end function

!  GType g_password_save_get_type (void) G_GNUC_CONST;
function g_password_save_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_password_save_get_type
end function

!  GType g_mount_operation_result_get_type (void) G_GNUC_CONST;
function g_mount_operation_result_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_mount_operation_result_get_type
end function

!  GType g_output_stream_splice_flags_get_type (void) G_GNUC_CONST;
function g_output_stream_splice_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_output_stream_splice_flags_get_type
end function

!  GType g_io_stream_splice_flags_get_type (void) G_GNUC_CONST;
function g_io_stream_splice_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_stream_splice_flags_get_type
end function

!  GType g_emblem_origin_get_type (void) G_GNUC_CONST;
function g_emblem_origin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblem_origin_get_type
end function

!  GType g_resolver_error_get_type (void) G_GNUC_CONST;
function g_resolver_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_resolver_error_get_type
end function

!  GType g_socket_family_get_type (void) G_GNUC_CONST;
function g_socket_family_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_family_get_type
end function

!  GType g_socket_type_get_type (void) G_GNUC_CONST;
function g_socket_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_type_get_type
end function

!  GType g_socket_msg_flags_get_type (void) G_GNUC_CONST;
function g_socket_msg_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_msg_flags_get_type
end function

!  GType g_socket_protocol_get_type (void) G_GNUC_CONST;
function g_socket_protocol_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_socket_protocol_get_type
end function

!  GType g_zlib_compressor_format_get_type (void) G_GNUC_CONST;
function g_zlib_compressor_format_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_compressor_format_get_type
end function

!  GType g_unix_socket_address_type_get_type (void) G_GNUC_CONST;
function g_unix_socket_address_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_unix_socket_address_type_get_type
end function

!  GType g_bus_type_get_type (void) G_GNUC_CONST;
function g_bus_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_type_get_type
end function

!  GType g_bus_name_owner_flags_get_type (void) G_GNUC_CONST;
function g_bus_name_owner_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_name_owner_flags_get_type
end function

!  GType g_bus_name_watcher_flags_get_type (void) G_GNUC_CONST;
function g_bus_name_watcher_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_bus_name_watcher_flags_get_type
end function

!  GType g_dbus_proxy_flags_get_type (void) G_GNUC_CONST;
function g_dbus_proxy_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_proxy_flags_get_type
end function

!  GType g_dbus_error_get_type (void) G_GNUC_CONST;
function g_dbus_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_error_get_type
end function

!  GType g_dbus_connection_flags_get_type (void) G_GNUC_CONST;
function g_dbus_connection_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_connection_flags_get_type
end function

!  GType g_dbus_capability_flags_get_type (void) G_GNUC_CONST;
function g_dbus_capability_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_capability_flags_get_type
end function

!  GType g_dbus_call_flags_get_type (void) G_GNUC_CONST;
function g_dbus_call_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_call_flags_get_type
end function

!  GType g_dbus_message_type_get_type (void) G_GNUC_CONST;
function g_dbus_message_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_type_get_type
end function

!  GType g_dbus_message_flags_get_type (void) G_GNUC_CONST;
function g_dbus_message_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_flags_get_type
end function

!  GType g_dbus_message_header_field_get_type (void) G_GNUC_CONST;
function g_dbus_message_header_field_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_header_field_get_type
end function

!  GType g_dbus_property_info_flags_get_type (void) G_GNUC_CONST;
function g_dbus_property_info_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_property_info_flags_get_type
end function

!  GType g_dbus_subtree_flags_get_type (void) G_GNUC_CONST;
function g_dbus_subtree_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_subtree_flags_get_type
end function

!  GType g_dbus_server_flags_get_type (void) G_GNUC_CONST;
function g_dbus_server_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_server_flags_get_type
end function

!  GType g_dbus_signal_flags_get_type (void) G_GNUC_CONST;
function g_dbus_signal_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_signal_flags_get_type
end function

!  GType g_dbus_send_message_flags_get_type (void) G_GNUC_CONST;
function g_dbus_send_message_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_send_message_flags_get_type
end function

!  GType g_credentials_type_get_type (void) G_GNUC_CONST;
function g_credentials_type_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_credentials_type_get_type
end function

!  GType g_dbus_message_byte_order_get_type (void) G_GNUC_CONST;
function g_dbus_message_byte_order_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_byte_order_get_type
end function

!  GType g_application_flags_get_type (void) G_GNUC_CONST;
function g_application_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_application_flags_get_type
end function

!  GType g_tls_error_get_type (void) G_GNUC_CONST;
function g_tls_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_error_get_type
end function

!  GType g_tls_certificate_flags_get_type (void) G_GNUC_CONST;
function g_tls_certificate_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_certificate_flags_get_type
end function

!  GType g_tls_authentication_mode_get_type (void) G_GNUC_CONST;
function g_tls_authentication_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_authentication_mode_get_type
end function

!  GType g_tls_rehandshake_mode_get_type (void) G_GNUC_CONST;
function g_tls_rehandshake_mode_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_rehandshake_mode_get_type
end function

!  GType g_settings_bind_flags_get_type (void) G_GNUC_CONST;
function g_settings_bind_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_bind_flags_get_type
end function

!   GType g_initable_get_type (void) G_GNUC_CONST;
function g_initable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_initable_get_type
end function

!  gboolean g_initable_init (GInitable *initable, GCancellable *cancellable, GError **error);
function g_initable_init(initable, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_initable_init
  type(c_ptr), value :: initable
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gpointer g_initable_newv (GType object_type, guint n_parameters, GParameter *parameters, GCancellable *cancellable, GError **error);
function g_initable_newv(object_type, n_parameters, parameters, cancellable, er&
&ror) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_initable_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GObject* g_initable_new_valist (GType object_type, const gchar *first_property_name, va_list var_args, GCancellable *cancellable, GError **error);
function g_initable_new_valist(object_type, first_property_name, var_args, canc&
&ellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_initable_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_input_stream_get_type (void) G_GNUC_CONST;
function g_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_input_stream_get_type
end function

!  gssize g_input_stream_read (GInputStream *stream, void *buffer, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_read(stream, buffer, count, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_input_stream_read_all (GInputStream *stream, void *buffer, gsize count, gsize *bytes_read, GCancellable *cancellable, GError **error);
function g_input_stream_read_all(stream, buffer, count, bytes_read, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_input_stream_read_all
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gssize g_input_stream_skip (GInputStream *stream, gsize count, GCancellable *cancellable, GError **error);
function g_input_stream_skip(stream, count, cancellable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_input_stream_close (GInputStream *stream, GCancellable *cancellable, GError **error);
function g_input_stream_close(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_input_stream_close
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_input_stream_read_async (GInputStream *stream, void *buffer, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_read_async(stream, buffer, count, io_priority, cancel&
&lable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_input_stream_read_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_read_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_read_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_input_stream_skip_async (GInputStream *stream, gsize count, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_skip_async(stream, count, io_priority, cancellable, c&
&allback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_size_t), value :: count
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gssize g_input_stream_skip_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_skip_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_input_stream_skip_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_input_stream_close_async (GInputStream *stream, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_input_stream_close_async(stream, io_priority, cancellable, callbac&
&k, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_input_stream_close_finish (GInputStream *stream, GAsyncResult *result, GError **error);
function g_input_stream_close_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_input_stream_close_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_input_stream_is_closed (GInputStream *stream);
function g_input_stream_is_closed(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_input_stream_is_closed
  type(c_ptr), value :: stream
end function

! gboolean g_input_stream_has_pending (GInputStream *stream);
function g_input_stream_has_pending(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_input_stream_has_pending
  type(c_ptr), value :: stream
end function

! gboolean g_input_stream_set_pending (GInputStream *stream, GError **error);
function g_input_stream_set_pending(stream, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_input_stream_set_pending
  type(c_ptr), value :: stream
  type(c_ptr), value :: error
end function

! void g_input_stream_clear_pending (GInputStream *stream);
subroutine g_input_stream_clear_pending(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: stream
end subroutine

!   GType g_file_info_get_type (void) G_GNUC_CONST;
function g_file_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_info_get_type
end function

!  GFileInfo * g_file_info_new (void);
function g_file_info_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_new
end function

! GFileInfo * g_file_info_dup (GFileInfo *other);
function g_file_info_dup(other) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_dup
  type(c_ptr), value :: other
end function

! void g_file_info_copy_into (GFileInfo *src_info, GFileInfo *dest_info);
subroutine g_file_info_copy_into(src_info, dest_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src_info
  type(c_ptr), value :: dest_info
end subroutine

! gboolean g_file_info_has_attribute (GFileInfo *info, const char *attribute);
function g_file_info_has_attribute(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_has_attribute
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_has_namespace (GFileInfo *info, const char *name_space);
function g_file_info_has_namespace(info, name_space) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_has_namespace
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! char ** g_file_info_list_attributes (GFileInfo *info, const char *name_space);
function g_file_info_list_attributes(info, name_space) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_list_attributes
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name_space
end function

! gboolean g_file_info_get_attribute_data (GFileInfo *info, const char *attribute, GFileAttributeType *type, gpointer *value_pp, GFileAttributeStatus *status);
function g_file_info_get_attribute_data(info, attribute, type, value_pp, status&
&) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_data
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_pp
  integer(c_int), value :: status
end function

! GFileAttributeType g_file_info_get_attribute_type (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_type(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_type
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! void g_file_info_remove_attribute (GFileInfo *info, const char *attribute);
subroutine g_file_info_remove_attribute(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end subroutine

! GFileAttributeStatus g_file_info_get_attribute_status (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_status(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_set_attribute_status (GFileInfo *info, const char *attribute, GFileAttributeStatus status);
function g_file_info_set_attribute_status(info, attribute, status) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_set_attribute_status
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: status
end function

! char * g_file_info_get_attribute_as_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_as_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_as_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! const char * g_file_info_get_attribute_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! const char * g_file_info_get_attribute_byte_string (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_byte_string(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_byte_string
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_info_get_attribute_boolean (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_boolean(info, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_info_get_attribute_boolean
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! guint32 g_file_info_get_attribute_uint32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint32(info, attribute) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_uint32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gint32 g_file_info_get_attribute_int32 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int32(info, attribute) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_char
  integer(c_int32_t) :: g_file_info_get_attribute_int32
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! guint64 g_file_info_get_attribute_uint64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_uint64(info, attribute) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_uint64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! gint64 g_file_info_get_attribute_int64 (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_int64(info, attribute) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_file_info_get_attribute_int64
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! GObject * g_file_info_get_attribute_object (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_object(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_object
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

! char ** g_file_info_get_attribute_stringv (GFileInfo *info, const char *attribute);
function g_file_info_get_attribute_stringv(info, attribute) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_info_get_attribute_stringv
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
end function

!  void g_file_info_set_attribute (GFileInfo *info, const char *attribute, GFileAttributeType type, gpointer value_p);
subroutine g_file_info_set_attribute(info, attribute, type, value_p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: type
  type(c_ptr), value :: value_p
end subroutine

! void g_file_info_set_attribute_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_string(info, attribute, attr_value) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! void g_file_info_set_attribute_byte_string (GFileInfo *info, const char *attribute, const char *attr_value);
subroutine g_file_info_set_attribute_byte_string(info, attribute, attr_value) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  character(kind=c_char), dimension(*) :: attr_value
end subroutine

! void g_file_info_set_attribute_boolean (GFileInfo *info, const char *attribute, gboolean attr_value);
subroutine g_file_info_set_attribute_boolean(info, attribute, attr_value) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int), value :: attr_value
end subroutine

! void g_file_info_set_attribute_uint32 (GFileInfo *info, const char *attribute, guint32 attr_value);
subroutine g_file_info_set_attribute_uint32(info, attribute, attr_value) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_int32 (GFileInfo *info, const char *attribute, gint32 attr_value);
subroutine g_file_info_set_attribute_int32(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int32_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_uint64 (GFileInfo *info, const char *attribute, guint64 attr_value);
subroutine g_file_info_set_attribute_uint64(info, attribute, attr_value) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_int64 (GFileInfo *info, const char *attribute, gint64 attr_value);
subroutine g_file_info_set_attribute_int64(info, attribute, attr_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  integer(c_int64_t), value :: attr_value
end subroutine

! void g_file_info_set_attribute_object (GFileInfo *info, const char *attribute, GObject *attr_value);
subroutine g_file_info_set_attribute_object(info, attribute, attr_value) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), value :: attr_value
end subroutine

! void g_file_info_set_attribute_stringv (GFileInfo *info, const char *attribute, char **attr_value);
subroutine g_file_info_set_attribute_stringv(info, attribute, attr_value) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: attribute
  type(c_ptr), dimension(*) :: attr_value
end subroutine

!  void g_file_info_clear_status (GFileInfo *info);
subroutine g_file_info_clear_status(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  GFileType g_file_info_get_file_type (GFileInfo *info);
function g_file_info_get_file_type(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_info_get_file_type
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_hidden (GFileInfo *info);
function g_file_info_get_is_hidden(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_hidden
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_backup (GFileInfo *info);
function g_file_info_get_is_backup(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_backup
  type(c_ptr), value :: info
end function

! gboolean g_file_info_get_is_symlink (GFileInfo *info);
function g_file_info_get_is_symlink(info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_info_get_is_symlink
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_name (GFileInfo *info);
function g_file_info_get_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_name
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_display_name (GFileInfo *info);
function g_file_info_get_display_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_display_name
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_edit_name (GFileInfo *info);
function g_file_info_get_edit_name(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_edit_name
  type(c_ptr), value :: info
end function

! GIcon * g_file_info_get_icon (GFileInfo *info);
function g_file_info_get_icon(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_icon
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_content_type (GFileInfo *info);
function g_file_info_get_content_type(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_content_type
  type(c_ptr), value :: info
end function

! goffset g_file_info_get_size (GFileInfo *info);
function g_file_info_get_size(info) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_file_info_get_size
  type(c_ptr), value :: info
end function

! void g_file_info_get_modification_time (GFileInfo *info, GTimeVal *result);
subroutine g_file_info_get_modification_time(info, result) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: result
end subroutine

! const char * g_file_info_get_symlink_target (GFileInfo *info);
function g_file_info_get_symlink_target(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_symlink_target
  type(c_ptr), value :: info
end function

! const char * g_file_info_get_etag (GFileInfo *info);
function g_file_info_get_etag(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_info_get_etag
  type(c_ptr), value :: info
end function

! gint32 g_file_info_get_sort_order (GFileInfo *info);
function g_file_info_get_sort_order(info) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_file_info_get_sort_order
  type(c_ptr), value :: info
end function

!  void g_file_info_set_attribute_mask (GFileInfo *info, GFileAttributeMatcher *mask);
subroutine g_file_info_set_attribute_mask(info, mask) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mask
end subroutine

! void g_file_info_unset_attribute_mask (GFileInfo *info);
subroutine g_file_info_unset_attribute_mask(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  void g_file_info_set_file_type (GFileInfo *info, GFileType type);
subroutine g_file_info_set_file_type(info, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: type
end subroutine

! void g_file_info_set_is_hidden (GFileInfo *info, gboolean is_hidden);
subroutine g_file_info_set_is_hidden(info, is_hidden) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: is_hidden
end subroutine

! void g_file_info_set_is_symlink (GFileInfo *info, gboolean is_symlink);
subroutine g_file_info_set_is_symlink(info, is_symlink) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: is_symlink
end subroutine

! void g_file_info_set_name (GFileInfo *info, const char *name);
subroutine g_file_info_set_name(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end subroutine

! void g_file_info_set_display_name (GFileInfo *info, const char *display_name);
subroutine g_file_info_set_display_name(info, display_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: display_name
end subroutine

! void g_file_info_set_edit_name (GFileInfo *info, const char *edit_name);
subroutine g_file_info_set_edit_name(info, edit_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: edit_name
end subroutine

! void g_file_info_set_icon (GFileInfo *info, GIcon *icon);
subroutine g_file_info_set_icon(info, icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: icon
end subroutine

! void g_file_info_set_content_type (GFileInfo *info, const char *content_type);
subroutine g_file_info_set_content_type(info, content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! void g_file_info_set_size (GFileInfo *info, goffset size);
subroutine g_file_info_set_size(info, size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: info
  integer(c_int64_t), value :: size
end subroutine

! void g_file_info_set_modification_time (GFileInfo *info, GTimeVal *mtime);
subroutine g_file_info_set_modification_time(info, mtime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
  type(c_ptr), value :: mtime
end subroutine

! void g_file_info_set_symlink_target (GFileInfo *info, const char *symlink_target);
subroutine g_file_info_set_symlink_target(info, symlink_target) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: symlink_target
end subroutine

! void g_file_info_set_sort_order (GFileInfo *info, gint32 sort_order);
subroutine g_file_info_set_sort_order(info, sort_order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: info
  integer(c_int32_t), value :: sort_order
end subroutine

!  GType g_file_attribute_matcher_get_type (void) G_GNUC_CONST;
function g_file_attribute_matcher_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_matcher_get_type
end function

! GFileAttributeMatcher *g_file_attribute_matcher_new (const char *attributes);
function g_file_attribute_matcher_new(attributes) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_matcher_new
  character(kind=c_char), dimension(*) :: attributes
end function

! GFileAttributeMatcher *g_file_attribute_matcher_ref (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_ref(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_ref
  type(c_ptr), value :: matcher
end function

! void g_file_attribute_matcher_unref (GFileAttributeMatcher *matcher);
subroutine g_file_attribute_matcher_unref(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: matcher
end subroutine

! gboolean g_file_attribute_matcher_matches (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches(matcher, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_matches
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_attribute_matcher_matches_only (GFileAttributeMatcher *matcher, const char *attribute);
function g_file_attribute_matcher_matches_only(matcher, attribute) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_matches_only
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: attribute
end function

! gboolean g_file_attribute_matcher_enumerate_namespace (GFileAttributeMatcher *matcher, const char *ns);
function g_file_attribute_matcher_enumerate_namespace(matcher, ns) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_file_attribute_matcher_enumerate_namespace
  type(c_ptr), value :: matcher
  character(kind=c_char), dimension(*) :: ns
end function

! const char * g_file_attribute_matcher_enumerate_next (GFileAttributeMatcher *matcher);
function g_file_attribute_matcher_enumerate_next(matcher) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_matcher_enumerate_next
  type(c_ptr), value :: matcher
end function

!   GType g_pollable_output_stream_get_type (void) G_GNUC_CONST;
function g_pollable_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_pollable_output_stream_get_type
end function

!  gboolean g_pollable_output_stream_can_poll (GPollableOutputStream *stream);
function g_pollable_output_stream_can_poll(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_pollable_output_stream_can_poll
  type(c_ptr), value :: stream
end function

!  gboolean g_pollable_output_stream_is_writable (GPollableOutputStream *stream);
function g_pollable_output_stream_is_writable(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_pollable_output_stream_is_writable
  type(c_ptr), value :: stream
end function

! GSource *g_pollable_output_stream_create_source (GPollableOutputStream *stream, GCancellable *cancellable);
function g_pollable_output_stream_create_source(stream, cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_pollable_output_stream_create_source
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
end function

!  gssize g_pollable_output_stream_write_nonblocking (GPollableOutputStream *stream, const void *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_pollable_output_stream_write_nonblocking(stream, buffer, size, cance&
&llable, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_pollable_output_stream_write_nonblocking
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_dbus_connection_get_type (void) G_GNUC_CONST;
function g_dbus_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_connection_get_type
end function

!  void g_bus_get (GBusType bus_type, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_bus_get(bus_type, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_bus_get_finish (GAsyncResult *res, GError **error);
function g_bus_get_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bus_get_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_bus_get_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_bus_get_sync(bus_type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_bus_get_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_new (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new(stream, guid, flags, observer, cancellable, ca&
&llback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_dbus_connection_new_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_connection_new_sync (GIOStream *stream, const gchar *guid, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable,&
& error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_sync
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: guid
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_new_for_address (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_new_for_address(address, flags, observer, cancella&
&ble, callback, user_data) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusConnection *g_dbus_connection_new_for_address_finish (GAsyncResult *res, GError **error);
function g_dbus_connection_new_for_address_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_new_for_address_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_connection_new_for_address_sync (const gchar *address, GDBusConnectionFlags flags, GDBusAuthObserver *observer, GCancellable *cancellable, GError **error);
function g_dbus_connection_new_for_address_sync(address, flags, observer, cance&
&llable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_new_for_address_sync
  character(kind=c_char), dimension(*) :: address
  integer(c_int), value :: flags
  type(c_ptr), value :: observer
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_start_message_processing (GDBusConnection *connection);
subroutine g_dbus_connection_start_message_processing(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: connection
end subroutine

! gboolean g_dbus_connection_is_closed (GDBusConnection *connection);
function g_dbus_connection_is_closed(connection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_is_closed
  type(c_ptr), value :: connection
end function

! GIOStream *g_dbus_connection_get_stream (GDBusConnection *connection);
function g_dbus_connection_get_stream(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_stream
  type(c_ptr), value :: connection
end function

! const gchar *g_dbus_connection_get_guid (GDBusConnection *connection);
function g_dbus_connection_get_guid(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_guid
  type(c_ptr), value :: connection
end function

! const gchar *g_dbus_connection_get_unique_name (GDBusConnection *connection);
function g_dbus_connection_get_unique_name(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_unique_name
  type(c_ptr), value :: connection
end function

! GCredentials *g_dbus_connection_get_peer_credentials (GDBusConnection *connection);
function g_dbus_connection_get_peer_credentials(connection) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_get_peer_credentials
  type(c_ptr), value :: connection
end function

! gboolean g_dbus_connection_get_exit_on_close (GDBusConnection *connection);
function g_dbus_connection_get_exit_on_close(connection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_exit_on_close
  type(c_ptr), value :: connection
end function

! void g_dbus_connection_set_exit_on_close (GDBusConnection *connection, gboolean exit_on_close);
subroutine g_dbus_connection_set_exit_on_close(connection, exit_on_close) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: exit_on_close
end subroutine

! GDBusCapabilityFlags g_dbus_connection_get_capabilities (GDBusConnection *connection);
function g_dbus_connection_get_capabilities(connection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_get_capabilities
  type(c_ptr), value :: connection
end function

!  void g_dbus_connection_close (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_close(connection, cancellable, callback, user_data&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_dbus_connection_close_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_close_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_close_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_close_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_close_sync(connection, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_close_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  void g_dbus_connection_flush (GDBusConnection *connection, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_flush(connection, cancellable, callback, user_data&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_dbus_connection_flush_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_flush_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_flush_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_flush_sync (GDBusConnection *connection, GCancellable *cancellable, GError **error);
function g_dbus_connection_flush_sync(connection, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_flush_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_connection_send_message (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, volatile guint32 *out_serial, GError **error);
function g_dbus_connection_send_message(connection, message, flags, out_serial,&
& error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_send_message
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: error
end function

! void g_dbus_connection_send_message_with_reply (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_send_message_with_reply(connection, message, flags&
&, timeout_msec, out_serial, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusMessage *g_dbus_connection_send_message_with_reply_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_send_message_with_reply_finish(connection, res, erro&
&r) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusMessage *g_dbus_connection_send_message_with_reply_sync (GDBusConnection *connection, GDBusMessage *message, GDBusSendMessageFlags flags, gint timeout_msec, volatile guint32 *out_serial, GCancellable *cancellable, GError **error);
function g_dbus_connection_send_message_with_reply_sync(connection, message, fl&
&ags, timeout_msec, out_serial, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_connection_send_message_with_reply_sync
  type(c_ptr), value :: connection
  type(c_ptr), value :: message
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: out_serial
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_connection_emit_signal (GDBusConnection *connection, const gchar *destination_bus_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, GError **error);
function g_dbus_connection_emit_signal(connection, destination_bus_name, object&
&_path, interface_name, signal_name, parameters, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_dbus_connection_emit_signal
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: destination_bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: signal_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: error
end function

! void g_dbus_connection_call (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_connection_call(connection, bus_name, object_path, interface_&
&name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, c&
&allback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GVariant *g_dbus_connection_call_finish (GDBusConnection *connection, GAsyncResult *res, GError **error);
function g_dbus_connection_call_finish(connection, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_connection_call_finish
  type(c_ptr), value :: connection
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GVariant *g_dbus_connection_call_sync (GDBusConnection *connection, const gchar *bus_name, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant *parameters, const GVariantType *reply_type, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_connection_call_sync(connection, bus_name, object_path, interfa&
&ce_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_connection_call_sync
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: bus_name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  type(c_ptr), value :: reply_type
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  guint g_dbus_connection_register_object (GDBusConnection *connection, const gchar *object_path, GDBusInterfaceInfo *interface_info, const GDBusInterfaceVTable *vtable, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_object(connection, object_path, interface_i&
&nfo, vtable, user_data, user_data_free_func, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_object
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: interface_info
  type(c_ptr), value :: vtable
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_unregister_object (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_object(connection, registration_id) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_unregister_object
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

!  guint g_dbus_connection_register_subtree (GDBusConnection *connection, const gchar *object_path, const GDBusSubtreeVTable *vtable, GDBusSubtreeFlags flags, gpointer user_data, GDestroyNotify user_data_free_func, GError **error);
function g_dbus_connection_register_subtree(connection, object_path, vtable, fl&
&ags, user_data, user_data_free_func, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_register_subtree
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: object_path
  type(c_ptr), value :: vtable
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
  type(c_ptr), value :: error
end function

! gboolean g_dbus_connection_unregister_subtree (GDBusConnection *connection, guint registration_id);
function g_dbus_connection_unregister_subtree(connection, registration_id) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_connection_unregister_subtree
  type(c_ptr), value :: connection
  integer(c_int), value :: registration_id
end function

!  guint g_dbus_connection_signal_subscribe (GDBusConnection *connection, const gchar *sender, const gchar *interface_name, const gchar *member, const gchar *object_path, const gchar *arg0, GDBusSignalFlags flags, GDBusSignalCallback callback, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_signal_subscribe(connection, sender, interface_name,&
& member, object_path, arg0, flags, callback, user_data, user_data_free_func) b&
&ind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int) :: g_dbus_connection_signal_subscribe
  type(c_ptr), value :: connection
  character(kind=c_char), dimension(*) :: sender
  character(kind=c_char), dimension(*) :: interface_name
  character(kind=c_char), dimension(*) :: member
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: arg0
  integer(c_int), value :: flags
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

! void g_dbus_connection_signal_unsubscribe (GDBusConnection *connection, guint subscription_id);
subroutine g_dbus_connection_signal_unsubscribe(connection, subscription_id) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: subscription_id
end subroutine

!  guint g_dbus_connection_add_filter (GDBusConnection *connection, GDBusMessageFilterFunction filter_function, gpointer user_data, GDestroyNotify user_data_free_func);
function g_dbus_connection_add_filter(connection, filter_function, user_data, u&
&ser_data_free_func) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_dbus_connection_add_filter
  type(c_ptr), value :: connection
  type(c_funptr), value :: filter_function
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_free_func
end function

!  void g_dbus_connection_remove_filter (GDBusConnection *connection, guint filter_id);
subroutine g_dbus_connection_remove_filter(connection, filter_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: filter_id
end subroutine

!   GType g_dbus_message_get_type (void) G_GNUC_CONST;
function g_dbus_message_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_message_get_type
end function

! GDBusMessage *g_dbus_message_new (void);
function g_dbus_message_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_new
end function

! GDBusMessage *g_dbus_message_new_signal (const gchar *path, const gchar *interface_, const gchar *signal);
function g_dbus_message_new_signal(path, interface_, signal) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_signal
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: signal
end function

! GDBusMessage *g_dbus_message_new_method_call (const gchar *name, const gchar *path, const gchar *interface_, const gchar *method);
function g_dbus_message_new_method_call(name, path, interface_, method) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_call
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: interface_
  character(kind=c_char), dimension(*) :: method
end function

! GDBusMessage *g_dbus_message_new_method_reply (GDBusMessage *method_call_message);
function g_dbus_message_new_method_reply(method_call_message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_new_method_reply
  type(c_ptr), value :: method_call_message
end function

! GDBusMessage *g_dbus_message_new_method_error_valist (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message_format, va_list var_args);
function g_dbus_message_new_method_error_valist(method_call_message, error_name&
&, error_message_format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_valist
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message_format
  type(c_ptr), value :: var_args
end function

! GDBusMessage *g_dbus_message_new_method_error_literal (GDBusMessage *method_call_message, const gchar *error_name, const gchar *error_message);
function g_dbus_message_new_method_error_literal(method_call_message, error_nam&
&e, error_message) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_message_new_method_error_literal
  type(c_ptr), value :: method_call_message
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end function

! gchar *g_dbus_message_print (GDBusMessage *message, guint indent);
function g_dbus_message_print(message, indent) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_print
  type(c_ptr), value :: message
  integer(c_int), value :: indent
end function

! gboolean g_dbus_message_get_locked (GDBusMessage *message);
function g_dbus_message_get_locked(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_locked
  type(c_ptr), value :: message
end function

! void g_dbus_message_lock (GDBusMessage *message);
subroutine g_dbus_message_lock(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
end subroutine

! GDBusMessage *g_dbus_message_copy (GDBusMessage *message, GError **error);
function g_dbus_message_copy(message, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_copy
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

! GDBusMessageByteOrder g_dbus_message_get_byte_order (GDBusMessage *message);
function g_dbus_message_get_byte_order(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_byte_order
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_byte_order (GDBusMessage *message, GDBusMessageByteOrder byte_order);
subroutine g_dbus_message_set_byte_order(message, byte_order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: byte_order
end subroutine

!  GDBusMessageType g_dbus_message_get_message_type (GDBusMessage *message);
function g_dbus_message_get_message_type(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_message_type
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_message_type (GDBusMessage *message, GDBusMessageType type);
subroutine g_dbus_message_set_message_type(message, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: type
end subroutine

! GDBusMessageFlags g_dbus_message_get_flags (GDBusMessage *message);
function g_dbus_message_get_flags(message) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_get_flags
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_flags (GDBusMessage *message, GDBusMessageFlags flags);
subroutine g_dbus_message_set_flags(message, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: flags
end subroutine

! guint32 g_dbus_message_get_serial (GDBusMessage *message);
function g_dbus_message_get_serial(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_serial
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_serial (GDBusMessage *message, guint32 serial);
subroutine g_dbus_message_set_serial(message, serial) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: serial
end subroutine

! GVariant *g_dbus_message_get_header (GDBusMessage *message, GDBusMessageHeaderField header_field);
function g_dbus_message_get_header(message, header_field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_get_header
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
end function

! void g_dbus_message_set_header (GDBusMessage *message, GDBusMessageHeaderField header_field, GVariant *value);
subroutine g_dbus_message_set_header(message, header_field, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: message
  integer(c_int), value :: header_field
  type(c_ptr), value :: value
end subroutine

! guchar *g_dbus_message_get_header_fields (GDBusMessage *message);
function g_dbus_message_get_header_fields(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_header_fields
  type(c_ptr), value :: message
end function

! GVariant *g_dbus_message_get_body (GDBusMessage *message);
function g_dbus_message_get_body(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_body
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_body (GDBusMessage *message, GVariant *body);
subroutine g_dbus_message_set_body(message, body) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: body
end subroutine

! GUnixFDList *g_dbus_message_get_unix_fd_list (GDBusMessage *message);
function g_dbus_message_get_unix_fd_list(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_unix_fd_list
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_unix_fd_list (GDBusMessage *message, GUnixFDList *fd_list);
subroutine g_dbus_message_set_unix_fd_list(message, fd_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: message
  type(c_ptr), value :: fd_list
end subroutine

!  guint32 g_dbus_message_get_reply_serial (GDBusMessage *message);
function g_dbus_message_get_reply_serial(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_reply_serial
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_reply_serial (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_reply_serial(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

!  const gchar *g_dbus_message_get_interface (GDBusMessage *message);
function g_dbus_message_get_interface(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_interface
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_interface (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_interface(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_member (GDBusMessage *message);
function g_dbus_message_get_member(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_member
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_member (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_member(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_path (GDBusMessage *message);
function g_dbus_message_get_path(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_path
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_path (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_path(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_sender (GDBusMessage *message);
function g_dbus_message_get_sender(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_sender
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_sender (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_sender(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_destination (GDBusMessage *message);
function g_dbus_message_get_destination(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_destination
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_destination (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_destination(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_error_name (GDBusMessage *message);
function g_dbus_message_get_error_name(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_error_name
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_error_name (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_error_name(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  const gchar *g_dbus_message_get_signature (GDBusMessage *message);
function g_dbus_message_get_signature(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_signature
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_signature (GDBusMessage *message, const gchar *value);
subroutine g_dbus_message_set_signature(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: message
  character(kind=c_char), dimension(*) :: value
end subroutine

!  guint32 g_dbus_message_get_num_unix_fds (GDBusMessage *message);
function g_dbus_message_get_num_unix_fds(message) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_dbus_message_get_num_unix_fds
  type(c_ptr), value :: message
end function

! void g_dbus_message_set_num_unix_fds (GDBusMessage *message, guint32 value);
subroutine g_dbus_message_set_num_unix_fds(message, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: message
  integer(c_int32_t), value :: value
end subroutine

!  const gchar *g_dbus_message_get_arg0 (GDBusMessage *message);
function g_dbus_message_get_arg0(message) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_message_get_arg0
  type(c_ptr), value :: message
end function

!  GDBusMessage *g_dbus_message_new_from_blob (guchar *blob, gsize blob_len, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_new_from_blob(blob, blob_len, capabilities, error) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_dbus_message_new_from_blob
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

!  gssize g_dbus_message_bytes_needed (guchar *blob, gsize blob_len, GError **error);
function g_dbus_message_bytes_needed(blob, blob_len, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_dbus_message_bytes_needed
  character(kind=c_char), dimension(*) :: blob
  integer(c_size_t), value :: blob_len
  type(c_ptr), value :: error
end function

!  guchar *g_dbus_message_to_blob (GDBusMessage *message, gsize *out_size, GDBusCapabilityFlags capabilities, GError **error);
function g_dbus_message_to_blob(message, out_size, capabilities, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_message_to_blob
  type(c_ptr), value :: message
  type(c_ptr), value :: out_size
  integer(c_int), value :: capabilities
  type(c_ptr), value :: error
end function

!  gboolean g_dbus_message_to_gerror (GDBusMessage *message, GError **error);
function g_dbus_message_to_gerror(message, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_message_to_gerror
  type(c_ptr), value :: message
  type(c_ptr), value :: error
end function

!   GType g_proxy_resolver_get_type (void) G_GNUC_CONST;
function g_proxy_resolver_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_resolver_get_type
end function

! GProxyResolver *g_proxy_resolver_get_default (void);
function g_proxy_resolver_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_resolver_get_default
end function

!  gboolean g_proxy_resolver_is_supported (GProxyResolver *resolver);
function g_proxy_resolver_is_supported(resolver) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_proxy_resolver_is_supported
  type(c_ptr), value :: resolver
end function

! gchar **g_proxy_resolver_lookup (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GError **error);
function g_proxy_resolver_lookup(resolver, uri, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_proxy_resolver_lookup
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_proxy_resolver_lookup_async (GProxyResolver *resolver, const gchar *uri, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_proxy_resolver_lookup_async(resolver, uri, cancellable, callback, &
&user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: resolver
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gchar **g_proxy_resolver_lookup_finish (GProxyResolver *resolver, GAsyncResult *result, GError **error);
function g_proxy_resolver_lookup_finish(resolver, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_resolver_lookup_finish
  type(c_ptr), value :: resolver
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_emblemed_icon_get_type (void) G_GNUC_CONST;
function g_emblemed_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_emblemed_icon_get_type
end function

!  GIcon *g_emblemed_icon_new (GIcon *icon, GEmblem *emblem);
function g_emblemed_icon_new(icon, emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_new
  type(c_ptr), value :: icon
  type(c_ptr), value :: emblem
end function

! GIcon *g_emblemed_icon_get_icon (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_icon(emblemed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_icon
  type(c_ptr), value :: emblemed
end function

! GList *g_emblemed_icon_get_emblems (GEmblemedIcon *emblemed);
function g_emblemed_icon_get_emblems(emblemed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_emblemed_icon_get_emblems
  type(c_ptr), value :: emblemed
end function

! void g_emblemed_icon_add_emblem (GEmblemedIcon *emblemed, GEmblem *emblem);
subroutine g_emblemed_icon_add_emblem(emblemed, emblem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: emblemed
  type(c_ptr), value :: emblem
end subroutine

! void g_emblemed_icon_clear_emblems (GEmblemedIcon *emblemed);
subroutine g_emblemed_icon_clear_emblems(emblemed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: emblemed
end subroutine

!   GType g_inet_socket_address_get_type (void) G_GNUC_CONST;
function g_inet_socket_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_inet_socket_address_get_type
end function

!  GSocketAddress *g_inet_socket_address_new (GInetAddress *address, guint16 port);
function g_inet_socket_address_new(address, port) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_inet_socket_address_new
  type(c_ptr), value :: address
  integer(c_int16_t), value :: port
end function

!  GInetAddress * g_inet_socket_address_get_address (GInetSocketAddress *address);
function g_inet_socket_address_get_address(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_socket_address_get_address
  type(c_ptr), value :: address
end function

!  guint16 g_inet_socket_address_get_port (GInetSocketAddress *address);
function g_inet_socket_address_get_port(address) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_inet_socket_address_get_port
  type(c_ptr), value :: address
end function

!   GType g_file_attribute_info_list_get_type (void);
function g_file_attribute_info_list_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_attribute_info_list_get_type
end function

! GFileAttributeInfoList * g_file_attribute_info_list_new (void);
function g_file_attribute_info_list_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_new
end function

! GFileAttributeInfoList * g_file_attribute_info_list_ref (GFileAttributeInfoList *list);
function g_file_attribute_info_list_ref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_ref
  type(c_ptr), value :: list
end function

! void g_file_attribute_info_list_unref (GFileAttributeInfoList *list);
subroutine g_file_attribute_info_list_unref(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! GFileAttributeInfoList * g_file_attribute_info_list_dup (GFileAttributeInfoList *list);
function g_file_attribute_info_list_dup(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_attribute_info_list_dup
  type(c_ptr), value :: list
end function

! const GFileAttributeInfo *g_file_attribute_info_list_lookup (GFileAttributeInfoList *list, const char *name);
function g_file_attribute_info_list_lookup(list, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_attribute_info_list_lookup
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
end function

! void g_file_attribute_info_list_add (GFileAttributeInfoList *list, const char *name, GFileAttributeType type, GFileAttributeInfoFlags flags);
subroutine g_file_attribute_info_list_add(list, name, type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: list
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: type
  integer(c_int), value :: flags
end subroutine

!   GType g_application_command_line_get_type (void) G_GNUC_CONST;
function g_application_command_line_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_application_command_line_get_type
end function

!  gchar ** g_application_command_line_get_arguments (GApplicationCommandLine *cmdline, int *argc);
function g_application_command_line_get_arguments(cmdline, argc) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_application_command_line_get_arguments
  type(c_ptr), value :: cmdline
  type(c_ptr), value :: argc
end function

!  const gchar * const * g_application_command_line_get_environ (GApplicationCommandLine *cmdline);
function g_application_command_line_get_environ(cmdline) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_application_command_line_get_environ
  type(c_ptr), value :: cmdline
end function

!  const gchar * g_application_command_line_getenv (GApplicationCommandLine *cmdline, const gchar *name);
function g_application_command_line_getenv(cmdline, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_application_command_line_getenv
  type(c_ptr), value :: cmdline
  character(kind=c_char), dimension(*) :: name
end function

!  const gchar * g_application_command_line_get_cwd (GApplicationCommandLine *cmdline);
function g_application_command_line_get_cwd(cmdline) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_application_command_line_get_cwd
  type(c_ptr), value :: cmdline
end function

!  gboolean g_application_command_line_get_is_remote (GApplicationCommandLine *cmdline);
function g_application_command_line_get_is_remote(cmdline) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_command_line_get_is_remote
  type(c_ptr), value :: cmdline
end function

!  void g_application_command_line_print (GApplicationCommandLine *cmdline, const gchar *format, ...) G_GNUC_PRINTF(2, 3);
subroutine g_application_command_line_print() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_application_command_line_printerr (GApplicationCommandLine *cmdline, const gchar *format, ...) G_GNUC_PRINTF(2, 3);
subroutine g_application_command_line_printerr() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  int g_application_command_line_get_exit_status (GApplicationCommandLine *cmdline);
function g_application_command_line_get_exit_status(cmdline) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_application_command_line_get_exit_status
  type(c_ptr), value :: cmdline
end function

! void g_application_command_line_set_exit_status (GApplicationCommandLine *cmdline, int exit_status);
subroutine g_application_command_line_set_exit_status(cmdline, exit_status) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: cmdline
  integer(c_int), value :: exit_status
end subroutine

!  GVariant * g_application_command_line_get_platform_data (GApplicationCommandLine *cmdline);
function g_application_command_line_get_platform_data(cmdline) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_application_command_line_get_platform_data
  type(c_ptr), value :: cmdline
end function

!   GType g_app_info_get_type (void) G_GNUC_CONST;
function g_app_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_info_get_type
end function

! GAppInfo * g_app_info_create_from_commandline (const char *commandline, const char *application_name, GAppInfoCreateFlags flags, GError **error);
function g_app_info_create_from_commandline(commandline, application_name, flag&
&s, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_app_info_create_from_commandline
  character(kind=c_char), dimension(*) :: commandline
  character(kind=c_char), dimension(*) :: application_name
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! GAppInfo * g_app_info_dup (GAppInfo *appinfo);
function g_app_info_dup(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_dup
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_equal (GAppInfo *appinfo1, GAppInfo *appinfo2);
function g_app_info_equal(appinfo1, appinfo2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_equal
  type(c_ptr), value :: appinfo1
  type(c_ptr), value :: appinfo2
end function

! const char *g_app_info_get_id (GAppInfo *appinfo);
function g_app_info_get_id(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_id
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_name (GAppInfo *appinfo);
function g_app_info_get_name(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_name
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_display_name (GAppInfo *appinfo);
function g_app_info_get_display_name(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_display_name
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_description (GAppInfo *appinfo);
function g_app_info_get_description(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_description
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_executable (GAppInfo *appinfo);
function g_app_info_get_executable(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_executable
  type(c_ptr), value :: appinfo
end function

! const char *g_app_info_get_commandline (GAppInfo *appinfo);
function g_app_info_get_commandline(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_commandline
  type(c_ptr), value :: appinfo
end function

! GIcon * g_app_info_get_icon (GAppInfo *appinfo);
function g_app_info_get_icon(appinfo) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_icon
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_launch (GAppInfo *appinfo, GList *files, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch(appinfo, files, launch_context, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_launch
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: files
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

! gboolean g_app_info_supports_uris (GAppInfo *appinfo);
function g_app_info_supports_uris(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_supports_uris
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_supports_files (GAppInfo *appinfo);
function g_app_info_supports_files(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_supports_files
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_launch_uris (GAppInfo *appinfo, GList *uris, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch_uris(appinfo, uris, launch_context, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_launch_uris
  type(c_ptr), value :: appinfo
  type(c_ptr), value :: uris
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

! gboolean g_app_info_should_show (GAppInfo *appinfo);
function g_app_info_should_show(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_should_show
  type(c_ptr), value :: appinfo
end function

!  gboolean g_app_info_set_as_default_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_set_as_default_for_type(appinfo, content_type, error) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_default_for_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_set_as_default_for_extension (GAppInfo *appinfo, const char *extension, GError **error);
function g_app_info_set_as_default_for_extension(appinfo, extension, error) bin&
&d(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_default_for_extension
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: extension
  type(c_ptr), value :: error
end function

! gboolean g_app_info_add_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_add_supports_type(appinfo, content_type, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_add_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_can_remove_supports_type (GAppInfo *appinfo);
function g_app_info_can_remove_supports_type(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_can_remove_supports_type
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_remove_supports_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_remove_supports_type(appinfo, content_type, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_remove_supports_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

! gboolean g_app_info_can_delete (GAppInfo *appinfo);
function g_app_info_can_delete(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_can_delete
  type(c_ptr), value :: appinfo
end function

! gboolean g_app_info_delete (GAppInfo *appinfo);
function g_app_info_delete(appinfo) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_app_info_delete
  type(c_ptr), value :: appinfo
end function

!  gboolean g_app_info_set_as_last_used_for_type (GAppInfo *appinfo, const char *content_type, GError **error);
function g_app_info_set_as_last_used_for_type(appinfo, content_type, error) bin&
&d(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_app_info_set_as_last_used_for_type
  type(c_ptr), value :: appinfo
  character(kind=c_char), dimension(*) :: content_type
  type(c_ptr), value :: error
end function

!  GList * g_app_info_get_all (void);
function g_app_info_get_all() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_info_get_all
end function

! GList * g_app_info_get_all_for_type (const char *content_type);
function g_app_info_get_all_for_type(content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_all_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! GList * g_app_info_get_recommended_for_type (const gchar *content_type);
function g_app_info_get_recommended_for_type(content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_recommended_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

! GList * g_app_info_get_fallback_for_type (const gchar *content_type);
function g_app_info_get_fallback_for_type(content_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_fallback_for_type
  character(kind=c_char), dimension(*) :: content_type
end function

!  void g_app_info_reset_type_associations (const char *content_type);
subroutine g_app_info_reset_type_associations(content_type) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: content_type
end subroutine

! GAppInfo *g_app_info_get_default_for_type (const char *content_type, gboolean must_support_uris);
function g_app_info_get_default_for_type(content_type, must_support_uris) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_app_info_get_default_for_type
  character(kind=c_char), dimension(*) :: content_type
  integer(c_int), value :: must_support_uris
end function

! GAppInfo *g_app_info_get_default_for_uri_scheme (const char *uri_scheme);
function g_app_info_get_default_for_uri_scheme(uri_scheme) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_app_info_get_default_for_uri_scheme
  character(kind=c_char), dimension(*) :: uri_scheme
end function

!  gboolean g_app_info_launch_default_for_uri (const char *uri, GAppLaunchContext *launch_context, GError **error);
function g_app_info_launch_default_for_uri(uri, launch_context, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_app_info_launch_default_for_uri
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: launch_context
  type(c_ptr), value :: error
end function

!  GType g_app_launch_context_get_type (void) G_GNUC_CONST;
function g_app_launch_context_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_app_launch_context_get_type
end function

! GAppLaunchContext *g_app_launch_context_new (void);
function g_app_launch_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_new
end function

! char * g_app_launch_context_get_display (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_display(context, info, files) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_get_display
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! char * g_app_launch_context_get_startup_notify_id (GAppLaunchContext *context, GAppInfo *info, GList *files);
function g_app_launch_context_get_startup_notify_id(context, info, files) bind(&
&c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_app_launch_context_get_startup_notify_id
  type(c_ptr), value :: context
  type(c_ptr), value :: info
  type(c_ptr), value :: files
end function

! void g_app_launch_context_launch_failed (GAppLaunchContext *context, const char * startup_notify_id);
subroutine g_app_launch_context_launch_failed(context, startup_notify_id) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: startup_notify_id
end subroutine

!   GType g_inet_address_get_type (void) G_GNUC_CONST;
function g_inet_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_inet_address_get_type
end function

!  GInetAddress * g_inet_address_new_from_string (const gchar *string);
function g_inet_address_new_from_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_inet_address_new_from_string
  character(kind=c_char), dimension(*) :: string
end function

!  GInetAddress * g_inet_address_new_from_bytes (const guint8 *bytes, GSocketFamily family);
function g_inet_address_new_from_bytes(bytes, family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_from_bytes
  type(c_ptr), value :: bytes
  integer(c_int), value :: family
end function

!  GInetAddress * g_inet_address_new_loopback (GSocketFamily family);
function g_inet_address_new_loopback(family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_loopback
  integer(c_int), value :: family
end function

!  GInetAddress * g_inet_address_new_any (GSocketFamily family);
function g_inet_address_new_any(family) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_inet_address_new_any
  integer(c_int), value :: family
end function

!  gchar * g_inet_address_to_string (GInetAddress *address);
function g_inet_address_to_string(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_address_to_string
  type(c_ptr), value :: address
end function

!  const guint8 * g_inet_address_to_bytes (GInetAddress *address);
function g_inet_address_to_bytes(address) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_inet_address_to_bytes
  type(c_ptr), value :: address
end function

!  gsize g_inet_address_get_native_size (GInetAddress *address);
function g_inet_address_get_native_size(address) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_inet_address_get_native_size
  type(c_ptr), value :: address
end function

!  GSocketFamily g_inet_address_get_family (GInetAddress *address);
function g_inet_address_get_family(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_family
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_any (GInetAddress *address);
function g_inet_address_get_is_any(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_any
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_loopback (GInetAddress *address);
function g_inet_address_get_is_loopback(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_loopback
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_link_local (GInetAddress *address);
function g_inet_address_get_is_link_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_link_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_site_local (GInetAddress *address);
function g_inet_address_get_is_site_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_site_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_multicast (GInetAddress *address);
function g_inet_address_get_is_multicast(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_multicast
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_global (GInetAddress *address);
function g_inet_address_get_is_mc_global(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_global
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_link_local (GInetAddress *address);
function g_inet_address_get_is_mc_link_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_link_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_node_local (GInetAddress *address);
function g_inet_address_get_is_mc_node_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_node_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_org_local (GInetAddress *address);
function g_inet_address_get_is_mc_org_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_org_local
  type(c_ptr), value :: address
end function

!  gboolean g_inet_address_get_is_mc_site_local (GInetAddress *address);
function g_inet_address_get_is_mc_site_local(address) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_inet_address_get_is_mc_site_local
  type(c_ptr), value :: address
end function

!   gboolean g_content_type_equals (const gchar *type1, const gchar *type2);
function g_content_type_equals(type1, type2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_content_type_equals
  character(kind=c_char), dimension(*) :: type1
  character(kind=c_char), dimension(*) :: type2
end function

! gboolean g_content_type_is_a (const gchar *type, const gchar *supertype);
function g_content_type_is_a(type, supertype) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_content_type_is_a
  character(kind=c_char), dimension(*) :: type
  character(kind=c_char), dimension(*) :: supertype
end function

! gboolean g_content_type_is_unknown (const gchar *type);
function g_content_type_is_unknown(type) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_content_type_is_unknown
  character(kind=c_char), dimension(*) :: type
end function

! gchar * g_content_type_get_description (const gchar *type);
function g_content_type_get_description(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_description
  character(kind=c_char), dimension(*) :: type
end function

! gchar * g_content_type_get_mime_type (const gchar *type);
function g_content_type_get_mime_type(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_mime_type
  character(kind=c_char), dimension(*) :: type
end function

! GIcon * g_content_type_get_icon (const gchar *type);
function g_content_type_get_icon(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_get_icon
  character(kind=c_char), dimension(*) :: type
end function

! gboolean g_content_type_can_be_executable (const gchar *type);
function g_content_type_can_be_executable(type) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_content_type_can_be_executable
  character(kind=c_char), dimension(*) :: type
end function

!  gchar * g_content_type_from_mime_type (const gchar *mime_type);
function g_content_type_from_mime_type(mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_content_type_from_mime_type
  character(kind=c_char), dimension(*) :: mime_type
end function

!  gchar * g_content_type_guess (const gchar *filename, const guchar *data, gsize data_size, gboolean *result_uncertain);
function g_content_type_guess(filename, data, data_size, result_uncertain) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_content_type_guess
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: result_uncertain
end function

!  gchar ** g_content_type_guess_for_tree (GFile *root);
function g_content_type_guess_for_tree(root) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_content_type_guess_for_tree
  type(c_ptr), value :: root
end function

!  GList * g_content_types_get_registered (void);
function g_content_types_get_registered() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_content_types_get_registered
end function

!   GType g_data_output_stream_get_type (void) G_GNUC_CONST;
function g_data_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_output_stream_get_type
end function

! GDataOutputStream * g_data_output_stream_new (GOutputStream *base_stream);
function g_data_output_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_output_stream_new
  type(c_ptr), value :: base_stream
end function

!  void g_data_output_stream_set_byte_order (GDataOutputStream *stream, GDataStreamByteOrder order);
subroutine g_data_output_stream_set_byte_order(stream, order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GDataStreamByteOrder g_data_output_stream_get_byte_order (GDataOutputStream *stream);
function g_data_output_stream_get_byte_order(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_output_stream_get_byte_order
  type(c_ptr), value :: stream
end function

!  gboolean g_data_output_stream_put_byte (GDataOutputStream *stream, guchar data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_byte(stream, data, cancellable, error) bind(c&
&) 
  use iso_c_binding, only: c_int, c_ptr, c_int8_t
  integer(c_int) :: g_data_output_stream_put_byte
  type(c_ptr), value :: stream
  integer(kind=c_int8_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int16 (GDataOutputStream *stream, gint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int16(stream, data, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_data_output_stream_put_int16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint16 (GDataOutputStream *stream, guint16 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint16(stream, data, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int16_t
  integer(c_int) :: g_data_output_stream_put_uint16
  type(c_ptr), value :: stream
  integer(c_int16_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int32 (GDataOutputStream *stream, gint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int32(stream, data, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_data_output_stream_put_int32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint32 (GDataOutputStream *stream, guint32 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint32(stream, data, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_data_output_stream_put_uint32
  type(c_ptr), value :: stream
  integer(c_int32_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_int64 (GDataOutputStream *stream, gint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_int64(stream, data, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_data_output_stream_put_int64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_uint64 (GDataOutputStream *stream, guint64 data, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_uint64(stream, data, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_data_output_stream_put_uint64
  type(c_ptr), value :: stream
  integer(c_int64_t), value :: data
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_data_output_stream_put_string (GDataOutputStream *stream, const char *str, GCancellable *cancellable, GError **error);
function g_data_output_stream_put_string(stream, str, cancellable, error) bind(&
&c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_data_output_stream_put_string
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: str
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_srv_target_get_type (void) G_GNUC_CONST;
function g_srv_target_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_srv_target_get_type
end function

!  GSrvTarget *g_srv_target_new (const gchar *hostname, guint16 port, guint16 priority, guint16 weight);
function g_srv_target_new(hostname, port, priority, weight) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int16_t
  type(c_ptr) :: g_srv_target_new
  character(kind=c_char), dimension(*) :: hostname
  integer(c_int16_t), value :: port
  integer(c_int16_t), value :: priority
  integer(c_int16_t), value :: weight
end function

! GSrvTarget *g_srv_target_copy (GSrvTarget *target);
function g_srv_target_copy(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_copy
  type(c_ptr), value :: target
end function

! void g_srv_target_free (GSrvTarget *target);
subroutine g_srv_target_free(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: target
end subroutine

!  const gchar *g_srv_target_get_hostname (GSrvTarget *target);
function g_srv_target_get_hostname(target) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_get_hostname
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_port (GSrvTarget *target);
function g_srv_target_get_port(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_port
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_priority (GSrvTarget *target);
function g_srv_target_get_priority(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_priority
  type(c_ptr), value :: target
end function

! guint16 g_srv_target_get_weight (GSrvTarget *target);
function g_srv_target_get_weight(target) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_srv_target_get_weight
  type(c_ptr), value :: target
end function

!  GList *g_srv_target_list_sort (GList *targets);
function g_srv_target_list_sort(targets) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_srv_target_list_sort
  type(c_ptr), value :: targets
end function

!   void g_io_scheduler_push_job (GIOSchedulerJobFunc job_func, gpointer user_data, GDestroyNotify notify, gint io_priority, GCancellable *cancellable);
subroutine g_io_scheduler_push_job(job_func, user_data, notify, io_priority, ca&
&ncellable) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr, c_int
  type(c_funptr), value :: job_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
end subroutine

! void g_io_scheduler_cancel_all_jobs (void);
subroutine g_io_scheduler_cancel_all_jobs() bind(c) 
  use iso_c_binding, only: 
end subroutine

! gboolean g_io_scheduler_job_send_to_mainloop (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
function g_io_scheduler_job_send_to_mainloop(job, func, user_data, notify) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_io_scheduler_job_send_to_mainloop
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! void g_io_scheduler_job_send_to_mainloop_async (GIOSchedulerJob *job, GSourceFunc func, gpointer user_data, GDestroyNotify notify);
subroutine g_io_scheduler_job_send_to_mainloop_async(job, func, user_data, noti&
&fy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: job
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end subroutine

!   GType g_dbus_method_invocation_get_type (void) G_GNUC_CONST;
function g_dbus_method_invocation_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_method_invocation_get_type
end function

! const gchar *g_dbus_method_invocation_get_sender (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_sender(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_sender
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_object_path (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_object_path(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_object_path
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_interface_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_interface_name(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_interface_name
  type(c_ptr), value :: invocation
end function

! const gchar *g_dbus_method_invocation_get_method_name (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_name(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_name
  type(c_ptr), value :: invocation
end function

! const GDBusMethodInfo *g_dbus_method_invocation_get_method_info (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_method_info(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_method_info
  type(c_ptr), value :: invocation
end function

! GDBusConnection *g_dbus_method_invocation_get_connection (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_connection(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_connection
  type(c_ptr), value :: invocation
end function

! GDBusMessage *g_dbus_method_invocation_get_message (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_message(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_message
  type(c_ptr), value :: invocation
end function

! GVariant *g_dbus_method_invocation_get_parameters (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_parameters(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_parameters
  type(c_ptr), value :: invocation
end function

! gpointer g_dbus_method_invocation_get_user_data (GDBusMethodInvocation *invocation);
function g_dbus_method_invocation_get_user_data(invocation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_invocation_get_user_data
  type(c_ptr), value :: invocation
end function

!  void g_dbus_method_invocation_return_value (GDBusMethodInvocation *invocation, GVariant *parameters);
subroutine g_dbus_method_invocation_return_value(invocation, parameters) bind(c&
&) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: parameters
end subroutine

! void g_dbus_method_invocation_return_error_valist (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *format, va_list var_args);
subroutine g_dbus_method_invocation_return_error_valist(invocation, domain, cod&
&e, format, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: var_args
end subroutine

! void g_dbus_method_invocation_return_error_literal (GDBusMethodInvocation *invocation, GQuark domain, gint code, const gchar *message);
subroutine g_dbus_method_invocation_return_error_literal(invocation, domain, co&
&de, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: invocation
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

! void g_dbus_method_invocation_return_gerror (GDBusMethodInvocation *invocation, const GError *error);
subroutine g_dbus_method_invocation_return_gerror(invocation, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: invocation
  type(c_ptr), value :: error
end subroutine

! void g_dbus_method_invocation_return_dbus_error (GDBusMethodInvocation *invocation, const gchar *error_name, const gchar *error_message);
subroutine g_dbus_method_invocation_return_dbus_error(invocation, error_name, e&
&rror_message) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: invocation
  character(kind=c_char), dimension(*) :: error_name
  character(kind=c_char), dimension(*) :: error_message
end subroutine

!   GType g_file_icon_get_type (void) G_GNUC_CONST;
function g_file_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_icon_get_type
end function

!  GIcon * g_file_icon_new (GFile *file);
function g_file_icon_new(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_icon_new
  type(c_ptr), value :: file
end function

!  GFile * g_file_icon_get_file (GFileIcon *icon);
function g_file_icon_get_file(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_icon_get_file
  type(c_ptr), value :: icon
end function

!   GType g_simple_action_group_get_type (void) G_GNUC_CONST;
function g_simple_action_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_action_group_get_type
end function

!  GSimpleActionGroup * g_simple_action_group_new (void);
function g_simple_action_group_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_simple_action_group_new
end function

!  GAction * g_simple_action_group_lookup (GSimpleActionGroup *simple, const gchar *action_name);
function g_simple_action_group_lookup(simple, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_simple_action_group_lookup
  type(c_ptr), value :: simple
  character(kind=c_char), dimension(*) :: action_name
end function

!  void g_simple_action_group_insert (GSimpleActionGroup *simple, GAction *action);
subroutine g_simple_action_group_insert(simple, action) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: simple
  type(c_ptr), value :: action
end subroutine

!  void g_simple_action_group_remove (GSimpleActionGroup *simple, const gchar *action_name);
subroutine g_simple_action_group_remove(simple, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: simple
  character(kind=c_char), dimension(*) :: action_name
end subroutine

!   GType g_zlib_decompressor_get_type (void) G_GNUC_CONST;
function g_zlib_decompressor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_zlib_decompressor_get_type
end function

!  GZlibDecompressor *g_zlib_decompressor_new (GZlibCompressorFormat format);
function g_zlib_decompressor_new(format) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_zlib_decompressor_new
  integer(c_int), value :: format
end function

!  GFileInfo *g_zlib_decompressor_get_file_info (GZlibDecompressor *decompressor);
function g_zlib_decompressor_get_file_info(decompressor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_zlib_decompressor_get_file_info
  type(c_ptr), value :: decompressor
end function

!   GType g_threaded_socket_service_get_type (void);
function g_threaded_socket_service_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_threaded_socket_service_get_type
end function

! GSocketService * g_threaded_socket_service_new (int max_threads);
function g_threaded_socket_service_new(max_threads) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_threaded_socket_service_new
  integer(c_int), value :: max_threads
end function

!   GType g_filter_input_stream_get_type (void) G_GNUC_CONST;
function g_filter_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_filter_input_stream_get_type
end function

! GInputStream * g_filter_input_stream_get_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_filter_input_stream_get_base_stream
  type(c_ptr), value :: stream
end function

! gboolean g_filter_input_stream_get_close_base_stream (GFilterInputStream *stream);
function g_filter_input_stream_get_close_base_stream(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_filter_input_stream_get_close_base_stream
  type(c_ptr), value :: stream
end function

! void g_filter_input_stream_set_close_base_stream (GFilterInputStream *stream, gboolean close_base);
subroutine g_filter_input_stream_set_close_base_stream(stream, close_base) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: close_base
end subroutine

!   GType g_async_initable_get_type (void) G_GNUC_CONST;
function g_async_initable_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_async_initable_get_type
end function

!  void g_async_initable_init_async (GAsyncInitable *initable, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_init_async(initable, io_priority, cancellable, call&
&back, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: initable
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_async_initable_init_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_init_finish(initable, res, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_async_initable_init_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! void g_async_initable_newv_async (GType object_type, guint n_parameters, GParameter *parameters, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_newv_async(object_type, n_parameters, parameters, i&
&o_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_size_t, c_int, c_ptr, c_funptr
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! void g_async_initable_new_valist_async (GType object_type, const gchar *first_property_name, va_list var_args, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_async_initable_new_valist_async(object_type, first_property_name, &
&var_args, io_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int, c_funptr
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GObject *g_async_initable_new_finish (GAsyncInitable *initable, GAsyncResult *res, GError **error);
function g_async_initable_new_finish(initable, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_initable_new_finish
  type(c_ptr), value :: initable
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

!   GType g_volume_monitor_get_type (void) G_GNUC_CONST;
function g_volume_monitor_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_volume_monitor_get_type
end function

!  GVolumeMonitor *g_volume_monitor_get (void);
function g_volume_monitor_get() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get
end function

! GList * g_volume_monitor_get_connected_drives (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_connected_drives(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_connected_drives
  type(c_ptr), value :: volume_monitor
end function

! GList * g_volume_monitor_get_volumes (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_volumes(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_volumes
  type(c_ptr), value :: volume_monitor
end function

! GList * g_volume_monitor_get_mounts (GVolumeMonitor *volume_monitor);
function g_volume_monitor_get_mounts(volume_monitor) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_get_mounts
  type(c_ptr), value :: volume_monitor
end function

! GVolume * g_volume_monitor_get_volume_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_volume_for_uuid(volume_monitor, uuid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_volume_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

! GMount * g_volume_monitor_get_mount_for_uuid (GVolumeMonitor *volume_monitor, const char *uuid);
function g_volume_monitor_get_mount_for_uuid(volume_monitor, uuid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_volume_monitor_get_mount_for_uuid
  type(c_ptr), value :: volume_monitor
  character(kind=c_char), dimension(*) :: uuid
end function

!  GVolume * g_volume_monitor_adopt_orphan_mount (GMount *mount);
function g_volume_monitor_adopt_orphan_mount(mount) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_volume_monitor_adopt_orphan_mount
  type(c_ptr), value :: mount
end function

!   GType g_converter_output_stream_get_type (void) G_GNUC_CONST;
function g_converter_output_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_output_stream_get_type
end function

! GOutputStream *g_converter_output_stream_new (GOutputStream *base_stream, GConverter *converter);
function g_converter_output_stream_new(base_stream, converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_output_stream_new
  type(c_ptr), value :: base_stream
  type(c_ptr), value :: converter
end function

! GConverter *g_converter_output_stream_get_converter (GConverterOutputStream *converter_stream);
function g_converter_output_stream_get_converter(converter_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_converter_output_stream_get_converter
  type(c_ptr), value :: converter_stream
end function

!   const gchar *g_dbus_annotation_info_lookup (GDBusAnnotationInfo **annotations, const gchar *name);
function g_dbus_annotation_info_lookup(annotations, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_annotation_info_lookup
  type(c_ptr), value :: annotations
  character(kind=c_char), dimension(*) :: name
end function

! GDBusMethodInfo *g_dbus_interface_info_lookup_method (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_method(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_method
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GDBusSignalInfo *g_dbus_interface_info_lookup_signal (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_signal(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_signal
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! GDBusPropertyInfo *g_dbus_interface_info_lookup_property (GDBusInterfaceInfo *info, const gchar *name);
function g_dbus_interface_info_lookup_property(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_interface_info_lookup_property
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! void g_dbus_interface_info_generate_xml (GDBusInterfaceInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_interface_info_generate_xml(info, indent, string_builder) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

!  GDBusNodeInfo *g_dbus_node_info_new_for_xml (const gchar *xml_data, GError **error);
function g_dbus_node_info_new_for_xml(xml_data, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_new_for_xml
  character(kind=c_char), dimension(*) :: xml_data
  type(c_ptr), value :: error
end function

! GDBusInterfaceInfo *g_dbus_node_info_lookup_interface (GDBusNodeInfo *info, const gchar *name);
function g_dbus_node_info_lookup_interface(info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_node_info_lookup_interface
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
end function

! void g_dbus_node_info_generate_xml (GDBusNodeInfo *info, guint indent, GString *string_builder);
subroutine g_dbus_node_info_generate_xml(info, indent, string_builder) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: info
  integer(c_int), value :: indent
  type(c_ptr), value :: string_builder
end subroutine

!  GDBusNodeInfo *g_dbus_node_info_ref (GDBusNodeInfo *info);
function g_dbus_node_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_node_info_ref
  type(c_ptr), value :: info
end function

! GDBusInterfaceInfo *g_dbus_interface_info_ref (GDBusInterfaceInfo *info);
function g_dbus_interface_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_interface_info_ref
  type(c_ptr), value :: info
end function

! GDBusMethodInfo *g_dbus_method_info_ref (GDBusMethodInfo *info);
function g_dbus_method_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_method_info_ref
  type(c_ptr), value :: info
end function

! GDBusSignalInfo *g_dbus_signal_info_ref (GDBusSignalInfo *info);
function g_dbus_signal_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_signal_info_ref
  type(c_ptr), value :: info
end function

! GDBusPropertyInfo *g_dbus_property_info_ref (GDBusPropertyInfo *info);
function g_dbus_property_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_property_info_ref
  type(c_ptr), value :: info
end function

! GDBusArgInfo *g_dbus_arg_info_ref (GDBusArgInfo *info);
function g_dbus_arg_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_arg_info_ref
  type(c_ptr), value :: info
end function

! GDBusAnnotationInfo *g_dbus_annotation_info_ref (GDBusAnnotationInfo *info);
function g_dbus_annotation_info_ref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_annotation_info_ref
  type(c_ptr), value :: info
end function

!  void g_dbus_node_info_unref (GDBusNodeInfo *info);
subroutine g_dbus_node_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_interface_info_unref (GDBusInterfaceInfo *info);
subroutine g_dbus_interface_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_method_info_unref (GDBusMethodInfo *info);
subroutine g_dbus_method_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_signal_info_unref (GDBusSignalInfo *info);
subroutine g_dbus_signal_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_property_info_unref (GDBusPropertyInfo *info);
subroutine g_dbus_property_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_arg_info_unref (GDBusArgInfo *info);
subroutine g_dbus_arg_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

! void g_dbus_annotation_info_unref (GDBusAnnotationInfo *info);
subroutine g_dbus_annotation_info_unref(info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: info
end subroutine

!  GType g_dbus_node_info_get_type (void) G_GNUC_CONST;
function g_dbus_node_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_node_info_get_type
end function

! GType g_dbus_interface_info_get_type (void) G_GNUC_CONST;
function g_dbus_interface_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_interface_info_get_type
end function

! GType g_dbus_method_info_get_type (void) G_GNUC_CONST;
function g_dbus_method_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_method_info_get_type
end function

! GType g_dbus_signal_info_get_type (void) G_GNUC_CONST;
function g_dbus_signal_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_signal_info_get_type
end function

! GType g_dbus_property_info_get_type (void) G_GNUC_CONST;
function g_dbus_property_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_property_info_get_type
end function

! GType g_dbus_arg_info_get_type (void) G_GNUC_CONST;
function g_dbus_arg_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_arg_info_get_type
end function

! GType g_dbus_annotation_info_get_type (void) G_GNUC_CONST;
function g_dbus_annotation_info_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_annotation_info_get_type
end function

!   GType g_converter_get_type (void) G_GNUC_CONST;
function g_converter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_converter_get_type
end function

!  GConverterResult g_converter_convert (GConverter *converter, const void *inbuf, gsize inbuf_size, void *outbuf, gsize outbuf_size, GConverterFlags flags, gsize *bytes_read, gsize *bytes_written, GError **error);
function g_converter_convert(converter, inbuf, inbuf_size, outbuf, outbuf_size,&
& flags, bytes_read, bytes_written, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_converter_convert
  type(c_ptr), value :: converter
  type(c_ptr), value :: inbuf
  integer(c_size_t), value :: inbuf_size
  type(c_ptr), value :: outbuf
  integer(c_size_t), value :: outbuf_size
  integer(c_int), value :: flags
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! void g_converter_reset (GConverter *converter);
subroutine g_converter_reset(converter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: converter
end subroutine

!   GType g_proxy_address_get_type (void) G_GNUC_CONST;
function g_proxy_address_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_proxy_address_get_type
end function

!  GSocketAddress *g_proxy_address_new (GInetAddress *inetaddr, guint16 port, const gchar *protocol, const gchar *dest_hostname, guint16 dest_port, const gchar *username, const gchar *password);
function g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port&
&, username, password) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t, c_char
  type(c_ptr) :: g_proxy_address_new
  type(c_ptr), value :: inetaddr
  integer(c_int16_t), value :: port
  character(kind=c_char), dimension(*) :: protocol
  character(kind=c_char), dimension(*) :: dest_hostname
  integer(c_int16_t), value :: dest_port
  character(kind=c_char), dimension(*) :: username
  character(kind=c_char), dimension(*) :: password
end function

!  const gchar *g_proxy_address_get_protocol (GProxyAddress *proxy);
function g_proxy_address_get_protocol(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_protocol
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_destination_hostname (GProxyAddress *proxy);
function g_proxy_address_get_destination_hostname(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_destination_hostname
  type(c_ptr), value :: proxy
end function

! guint16 g_proxy_address_get_destination_port (GProxyAddress *proxy);
function g_proxy_address_get_destination_port(proxy) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_proxy_address_get_destination_port
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_username (GProxyAddress *proxy);
function g_proxy_address_get_username(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_username
  type(c_ptr), value :: proxy
end function

! const gchar *g_proxy_address_get_password (GProxyAddress *proxy);
function g_proxy_address_get_password(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_proxy_address_get_password
  type(c_ptr), value :: proxy
end function

!   GType g_data_input_stream_get_type (void) G_GNUC_CONST;
function g_data_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_data_input_stream_get_type
end function

! GDataInputStream * g_data_input_stream_new (GInputStream *base_stream);
function g_data_input_stream_new(base_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_new
  type(c_ptr), value :: base_stream
end function

!  void g_data_input_stream_set_byte_order (GDataInputStream *stream, GDataStreamByteOrder order);
subroutine g_data_input_stream_set_byte_order(stream, order) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: order
end subroutine

! GDataStreamByteOrder g_data_input_stream_get_byte_order (GDataInputStream *stream);
function g_data_input_stream_get_byte_order(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_byte_order
  type(c_ptr), value :: stream
end function

! void g_data_input_stream_set_newline_type (GDataInputStream *stream, GDataStreamNewlineType type);
subroutine g_data_input_stream_set_newline_type(stream, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: stream
  integer(c_int), value :: type
end subroutine

! GDataStreamNewlineType g_data_input_stream_get_newline_type (GDataInputStream *stream);
function g_data_input_stream_get_newline_type(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_data_input_stream_get_newline_type
  type(c_ptr), value :: stream
end function

! guchar g_data_input_stream_read_byte (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_byte(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_data_input_stream_read_byte
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint16 g_data_input_stream_read_int16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int16(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_int16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint16 g_data_input_stream_read_uint16 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint16(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_data_input_stream_read_uint16
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint32 g_data_input_stream_read_int32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int32(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_int32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint32 g_data_input_stream_read_uint32 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint32(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_data_input_stream_read_uint32
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gint64 g_data_input_stream_read_int64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_int64(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_int64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! guint64 g_data_input_stream_read_uint64 (GDataInputStream *stream, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_uint64(stream, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_data_input_stream_read_uint64
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! char * g_data_input_stream_read_line (GDataInputStream *stream, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_line(stream, length, cancellable, error) bind&
&(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line
  type(c_ptr), value :: stream
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_line_async (GDataInputStream *stream, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_line_async(stream, io_priority, cancellable&
&, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: stream
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_line_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_line_finish(stream, result, length, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_line_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! char * g_data_input_stream_read_until (GDataInputStream *stream, const gchar *stop_chars, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_until(stream, stop_chars, length, cancellable&
&, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_data_input_stream_read_until
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_until_async (GDataInputStream *stream, const gchar *stop_chars, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_until_async(stream, stop_chars, io_priority&
&, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_until_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_until_finish(stream, result, length, error) b&
&ind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_until_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

!  char * g_data_input_stream_read_upto (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gsize *length, GCancellable *cancellable, GError **error);
function g_data_input_stream_read_upto(stream, stop_chars, stop_chars_len, leng&
&th, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_data_input_stream_read_upto
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  type(c_ptr), value :: length
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_data_input_stream_read_upto_async (GDataInputStream *stream, const gchar *stop_chars, gssize stop_chars_len, gint io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_data_input_stream_read_upto_async(stream, stop_chars, stop_chars_l&
&en, io_priority, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: stop_chars
  integer(c_size_t), value :: stop_chars_len
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! char * g_data_input_stream_read_upto_finish (GDataInputStream *stream, GAsyncResult *result, gsize *length, GError **error);
function g_data_input_stream_read_upto_finish(stream, result, length, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_data_input_stream_read_upto_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

!   gboolean g_dbus_is_address (const gchar *string);
function g_dbus_is_address(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_address
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_supported_address (const gchar *string, GError **error);
function g_dbus_is_supported_address(string, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_dbus_is_supported_address
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: error
end function

!  void g_dbus_address_get_stream (const gchar *address, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_address_get_stream(address, cancellable, callback, user_data)&
& bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: address
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

!  GIOStream *g_dbus_address_get_stream_finish (GAsyncResult *res, gchar **out_guid, GError **error);
function g_dbus_address_get_stream_finish(res, out_guid, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_address_get_stream_finish
  type(c_ptr), value :: res
  type(c_ptr), dimension(*) :: out_guid
  type(c_ptr), value :: error
end function

!  GIOStream *g_dbus_address_get_stream_sync (const gchar *address, gchar **out_guid, GCancellable *cancellable, GError **error);
function g_dbus_address_get_stream_sync(address, out_guid, cancellable, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_address_get_stream_sync
  character(kind=c_char), dimension(*) :: address
  type(c_ptr), dimension(*) :: out_guid
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  gchar *g_dbus_address_get_for_bus_sync (GBusType bus_type, GCancellable *cancellable, GError **error);
function g_dbus_address_get_for_bus_sync(bus_type, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_dbus_address_get_for_bus_sync
  integer(c_int), value :: bus_type
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_tcp_connection_get_type (void) G_GNUC_CONST;
function g_tcp_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tcp_connection_get_type
end function

!  void g_tcp_connection_set_graceful_disconnect (GTcpConnection *connection, gboolean graceful_disconnect);
subroutine g_tcp_connection_set_graceful_disconnect(connection, graceful_discon&
&nect) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: connection
  integer(c_int), value :: graceful_disconnect
end subroutine

! gboolean g_tcp_connection_get_graceful_disconnect (GTcpConnection *connection);
function g_tcp_connection_get_graceful_disconnect(connection) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tcp_connection_get_graceful_disconnect
  type(c_ptr), value :: connection
end function

!   GType g_dbus_proxy_get_type (void) G_GNUC_CONST;
function g_dbus_proxy_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_proxy_get_type
end function

! void g_dbus_proxy_new (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new(connection, flags, info, name, object_path, interfa&
&ce_name, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_funptr
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusProxy *g_dbus_proxy_new_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusProxy *g_dbus_proxy_new_sync (GDBusConnection *connection, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_sync(connection, flags, info, name, object_path, inte&
&rface_name, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_sync
  type(c_ptr), value :: connection
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_dbus_proxy_new_for_bus (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, i&
&nterface_name, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_funptr
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GDBusProxy *g_dbus_proxy_new_for_bus_finish (GAsyncResult *res, GError **error);
function g_dbus_proxy_new_for_bus_finish(res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_new_for_bus_finish
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GDBusProxy *g_dbus_proxy_new_for_bus_sync (GBusType bus_type, GDBusProxyFlags flags, GDBusInterfaceInfo *info, const gchar *name, const gchar *object_path, const gchar *interface_name, GCancellable *cancellable, GError **error);
function g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path&
&, interface_name, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_dbus_proxy_new_for_bus_sync
  integer(c_int), value :: bus_type
  integer(c_int), value :: flags
  type(c_ptr), value :: info
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: object_path
  character(kind=c_char), dimension(*) :: interface_name
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! GDBusConnection *g_dbus_proxy_get_connection (GDBusProxy *proxy);
function g_dbus_proxy_get_connection(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_connection
  type(c_ptr), value :: proxy
end function

! GDBusProxyFlags g_dbus_proxy_get_flags (GDBusProxy *proxy);
function g_dbus_proxy_get_flags(proxy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_flags
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_name (GDBusProxy *proxy);
function g_dbus_proxy_get_name(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name
  type(c_ptr), value :: proxy
end function

! gchar *g_dbus_proxy_get_name_owner (GDBusProxy *proxy);
function g_dbus_proxy_get_name_owner(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_name_owner
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_object_path (GDBusProxy *proxy);
function g_dbus_proxy_get_object_path(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_object_path
  type(c_ptr), value :: proxy
end function

! const gchar *g_dbus_proxy_get_interface_name (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_name(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_name
  type(c_ptr), value :: proxy
end function

! gint g_dbus_proxy_get_default_timeout (GDBusProxy *proxy);
function g_dbus_proxy_get_default_timeout(proxy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_proxy_get_default_timeout
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_set_default_timeout (GDBusProxy *proxy, gint timeout_msec);
subroutine g_dbus_proxy_set_default_timeout(proxy, timeout_msec) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: proxy
  integer(c_int), value :: timeout_msec
end subroutine

! GDBusInterfaceInfo *g_dbus_proxy_get_interface_info (GDBusProxy *proxy);
function g_dbus_proxy_get_interface_info(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_interface_info
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_set_interface_info (GDBusProxy *proxy, GDBusInterfaceInfo *info);
subroutine g_dbus_proxy_set_interface_info(proxy, info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: proxy
  type(c_ptr), value :: info
end subroutine

! GVariant *g_dbus_proxy_get_cached_property (GDBusProxy *proxy, const gchar *property_name);
function g_dbus_proxy_get_cached_property(proxy, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dbus_proxy_get_cached_property
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
end function

! void g_dbus_proxy_set_cached_property (GDBusProxy *proxy, const gchar *property_name, GVariant *value);
subroutine g_dbus_proxy_set_cached_property(proxy, property_name, value) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! gchar **g_dbus_proxy_get_cached_property_names (GDBusProxy *proxy);
function g_dbus_proxy_get_cached_property_names(proxy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_get_cached_property_names
  type(c_ptr), value :: proxy
end function

! void g_dbus_proxy_call (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_dbus_proxy_call(proxy, method_name, parameters, flags, timeout_mse&
&c, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GVariant *g_dbus_proxy_call_finish (GDBusProxy *proxy, GAsyncResult *res, GError **error);
function g_dbus_proxy_call_finish(proxy, res, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_proxy_call_finish
  type(c_ptr), value :: proxy
  type(c_ptr), value :: res
  type(c_ptr), value :: error
end function

! GVariant *g_dbus_proxy_call_sync (GDBusProxy *proxy, const gchar *method_name, GVariant *parameters, GDBusCallFlags flags, gint timeout_msec, GCancellable *cancellable, GError **error);
function g_dbus_proxy_call_sync(proxy, method_name, parameters, flags, timeout_&
&msec, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dbus_proxy_call_sync
  type(c_ptr), value :: proxy
  character(kind=c_char), dimension(*) :: method_name
  type(c_ptr), value :: parameters
  integer(c_int), value :: flags
  integer(c_int), value :: timeout_msec
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!   GType g_memory_input_stream_get_type (void) G_GNUC_CONST;
function g_memory_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_memory_input_stream_get_type
end function

! GInputStream * g_memory_input_stream_new (void);
function g_memory_input_stream_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_input_stream_new
end function

! GInputStream * g_memory_input_stream_new_from_data (const void *data, gssize len, GDestroyNotify destroy);
function g_memory_input_stream_new_from_data(data, len, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr) :: g_memory_input_stream_new_from_data
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end function

! void g_memory_input_stream_add_data (GMemoryInputStream *stream, const void *data, gssize len, GDestroyNotify destroy);
subroutine g_memory_input_stream_add_data(stream, data, len, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_funptr
  type(c_ptr), value :: stream
  type(c_ptr), value :: data
  integer(c_size_t), value :: len
  type(c_funptr), value :: destroy
end subroutine

!   GType g_settings_backend_get_type (void);
function g_settings_backend_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_backend_get_type
end function

!  void g_settings_backend_changed (GSettingsBackend *backend, const gchar *key, gpointer origin_tag);
subroutine g_settings_backend_changed(backend, key, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: origin_tag
end subroutine

! void g_settings_backend_path_changed (GSettingsBackend *backend, const gchar *path, gpointer origin_tag);
subroutine g_settings_backend_path_changed(backend, path, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  type(c_ptr), value :: origin_tag
end subroutine

! void g_settings_backend_flatten_tree (GTree *tree, gchar **path, const gchar ***keys, GVariant ***values);
subroutine g_settings_backend_flatten_tree(tree, path, keys, values) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), dimension(*) :: path
  type(c_ptr), dimension(*) :: keys
  type(c_ptr), value :: values
end subroutine

! void g_settings_backend_keys_changed (GSettingsBackend *backend, const gchar *path, gchar const * const *items, gpointer origin_tag);
subroutine g_settings_backend_keys_changed(backend, path, items, origin_tag) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
  character(kind=c_char), dimension(*) :: items
  type(c_ptr), value :: origin_tag
end subroutine

!  void g_settings_backend_path_writable_changed (GSettingsBackend *backend, const gchar *path);
subroutine g_settings_backend_path_writable_changed(backend, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end subroutine

! void g_settings_backend_writable_changed (GSettingsBackend *backend, const gchar *key);
subroutine g_settings_backend_writable_changed(backend, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: key
end subroutine

! void g_settings_backend_changed_tree (GSettingsBackend *backend, GTree *tree, gpointer origin_tag);
subroutine g_settings_backend_changed_tree(backend, tree, origin_tag) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: backend
  type(c_ptr), value :: tree
  type(c_ptr), value :: origin_tag
end subroutine

!  GSettingsBackend * g_settings_backend_get_default (void);
function g_settings_backend_get_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_backend_get_default
end function

!  GSettingsBackend * g_keyfile_settings_backend_new (const gchar *filename, const gchar *root_path, const gchar *root_group);
function g_keyfile_settings_backend_new(filename, root_path, root_group) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_keyfile_settings_backend_new
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: root_path
  character(kind=c_char), dimension(*) :: root_group
end function

!  GSettingsBackend * g_null_settings_backend_new (void);
function g_null_settings_backend_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_null_settings_backend_new
end function

!  GSettingsBackend * g_memory_settings_backend_new (void);
function g_memory_settings_backend_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_memory_settings_backend_new
end function

!   GType g_settings_get_type (void);
function g_settings_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_settings_get_type
end function

!  const gchar * const * g_settings_list_schemas (void);
function g_settings_list_schemas() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_schemas
end function

! const gchar * const * g_settings_list_relocatable_schemas (void);
function g_settings_list_relocatable_schemas() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_relocatable_schemas
end function

! GSettings * g_settings_new (const gchar *schema);
function g_settings_new(schema) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new
  character(kind=c_char), dimension(*) :: schema
end function

! GSettings * g_settings_new_with_path (const gchar *schema, const gchar *path);
function g_settings_new_with_path(schema, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_path
  character(kind=c_char), dimension(*) :: schema
  character(kind=c_char), dimension(*) :: path
end function

! GSettings * g_settings_new_with_backend (const gchar *schema, GSettingsBackend *backend);
function g_settings_new_with_backend(schema, backend) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend
  character(kind=c_char), dimension(*) :: schema
  type(c_ptr), value :: backend
end function

! GSettings * g_settings_new_with_backend_and_path (const gchar *schema, GSettingsBackend *backend, const gchar *path);
function g_settings_new_with_backend_and_path(schema, backend, path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_new_with_backend_and_path
  character(kind=c_char), dimension(*) :: schema
  type(c_ptr), value :: backend
  character(kind=c_char), dimension(*) :: path
end function

! gchar ** g_settings_list_children (GSettings *settings);
function g_settings_list_children(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_children
  type(c_ptr), value :: settings
end function

! gchar ** g_settings_list_keys (GSettings *settings);
function g_settings_list_keys(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_settings_list_keys
  type(c_ptr), value :: settings
end function

! GVariant * g_settings_get_range (GSettings *settings, const gchar *key);
function g_settings_get_range(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_range
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_range_check (GSettings *settings, const gchar *key, GVariant *value);
function g_settings_range_check(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_range_check
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end function

!  gboolean g_settings_set_value (GSettings *settings, const gchar *key, GVariant *value);
function g_settings_set_value(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: value
end function

! GVariant * g_settings_get_value (GSettings *settings, const gchar *key);
function g_settings_get_value(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_value
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! void g_settings_reset (GSettings *settings, const gchar *key);
subroutine g_settings_reset(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end subroutine

!  gint g_settings_get_int (GSettings *settings, const gchar *key);
function g_settings_get_int(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_int (GSettings *settings, const gchar *key, gint value);
function g_settings_set_int(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! gchar * g_settings_get_string (GSettings *settings, const gchar *key);
function g_settings_get_string(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_string (GSettings *settings, const gchar *key, const gchar *value);
function g_settings_set_string(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_string
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! gboolean g_settings_get_boolean (GSettings *settings, const gchar *key);
function g_settings_get_boolean(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_boolean (GSettings *settings, const gchar *key, gboolean value);
function g_settings_set_boolean(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_boolean
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! gdouble g_settings_get_double (GSettings *settings, const gchar *key);
function g_settings_get_double(settings, key) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: g_settings_get_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_double (GSettings *settings, const gchar *key, gdouble value);
function g_settings_set_double(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_double
  integer(c_int) :: g_settings_set_double
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end function

! gchar ** g_settings_get_strv (GSettings *settings, const gchar *key);
function g_settings_get_strv(settings, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_strv (GSettings *settings, const gchar *key, const gchar *const *value);
function g_settings_set_strv(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_strv
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end function

! gint g_settings_get_enum (GSettings *settings, const gchar *key);
function g_settings_get_enum(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_enum (GSettings *settings, const gchar *key, gint value);
function g_settings_set_enum(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_enum
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! guint g_settings_get_flags (GSettings *settings, const gchar *key);
function g_settings_get_flags(settings, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_get_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
end function

! gboolean g_settings_set_flags (GSettings *settings, const gchar *key, guint value);
function g_settings_set_flags(settings, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_set_flags
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end function

! GSettings * g_settings_get_child (GSettings *settings, const gchar *name);
function g_settings_get_child(settings, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_settings_get_child
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

!  gboolean g_settings_is_writable (GSettings *settings, const gchar *name);
function g_settings_is_writable(settings, name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_settings_is_writable
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: name
end function

!  void g_settings_delay (GSettings *settings);
subroutine g_settings_delay(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! void g_settings_apply (GSettings *settings);
subroutine g_settings_apply(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! void g_settings_revert (GSettings *settings);
subroutine g_settings_revert(settings) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: settings
end subroutine

! gboolean g_settings_get_has_unapplied (GSettings *settings);
function g_settings_get_has_unapplied(settings) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_settings_get_has_unapplied
  type(c_ptr), value :: settings
end function

! void g_settings_sync (void);
subroutine g_settings_sync() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_settings_bind (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags);
subroutine g_settings_bind(settings, key, object, property, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
end subroutine

! void g_settings_bind_with_mapping (GSettings *settings, const gchar *key, gpointer object, const gchar *property, GSettingsBindFlags flags, GSettingsBindGetMapping get_mapping, GSettingsBindSetMapping set_mapping, gpointer user_data, GDestroyNotify destroy);
subroutine g_settings_bind_with_mapping(settings, key, object, property, flags,&
& get_mapping, set_mapping, user_data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: flags
  type(c_funptr), value :: get_mapping
  type(c_funptr), value :: set_mapping
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end subroutine

! void g_settings_bind_writable (GSettings *settings, const gchar *key, gpointer object, const gchar *property, gboolean inverted);
subroutine g_settings_bind_writable(settings, key, object, property, inverted) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
  integer(c_int), value :: inverted
end subroutine

! void g_settings_unbind (gpointer object, const gchar *property);
subroutine g_settings_unbind(object, property) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property
end subroutine

!  gpointer g_settings_get_mapped (GSettings *settings, const gchar *key, GSettingsGetMapping mapping, gpointer user_data);
function g_settings_get_mapped(settings, key, mapping, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_settings_get_mapped
  type(c_ptr), value :: settings
  character(kind=c_char), dimension(*) :: key
  type(c_funptr), value :: mapping
  type(c_ptr), value :: user_data
end function

!   GType g_permission_get_type (void);
function g_permission_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_permission_get_type
end function

! gboolean g_permission_acquire (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_acquire(permission, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_acquire
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_permission_acquire_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_acquire_async(permission, cancellable, callback, user_d&
&ata) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_permission_acquire_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_acquire_finish(permission, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_acquire_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_permission_release (GPermission *permission, GCancellable *cancellable, GError **error);
function g_permission_release(permission, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_release
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_permission_release_async (GPermission *permission, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_permission_release_async(permission, cancellable, callback, user_d&
&ata) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: permission
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_permission_release_finish (GPermission *permission, GAsyncResult *result, GError **error);
function g_permission_release_finish(permission, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_release_finish
  type(c_ptr), value :: permission
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!  gboolean g_permission_get_allowed (GPermission *permission);
function g_permission_get_allowed(permission) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_get_allowed
  type(c_ptr), value :: permission
end function

! gboolean g_permission_get_can_acquire (GPermission *permission);
function g_permission_get_can_acquire(permission) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_get_can_acquire
  type(c_ptr), value :: permission
end function

! gboolean g_permission_get_can_release (GPermission *permission);
function g_permission_get_can_release(permission) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_permission_get_can_release
  type(c_ptr), value :: permission
end function

!  void g_permission_impl_update (GPermission *permission, gboolean allowed, gboolean can_acquire, gboolean can_release);
subroutine g_permission_impl_update(permission, allowed, can_acquire, can_relea&
&se) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: permission
  integer(c_int), value :: allowed
  integer(c_int), value :: can_acquire
  integer(c_int), value :: can_release
end subroutine

!   GType g_pollable_input_stream_get_type (void) G_GNUC_CONST;
function g_pollable_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_pollable_input_stream_get_type
end function

!  gboolean g_pollable_input_stream_can_poll (GPollableInputStream *stream);
function g_pollable_input_stream_can_poll(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_pollable_input_stream_can_poll
  type(c_ptr), value :: stream
end function

!  gboolean g_pollable_input_stream_is_readable (GPollableInputStream *stream);
function g_pollable_input_stream_is_readable(stream) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_pollable_input_stream_is_readable
  type(c_ptr), value :: stream
end function

! GSource *g_pollable_input_stream_create_source (GPollableInputStream *stream, GCancellable *cancellable);
function g_pollable_input_stream_create_source(stream, cancellable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_pollable_input_stream_create_source
  type(c_ptr), value :: stream
  type(c_ptr), value :: cancellable
end function

!  gssize g_pollable_input_stream_read_nonblocking (GPollableInputStream *stream, void *buffer, gsize size, GCancellable *cancellable, GError **error);
function g_pollable_input_stream_read_nonblocking(stream, buffer, size, cancell&
&able, error) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_pollable_input_stream_read_nonblocking
  type(c_ptr), value :: stream
  type(c_ptr), value :: buffer
  integer(c_size_t), value :: size
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

!  GSource *g_pollable_source_new (GObject *pollable_stream);
function g_pollable_source_new(pollable_stream) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_pollable_source_new
  type(c_ptr), value :: pollable_stream
end function

!   GType g_file_input_stream_get_type (void) G_GNUC_CONST;
function g_file_input_stream_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_input_stream_get_type
end function

!  GFileInfo *g_file_input_stream_query_info (GFileInputStream *stream, const char *attributes, GCancellable *cancellable, GError **error);
function g_file_input_stream_query_info(stream, attributes, cancellable, error)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_input_stream_query_info
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_input_stream_query_info_async (GFileInputStream *stream, const char *attributes, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_input_stream_query_info_async(stream, attributes, io_priority&
&, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr), value :: stream
  character(kind=c_char), dimension(*) :: attributes
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GFileInfo *g_file_input_stream_query_info_finish (GFileInputStream *stream, GAsyncResult *result, GError **error);
function g_file_input_stream_query_info_finish(stream, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_input_stream_query_info_finish
  type(c_ptr), value :: stream
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

!   GType g_charset_converter_get_type (void) G_GNUC_CONST;
function g_charset_converter_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_charset_converter_get_type
end function

!  GCharsetConverter *g_charset_converter_new (const gchar *to_charset, const gchar *from_charset, GError **error);
function g_charset_converter_new(to_charset, from_charset, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_charset_converter_new
  character(kind=c_char), dimension(*) :: to_charset
  character(kind=c_char), dimension(*) :: from_charset
  type(c_ptr), value :: error
end function

! void g_charset_converter_set_use_fallback (GCharsetConverter *converter, gboolean use_fallback);
subroutine g_charset_converter_set_use_fallback(converter, use_fallback) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: converter
  integer(c_int), value :: use_fallback
end subroutine

! gboolean g_charset_converter_get_use_fallback (GCharsetConverter *converter);
function g_charset_converter_get_use_fallback(converter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_charset_converter_get_use_fallback
  type(c_ptr), value :: converter
end function

! guint g_charset_converter_get_num_fallbacks (GCharsetConverter *converter);
function g_charset_converter_get_num_fallbacks(converter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_charset_converter_get_num_fallbacks
  type(c_ptr), value :: converter
end function

!   GType g_dbus_auth_observer_get_type (void) G_GNUC_CONST;
function g_dbus_auth_observer_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_dbus_auth_observer_get_type
end function

! GDBusAuthObserver *g_dbus_auth_observer_new (void);
function g_dbus_auth_observer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_auth_observer_new
end function

! gboolean g_dbus_auth_observer_authorize_authenticated_peer (GDBusAuthObserver *observer, GIOStream *stream, GCredentials *credentials);
function g_dbus_auth_observer_authorize_authenticated_peer(observer, stream, cr&
&edentials) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_dbus_auth_observer_authorize_authenticated_peer
  type(c_ptr), value :: observer
  type(c_ptr), value :: stream
  type(c_ptr), value :: credentials
end function

!   gboolean g_dbus_is_guid (const gchar *string);
function g_dbus_is_guid(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_guid
  character(kind=c_char), dimension(*) :: string
end function

! gchar *g_dbus_generate_guid (void);
function g_dbus_generate_guid() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_dbus_generate_guid
end function

!  gboolean g_dbus_is_name (const gchar *string);
function g_dbus_is_name(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_unique_name (const gchar *string);
function g_dbus_is_unique_name(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_unique_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_member_name (const gchar *string);
function g_dbus_is_member_name(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_member_name
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_dbus_is_interface_name (const gchar *string);
function g_dbus_is_interface_name(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_dbus_is_interface_name
  character(kind=c_char), dimension(*) :: string
end function

!   GType g_simple_permission_get_type (void);
function g_simple_permission_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_simple_permission_get_type
end function

! GPermission * g_simple_permission_new (gboolean allowed);
function g_simple_permission_new(allowed) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_simple_permission_new
  integer(c_int), value :: allowed
end function

!   GType g_action_group_get_type (void) G_GNUC_CONST;
function g_action_group_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_action_group_get_type
end function

!  gboolean g_action_group_has_action (GActionGroup *action_group, const gchar *action_name);
function g_action_group_has_action(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_action_group_has_action
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! gchar ** g_action_group_list_actions (GActionGroup *action_group);
function g_action_group_list_actions(action_group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_action_group_list_actions
  type(c_ptr), value :: action_group
end function

!  const GVariantType * g_action_group_get_action_parameter_type (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_parameter_type(action_group, action_name) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_parameter_type
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! const GVariantType * g_action_group_get_action_state_type (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state_type(action_group, action_name) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state_type
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! GVariant * g_action_group_get_action_state_hint (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state_hint(action_group, action_name) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state_hint
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

!  gboolean g_action_group_get_action_enabled (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_enabled(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_action_group_get_action_enabled
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

!  GVariant * g_action_group_get_action_state (GActionGroup *action_group, const gchar *action_name);
function g_action_group_get_action_state(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_action_group_get_action_state
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end function

! void g_action_group_change_action_state (GActionGroup *action_group, const gchar *action_name, GVariant *value);
subroutine g_action_group_change_action_state(action_group, action_name, value)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: value
end subroutine

!  void g_action_group_activate_action (GActionGroup *action_group, const gchar *action_name, GVariant *parameter);
subroutine g_action_group_activate_action(action_group, action_name, parameter)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: parameter
end subroutine

!  void g_action_group_action_added (GActionGroup *action_group, const gchar *action_name);
subroutine g_action_group_action_added(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! void g_action_group_action_removed (GActionGroup *action_group, const gchar *action_name);
subroutine g_action_group_action_removed(action_group, action_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
end subroutine

! void g_action_group_action_enabled_changed (GActionGroup *action_group, const gchar *action_name, gboolean enabled);
subroutine g_action_group_action_enabled_changed(action_group, action_name, ena&
&bled) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  integer(c_int), value :: enabled
end subroutine

!  void g_action_group_action_state_changed (GActionGroup *action_group, const gchar *action_name, GVariant *state);
subroutine g_action_group_action_state_changed(action_group, action_name, state&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: action_group
  character(kind=c_char), dimension(*) :: action_name
  type(c_ptr), value :: state
end subroutine

!   GType g_file_enumerator_get_type (void) G_GNUC_CONST;
function g_file_enumerator_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_file_enumerator_get_type
end function

!  GFileInfo *g_file_enumerator_next_file (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_next_file(enumerator, cancellable, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_next_file
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! gboolean g_file_enumerator_close (GFileEnumerator *enumerator, GCancellable *cancellable, GError **error);
function g_file_enumerator_close(enumerator, cancellable, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_close
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: cancellable
  type(c_ptr), value :: error
end function

! void g_file_enumerator_next_files_async (GFileEnumerator *enumerator, int num_files, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_next_files_async(enumerator, num_files, io_priorit&
&y, cancellable, callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: num_files
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! GList * g_file_enumerator_next_files_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_next_files_finish(enumerator, result, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_next_files_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! void g_file_enumerator_close_async (GFileEnumerator *enumerator, int io_priority, GCancellable *cancellable, GAsyncReadyCallback callback, gpointer user_data);
subroutine g_file_enumerator_close_async(enumerator, io_priority, cancellable, &
&callback, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: enumerator
  integer(c_int), value :: io_priority
  type(c_ptr), value :: cancellable
  type(c_funptr), value :: callback
  type(c_ptr), value :: user_data
end subroutine

! gboolean g_file_enumerator_close_finish (GFileEnumerator *enumerator, GAsyncResult *result, GError **error);
function g_file_enumerator_close_finish(enumerator, result, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_close_finish
  type(c_ptr), value :: enumerator
  type(c_ptr), value :: result
  type(c_ptr), value :: error
end function

! gboolean g_file_enumerator_is_closed (GFileEnumerator *enumerator);
function g_file_enumerator_is_closed(enumerator) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_is_closed
  type(c_ptr), value :: enumerator
end function

! gboolean g_file_enumerator_has_pending (GFileEnumerator *enumerator);
function g_file_enumerator_has_pending(enumerator) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_file_enumerator_has_pending
  type(c_ptr), value :: enumerator
end function

! void g_file_enumerator_set_pending (GFileEnumerator *enumerator, gboolean pending);
subroutine g_file_enumerator_set_pending(enumerator, pending) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: enumerator
  integer(c_int), value :: pending
end subroutine

! GFile * g_file_enumerator_get_container (GFileEnumerator *enumerator);
function g_file_enumerator_get_container(enumerator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_file_enumerator_get_container
  type(c_ptr), value :: enumerator
end function

!   GType g_tls_client_connection_get_type (void) G_GNUC_CONST;
function g_tls_client_connection_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_tls_client_connection_get_type
end function

!  GIOStream * g_tls_client_connection_new (GIOStream *base_io_stream, GSocketConnectable *server_identity, GError **error);
function g_tls_client_connection_new(base_io_stream, server_identity, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_client_connection_new
  type(c_ptr), value :: base_io_stream
  type(c_ptr), value :: server_identity
  type(c_ptr), value :: error
end function

!  GTlsCertificateFlags g_tls_client_connection_get_validation_flags (GTlsClientConnection *conn);
function g_tls_client_connection_get_validation_flags(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_client_connection_get_validation_flags
  type(c_ptr), value :: conn
end function

! void g_tls_client_connection_set_validation_flags (GTlsClientConnection *conn, GTlsCertificateFlags flags);
subroutine g_tls_client_connection_set_validation_flags(conn, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: flags
end subroutine

! GSocketConnectable *g_tls_client_connection_get_server_identity (GTlsClientConnection *conn);
function g_tls_client_connection_get_server_identity(conn) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_client_connection_get_server_identity
  type(c_ptr), value :: conn
end function

! void g_tls_client_connection_set_server_identity (GTlsClientConnection *conn, GSocketConnectable *identity);
subroutine g_tls_client_connection_set_server_identity(conn, identity) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: conn
  type(c_ptr), value :: identity
end subroutine

! gboolean g_tls_client_connection_get_use_ssl3 (GTlsClientConnection *conn);
function g_tls_client_connection_get_use_ssl3(conn) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tls_client_connection_get_use_ssl3
  type(c_ptr), value :: conn
end function

! void g_tls_client_connection_set_use_ssl3 (GTlsClientConnection *conn, gboolean use_ssl3);
subroutine g_tls_client_connection_set_use_ssl3(conn, use_ssl3) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: conn
  integer(c_int), value :: use_ssl3
end subroutine

! GList * g_tls_client_connection_get_accepted_cas (GTlsClientConnection *conn);
function g_tls_client_connection_get_accepted_cas(conn) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tls_client_connection_get_accepted_cas
  type(c_ptr), value :: conn
end function

!   GType g_themed_icon_get_type (void) G_GNUC_CONST;
function g_themed_icon_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_themed_icon_get_type
end function

!  GIcon *g_themed_icon_new (const char *iconname);
function g_themed_icon_new(iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new
  character(kind=c_char), dimension(*) :: iconname
end function

! GIcon *g_themed_icon_new_with_default_fallbacks (const char *iconname);
function g_themed_icon_new_with_default_fallbacks(iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_themed_icon_new_with_default_fallbacks
  character(kind=c_char), dimension(*) :: iconname
end function

! GIcon *g_themed_icon_new_from_names (char **iconnames, int len);
function g_themed_icon_new_from_names(iconnames, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_themed_icon_new_from_names
  type(c_ptr), dimension(*) :: iconnames
  integer(c_int), value :: len
end function

! void g_themed_icon_prepend_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_prepend_name(icon, iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

! void g_themed_icon_append_name (GThemedIcon *icon, const char *iconname);
subroutine g_themed_icon_append_name(icon, iconname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: icon
  character(kind=c_char), dimension(*) :: iconname
end subroutine

!  const gchar* const * g_themed_icon_get_names (GThemedIcon *icon);
function g_themed_icon_get_names(icon) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_themed_icon_get_names
  type(c_ptr), value :: icon
end function

!   GList* g_list_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_list_alloc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_alloc
end function

! void g_list_free (GList *list);
subroutine g_list_free(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void g_list_free_1 (GList *list);
subroutine g_list_free_1(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

!  void g_list_free_full (GList *list, GDestroyNotify free_func);
subroutine g_list_free_full(list, free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: free_func
end subroutine

! GList* g_list_append (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_append(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_prepend (GList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_prepend(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_insert (GList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert(list, data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GList* g_list_insert_sorted (GList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GList* g_list_insert_sorted_with_data (GList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_sorted_with_data(list, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GList* g_list_insert_before (GList *list, GList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_insert_before(list, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_insert_before
  type(c_ptr), value :: list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GList* g_list_concat (GList *list1, GList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_list_concat(list1, list2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GList* g_list_remove (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_remove_all (GList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_all(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_remove_link (GList *list, GList *llink) G_GNUC_WARN_UNUSED_RESULT;
function g_list_remove_link(list, llink) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! GList* g_list_delete_link (GList *list, GList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_list_delete_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GList* g_list_reverse (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_reverse(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_reverse
  type(c_ptr), value :: list
end function

! GList* g_list_copy (GList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_list_copy(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_copy
  type(c_ptr), value :: list
end function

! GList* g_list_nth (GList *list, guint n);
function g_list_nth(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GList* g_list_nth_prev (GList *list, guint n);
function g_list_nth_prev(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth_prev
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GList* g_list_find (GList *list, gconstpointer data);
function g_list_find(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_find_custom (GList *list, gconstpointer data, GCompareFunc func);
function g_list_find_custom(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! gint g_list_position (GList *list, GList *llink);
function g_list_position(list, llink) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! gint g_list_index (GList *list, gconstpointer data);
function g_list_index(list, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GList* g_list_last (GList *list);
function g_list_last(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_last
  type(c_ptr), value :: list
end function

! GList* g_list_first (GList *list);
function g_list_first(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_list_first
  type(c_ptr), value :: list
end function

! guint g_list_length (GList *list);
function g_list_length(list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_list_length
  type(c_ptr), value :: list
end function

! void g_list_foreach (GList *list, GFunc func, gpointer user_data);
subroutine g_list_foreach(list, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GList* g_list_sort (GList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort(list, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GList* g_list_sort_with_data (GList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_list_sort_with_data(list, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_list_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! gpointer g_list_nth_data (GList *list, guint n);
function g_list_nth_data(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_list_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

!  void g_list_push_allocator (gpointer allocator);
subroutine g_list_push_allocator(allocator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: allocator
end subroutine

! void g_list_pop_allocator (void);
subroutine g_list_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GMappedFile *g_mapped_file_new (const gchar *filename, gboolean writable, GError **error) G_GNUC_MALLOC;
function g_mapped_file_new(filename, writable, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_mapped_file_new
  character(kind=c_char), dimension(*) :: filename
  integer(c_int), value :: writable
  type(c_ptr), value :: error
end function

! gsize g_mapped_file_get_length (GMappedFile *file);
function g_mapped_file_get_length(file) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_mapped_file_get_length
  type(c_ptr), value :: file
end function

! gchar *g_mapped_file_get_contents (GMappedFile *file);
function g_mapped_file_get_contents(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mapped_file_get_contents
  type(c_ptr), value :: file
end function

! GMappedFile *g_mapped_file_ref (GMappedFile *file);
function g_mapped_file_ref(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mapped_file_ref
  type(c_ptr), value :: file
end function

! void g_mapped_file_unref (GMappedFile *file);
subroutine g_mapped_file_unref(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: file
end subroutine

!  void g_mapped_file_free (GMappedFile *file);
subroutine g_mapped_file_free(file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: file
end subroutine

!   GQuark g_file_error_quark (void);
function g_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_file_error_quark
end function

!  GFileError g_file_error_from_errno (gint err_no);
function g_file_error_from_errno(err_no) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_file_error_from_errno
  integer(c_int), value :: err_no
end function

! gboolean g_file_set_contents (const gchar *filename, const gchar *contents, gssize length, GError **error);
function g_file_set_contents(filename, contents, length, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_file_set_contents
  character(kind=c_char), dimension(*) :: filename
  character(kind=c_char), dimension(*) :: contents
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! gchar *g_file_read_link (const gchar *filename, GError **error);
function g_file_read_link(filename, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_file_read_link
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! gint g_mkstemp_full (gchar *tmpl, int flags, int mode);
function g_mkstemp_full(tmpl, flags, mode) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_mkstemp_full
  character(kind=c_char), dimension(*) :: tmpl
  integer(c_int), value :: flags
  integer(c_int), value :: mode
end function

!  char *g_format_size_for_display (goffset size);
function g_format_size_for_display(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_format_size_for_display
  integer(c_int64_t), value :: size
end function

! gchar *g_build_pathv (const gchar *separator, gchar **args) G_GNUC_MALLOC;
function g_build_pathv(separator, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_build_pathv
  character(kind=c_char), dimension(*) :: separator
  type(c_ptr), dimension(*) :: args
end function

! gchar *g_build_filenamev (gchar **args) G_GNUC_MALLOC;
function g_build_filenamev(args) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_build_filenamev
  type(c_ptr), dimension(*) :: args
end function

!  int g_mkdir_with_parents (const gchar *pathname, int mode);
function g_mkdir_with_parents(pathname, mode) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_mkdir_with_parents
  character(kind=c_char), dimension(*) :: pathname
  integer(c_int), value :: mode
end function

!   guint g_spaced_primes_closest (guint num) G_GNUC_CONST;
function g_spaced_primes_closest(num) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_spaced_primes_closest
  integer(c_int), value :: num
end function

!   void g_bit_lock (volatile gint *address, gint lock_bit);
subroutine g_bit_lock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

! gboolean g_bit_trylock (volatile gint *address, gint lock_bit);
function g_bit_trylock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_bit_trylock
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end function

! void g_bit_unlock (volatile gint *address, gint lock_bit);
subroutine g_bit_unlock(address, lock_bit) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: address
  integer(c_int), value :: lock_bit
end subroutine

!   gssize g_checksum_type_get_length (GChecksumType checksum_type);
function g_checksum_type_get_length(checksum_type) bind(c) 
  use iso_c_binding, only: c_size_t, c_int
  integer(c_size_t) :: g_checksum_type_get_length
  integer(c_int), value :: checksum_type
end function

!  GChecksum * g_checksum_new (GChecksumType checksum_type);
function g_checksum_new(checksum_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_checksum_new
  integer(c_int), value :: checksum_type
end function

! void g_checksum_reset (GChecksum *checksum);
subroutine g_checksum_reset(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! GChecksum * g_checksum_copy (const GChecksum *checksum);
function g_checksum_copy(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_checksum_copy
  type(c_ptr), value :: checksum
end function

! void g_checksum_free (GChecksum *checksum);
subroutine g_checksum_free(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
end subroutine

! void g_checksum_update (GChecksum *checksum, const guchar *data, gssize length);
subroutine g_checksum_update(checksum, data, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: checksum
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end subroutine

! G_CONST_RETURN gchar *g_checksum_get_string (GChecksum *checksum);
function g_checksum_get_string(checksum) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_checksum_get_string
  type(c_ptr), value :: checksum
end function

! void g_checksum_get_digest (GChecksum *checksum, guint8 *buffer, gsize *digest_len);
subroutine g_checksum_get_digest(checksum, buffer, digest_len) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: checksum
  type(c_ptr), value :: buffer
  type(c_ptr), value :: digest_len
end subroutine

!  gchar *g_compute_checksum_for_data (GChecksumType checksum_type, const guchar *data, gsize length);
function g_compute_checksum_for_data(checksum_type, data, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_data
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
end function

! gchar *g_compute_checksum_for_string (GChecksumType checksum_type, const gchar *str, gssize length);
function g_compute_checksum_for_string(checksum_type, str, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char, c_size_t
  type(c_ptr) :: g_compute_checksum_for_string
  integer(c_int), value :: checksum_type
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: length
end function

!   gsize g_base64_encode_step (const guchar *in, gsize len, gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_step(in, len, break_lines, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_int, c_ptr
  integer(c_size_t) :: g_base64_encode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  integer(c_int), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! gsize g_base64_encode_close (gboolean break_lines, gchar *out, gint *state, gint *save);
function g_base64_encode_close(break_lines, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_int, c_char, c_ptr
  integer(c_size_t) :: g_base64_encode_close
  integer(c_int), value :: break_lines
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! gchar* g_base64_encode (const guchar *data, gsize len) G_GNUC_MALLOC;
function g_base64_encode(data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_base64_encode
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: len
end function

! gsize g_base64_decode_step (const gchar *in, gsize len, guchar *out, gint *state, guint *save);
function g_base64_decode_step(in, len, out, state, save) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_base64_decode_step
  character(kind=c_char), dimension(*) :: in
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: out
  type(c_ptr), value :: state
  type(c_ptr), value :: save
end function

! guchar *g_base64_decode (const gchar *text, gsize *out_len) G_GNUC_MALLOC;
function g_base64_decode(text, out_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_base64_decode
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

! guchar *g_base64_decode_inplace (gchar *text, gsize *out_len);
function g_base64_decode_inplace(text, out_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_base64_decode_inplace
  character(kind=c_char), dimension(*) :: text
  type(c_ptr), value :: out_len
end function

!   GQuark g_shell_error_quark (void);
function g_shell_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_shell_error_quark
end function

!  gchar* g_shell_quote (const gchar *unquoted_string);
function g_shell_quote(unquoted_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_shell_quote
  character(kind=c_char), dimension(*) :: unquoted_string
end function

! gchar* g_shell_unquote (const gchar *quoted_string, GError **error);
function g_shell_unquote(quoted_string, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_shell_unquote
  character(kind=c_char), dimension(*) :: quoted_string
  type(c_ptr), value :: error
end function

! gboolean g_shell_parse_argv (const gchar *command_line, gint *argcp, gchar ***argvp, GError **error);
function g_shell_parse_argv(command_line, argcp, argvp, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_shell_parse_argv
  character(kind=c_char), dimension(*) :: command_line
  type(c_ptr), value :: argcp
  type(c_ptr), dimension(*) :: argvp
  type(c_ptr), value :: error
end function

!   void g_on_error_query (const gchar *prg_name);
subroutine g_on_error_query(prg_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

! void g_on_error_stack_trace (const gchar *prg_name);
subroutine g_on_error_stack_trace(prg_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prg_name
end subroutine

!   gint g_poll (GPollFD *fds, guint nfds, gint timeout);
function g_poll(fds, nfds, timeout) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_poll
  type(c_ptr), value :: fds
  integer(c_int), value :: nfds
  integer(c_int), value :: timeout
end function

!   void g_free (gpointer mem);
subroutine g_free(mem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem
end subroutine

!  gpointer g_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_malloc0(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc(mem, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_malloc (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_malloc0 (gsize n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_try_malloc0(n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0
  integer(c_size_t), value :: n_bytes
end function

! gpointer g_try_realloc (gpointer mem, gsize n_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc(mem, n_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_bytes
end function

!  gpointer g_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_malloc0_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_realloc_n(mem, n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_malloc_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_malloc0_n (gsize n_blocks, gsize n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
function g_try_malloc0_n(n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_malloc0_n
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

! gpointer g_try_realloc_n (gpointer mem, gsize n_blocks, gsize n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
function g_try_realloc_n(mem, n_blocks, n_block_bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_try_realloc_n
  type(c_ptr), value :: mem
  integer(c_size_t), value :: n_blocks
  integer(c_size_t), value :: n_block_bytes
end function

!  void g_mem_set_vtable (GMemVTable *vtable);
subroutine g_mem_set_vtable(vtable) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: vtable
end subroutine

! gboolean g_mem_is_system_malloc (void);
function g_mem_is_system_malloc() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_mem_is_system_malloc
end function

! void g_mem_profile (void);
subroutine g_mem_profile() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  GMemChunk* g_mem_chunk_new (const gchar *name, gint atom_size, gsize area_size, gint type);
function g_mem_chunk_new(name, atom_size, area_size, type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr) :: g_mem_chunk_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: atom_size
  integer(c_size_t), value :: area_size
  integer(c_int), value :: type
end function

! void g_mem_chunk_destroy (GMemChunk *mem_chunk);
subroutine g_mem_chunk_destroy(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
function g_mem_chunk_alloc(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc
  type(c_ptr), value :: mem_chunk
end function

! gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
function g_mem_chunk_alloc0(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_mem_chunk_alloc0
  type(c_ptr), value :: mem_chunk
end function

! void g_mem_chunk_free (GMemChunk *mem_chunk, gpointer mem);
subroutine g_mem_chunk_free(mem_chunk, mem) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
  type(c_ptr), value :: mem
end subroutine

! void g_mem_chunk_clean (GMemChunk *mem_chunk);
subroutine g_mem_chunk_clean(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_reset (GMemChunk *mem_chunk);
subroutine g_mem_chunk_reset(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_print (GMemChunk *mem_chunk);
subroutine g_mem_chunk_print(mem_chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mem_chunk
end subroutine

! void g_mem_chunk_info (void);
subroutine g_mem_chunk_info() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_blow_chunks (void);
subroutine g_blow_chunks() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GAllocator*g_allocator_new (const gchar *name, guint n_preallocs);
function g_allocator_new(name, n_preallocs) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_allocator_new
  character(kind=c_char), dimension(*) :: name
  integer(c_int), value :: n_preallocs
end function

! void g_allocator_free (GAllocator *allocator);
subroutine g_allocator_free(allocator) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: allocator
end subroutine

!   gsize g_printf_string_upper_bound (const gchar* format, va_list args);
function g_printf_string_upper_bound(format, args) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_printf_string_upper_bound
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  guint g_log_set_handler (const gchar *log_domain, GLogLevelFlags log_levels, GLogFunc log_func, gpointer user_data);
function g_log_set_handler(log_domain, log_levels, log_func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_funptr, c_ptr
  integer(c_int) :: g_log_set_handler
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_levels
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! void g_log_remove_handler (const gchar *log_domain, guint handler_id);
subroutine g_log_remove_handler(log_domain, handler_id) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: handler_id
end subroutine

! void g_log_default_handler (const gchar *log_domain, GLogLevelFlags log_level, const gchar *message, gpointer unused_data);
subroutine g_log_default_handler(log_domain, log_level, message, unused_data) b&
&ind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: message
  type(c_ptr), value :: unused_data
end subroutine

! GLogFunc g_log_set_default_handler (GLogFunc log_func, gpointer user_data);
function g_log_set_default_handler(log_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: g_log_set_default_handler
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end function

! void g_log (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
subroutine g_log() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_logv (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args);
subroutine g_logv(log_domain, log_level, format, args) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: log_level
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain, GLogLevelFlags fatal_mask);
function g_log_set_fatal_mask(log_domain, fatal_mask) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_log_set_fatal_mask
  character(kind=c_char), dimension(*) :: log_domain
  integer(c_int), value :: fatal_mask
end function

! GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
function g_log_set_always_fatal(fatal_mask) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_log_set_always_fatal
  integer(c_int), value :: fatal_mask
end function

!  void g_return_if_fail_warning (const char *log_domain, const char *pretty_function, const char *expression);
subroutine g_return_if_fail_warning(log_domain, pretty_function, expression) bi&
&nd(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: log_domain
  character(kind=c_char), dimension(*) :: pretty_function
  character(kind=c_char), dimension(*) :: expression
end subroutine

! void g_warn_message (const char *domain, const char *file, int line, const char *func, const char *warnexpr);
subroutine g_warn_message(domain, file, line, func, warnexpr) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: warnexpr
end subroutine

!      static void g_error (const gchar *format, ...)  static void g_message (const gchar *format, ...)  static void g_critical (const gchar *format, ...)  static void g_warning (const gchar *format, ...)  static void g_debug (const gchar *format, ...)  void g_print (const gchar *format, ...) G_GNUC_PRINTF (1, 2);
subroutine g_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GPrintFunc g_set_print_handler (GPrintFunc func);
function g_set_print_handler(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: g_set_print_handler
  type(c_funptr), value :: func
end function

! void g_printerr (const gchar *format, ...) G_GNUC_PRINTF (1, 2);
subroutine g_printerr() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GPrintFunc g_set_printerr_handler (GPrintFunc func);
function g_set_printerr_handler(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr) :: g_set_printerr_handler
  type(c_funptr), value :: func
end function

!   gpointer g_slice_alloc (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc(block_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc
  integer(c_size_t), value :: block_size
end function

! gpointer g_slice_alloc0 (gsize block_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_alloc0(block_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_alloc0
  integer(c_size_t), value :: block_size
end function

! gpointer g_slice_copy (gsize block_size, gconstpointer mem_block) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
function g_slice_copy(block_size, mem_block) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_slice_copy
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end function

! void g_slice_free1 (gsize block_size, gpointer mem_block);
subroutine g_slice_free1(block_size, mem_block) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_block
end subroutine

! void g_slice_free_chain_with_offset (gsize block_size, gpointer mem_chain, gsize next_offset);
subroutine g_slice_free_chain_with_offset(block_size, mem_chain, next_offset) b&
&ind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: block_size
  type(c_ptr), value :: mem_chain
  integer(c_size_t), value :: next_offset
end subroutine

!  void g_slice_set_config (GSliceConfig ckey, gint64 value);
subroutine g_slice_set_config(ckey, value) bind(c) 
  use iso_c_binding, only: c_int, c_int64_t
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: value
end subroutine

! gint64 g_slice_get_config (GSliceConfig ckey);
function g_slice_get_config(ckey) bind(c) 
  use iso_c_binding, only: c_int64_t, c_int
  integer(c_int64_t) :: g_slice_get_config
  integer(c_int), value :: ckey
end function

! gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);
function g_slice_get_config_state(ckey, address, n_values) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int64_t
  type(c_ptr) :: g_slice_get_config_state
  integer(c_int), value :: ckey
  integer(c_int64_t), value :: address
  type(c_ptr), value :: n_values
end function

!   GAsyncQueue* g_async_queue_new (void);
function g_async_queue_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_new
end function

!  GAsyncQueue* g_async_queue_new_full (GDestroyNotify item_free_func);
function g_async_queue_new_full(item_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_async_queue_new_full
  type(c_funptr), value :: item_free_func
end function

!  void g_async_queue_lock (GAsyncQueue *queue);
subroutine g_async_queue_lock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_async_queue_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unlock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  GAsyncQueue* g_async_queue_ref (GAsyncQueue *queue);
function g_async_queue_ref(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_ref
  type(c_ptr), value :: queue
end function

! void g_async_queue_unref (GAsyncQueue *queue);
subroutine g_async_queue_unref(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  void g_async_queue_ref_unlocked (GAsyncQueue *queue);
subroutine g_async_queue_ref_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_async_queue_unref_and_unlock (GAsyncQueue *queue);
subroutine g_async_queue_unref_and_unlock(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

!  void g_async_queue_push (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_async_queue_push_unlocked (GAsyncQueue *queue, gpointer data);
subroutine g_async_queue_push_unlocked(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

!  void g_async_queue_push_sorted (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted(queue, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_push_sorted_unlocked(queue, data, func, user_data) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_async_queue_pop (GAsyncQueue *queue);
function g_async_queue_pop(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_pop
  type(c_ptr), value :: queue
end function

! gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_pop_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_pop_unlocked
  type(c_ptr), value :: queue
end function

!  gpointer g_async_queue_try_pop (GAsyncQueue *queue);
function g_async_queue_try_pop(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_try_pop
  type(c_ptr), value :: queue
end function

! gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
function g_async_queue_try_pop_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_try_pop_unlocked
  type(c_ptr), value :: queue
end function

!  gpointer g_async_queue_timed_pop (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop(queue, end_time) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

! gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue, GTimeVal *end_time);
function g_async_queue_timed_pop_unlocked(queue, end_time) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_async_queue_timed_pop_unlocked
  type(c_ptr), value :: queue
  type(c_ptr), value :: end_time
end function

!  gint g_async_queue_length (GAsyncQueue *queue);
function g_async_queue_length(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_async_queue_length
  type(c_ptr), value :: queue
end function

! gint g_async_queue_length_unlocked (GAsyncQueue *queue);
function g_async_queue_length_unlocked(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_async_queue_length_unlocked
  type(c_ptr), value :: queue
end function

! void g_async_queue_sort (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_async_queue_sort_unlocked (GAsyncQueue *queue, GCompareDataFunc func, gpointer user_data);
subroutine g_async_queue_sort_unlocked(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!   GQuark g_convert_error_quark (void);
function g_convert_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_convert_error_quark
end function

!  GIConv g_iconv_open (const gchar *to_codeset, const gchar *from_codeset);
function g_iconv_open(to_codeset, from_codeset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_iconv_open
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
end function

! gsize g_iconv (GIConv converter, gchar **inbuf, gsize *inbytes_left, gchar **outbuf, gsize *outbytes_left);
function g_iconv(converter, inbuf, inbytes_left, outbuf, outbytes_left) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_iconv
  type(c_ptr), value :: converter
  type(c_ptr), dimension(*) :: inbuf
  type(c_ptr), value :: inbytes_left
  type(c_ptr), dimension(*) :: outbuf
  type(c_ptr), value :: outbytes_left
end function

! gint g_iconv_close (GIConv converter);
function g_iconv_close(converter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_iconv_close
  type(c_ptr), value :: converter
end function

!  gchar* g_convert (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert(str, len, to_codeset, from_codeset, bytes_read, bytes_writte&
&n, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_convert_with_iconv (const gchar *str, gssize len, GIConv converter, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_iconv(str, len, converter, bytes_read, bytes_written, e&
&rror) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_iconv
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  type(c_ptr), value :: converter
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_convert_with_fallback (const gchar *str, gssize len, const gchar *to_codeset, const gchar *from_codeset, const gchar *fallback, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_convert_with_fallback(str, len, to_codeset, from_codeset, fallback, &
&bytes_read, bytes_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_convert_with_fallback
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  character(kind=c_char), dimension(*) :: to_codeset
  character(kind=c_char), dimension(*) :: from_codeset
  character(kind=c_char), dimension(*) :: fallback
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

!  gchar* g_locale_to_utf8 (const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_to_utf8(opsysstring, len, bytes_read, bytes_written, error) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_to_utf8
  character(kind=c_char), dimension(*) :: opsysstring
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar* g_locale_from_utf8 (const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error) G_GNUC_MALLOC;
function g_locale_from_utf8(utf8string, len, bytes_read, bytes_written, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_locale_from_utf8
  character(kind=c_char), dimension(*) :: utf8string
  integer(c_size_t), value :: len
  type(c_ptr), value :: bytes_read
  type(c_ptr), value :: bytes_written
  type(c_ptr), value :: error
end function

! gchar *g_filename_display_name (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_name(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_display_name
  character(kind=c_char), dimension(*) :: filename
end function

! gboolean g_get_filename_charsets (G_CONST_RETURN gchar ***charsets);
function g_get_filename_charsets(charsets) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_get_filename_charsets
  type(c_ptr), dimension(*) :: charsets
end function

!  gchar *g_filename_display_basename (const gchar *filename) G_GNUC_MALLOC;
function g_filename_display_basename(filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_filename_display_basename
  character(kind=c_char), dimension(*) :: filename
end function

!  gchar **g_uri_list_extract_uris (const gchar *uri_list) G_GNUC_MALLOC;
function g_uri_list_extract_uris(uri_list) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_list_extract_uris
  character(kind=c_char), dimension(*) :: uri_list
end function

!   gboolean g_variant_type_string_is_valid (const gchar *type_string);
function g_variant_type_string_is_valid(type_string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_variant_type_string_is_valid
  character(kind=c_char), dimension(*) :: type_string
end function

! gboolean g_variant_type_string_scan (const gchar *string, const gchar *limit, const gchar **endptr);
function g_variant_type_string_scan(string, limit, endptr) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_variant_type_string_scan
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: limit
  type(c_ptr), dimension(*) :: endptr
end function

!  void g_variant_type_free (GVariantType *type);
subroutine g_variant_type_free(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: type
end subroutine

! GVariantType * g_variant_type_copy (const GVariantType *type);
function g_variant_type_copy(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_copy
  type(c_ptr), value :: type
end function

! GVariantType * g_variant_type_new (const gchar *type_string);
function g_variant_type_new(type_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_type_new
  character(kind=c_char), dimension(*) :: type_string
end function

!  gsize g_variant_type_get_string_length (const GVariantType *type);
function g_variant_type_get_string_length(type) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_get_string_length
  type(c_ptr), value :: type
end function

! const gchar * g_variant_type_peek_string (const GVariantType *type);
function g_variant_type_peek_string(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_peek_string
  type(c_ptr), value :: type
end function

! gchar * g_variant_type_dup_string (const GVariantType *type);
function g_variant_type_dup_string(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_dup_string
  type(c_ptr), value :: type
end function

!  gboolean g_variant_type_is_definite (const GVariantType *type);
function g_variant_type_is_definite(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_definite
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_container (const GVariantType *type);
function g_variant_type_is_container(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_container
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_basic (const GVariantType *type);
function g_variant_type_is_basic(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_basic
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_maybe (const GVariantType *type);
function g_variant_type_is_maybe(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_maybe
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_array (const GVariantType *type);
function g_variant_type_is_array(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_array
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_tuple (const GVariantType *type);
function g_variant_type_is_tuple(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_tuple
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_dict_entry (const GVariantType *type);
function g_variant_type_is_dict_entry(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_dict_entry
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_is_variant (const GVariantType *type);
function g_variant_type_is_variant(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_variant
  type(c_ptr), value :: type
end function

!  guint g_variant_type_hash (gconstpointer type);
function g_variant_type_hash(type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_hash
  type(c_ptr), value :: type
end function

! gboolean g_variant_type_equal (gconstpointer type1, gconstpointer type2);
function g_variant_type_equal(type1, type2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_equal
  type(c_ptr), value :: type1
  type(c_ptr), value :: type2
end function

!  gboolean g_variant_type_is_subtype_of (const GVariantType *type, const GVariantType *supertype);
function g_variant_type_is_subtype_of(type, supertype) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_type_is_subtype_of
  type(c_ptr), value :: type
  type(c_ptr), value :: supertype
end function

!  const GVariantType * g_variant_type_element (const GVariantType *type);
function g_variant_type_element(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_element
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_first (const GVariantType *type);
function g_variant_type_first(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_first
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_next (const GVariantType *type);
function g_variant_type_next(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_next
  type(c_ptr), value :: type
end function

! gsize g_variant_type_n_items (const GVariantType *type);
function g_variant_type_n_items(type) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_type_n_items
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_key (const GVariantType *type);
function g_variant_type_key(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_key
  type(c_ptr), value :: type
end function

! const GVariantType * g_variant_type_value (const GVariantType *type);
function g_variant_type_value(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_value
  type(c_ptr), value :: type
end function

!  GVariantType * g_variant_type_new_array (const GVariantType *element);
function g_variant_type_new_array(element) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_array
  type(c_ptr), value :: element
end function

! GVariantType * g_variant_type_new_maybe (const GVariantType *element);
function g_variant_type_new_maybe(element) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_maybe
  type(c_ptr), value :: element
end function

! GVariantType * g_variant_type_new_tuple (const GVariantType * const *items, gint length);
function g_variant_type_new_tuple(items, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_variant_type_new_tuple
  type(c_ptr), value :: items
  integer(c_int), value :: length
end function

! GVariantType * g_variant_type_new_dict_entry (const GVariantType *key, const GVariantType *value);
function g_variant_type_new_dict_entry(key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_type_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

!  const GVariantType * g_variant_type_checked_ (const gchar *);
function g_variant_type_checked_() bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_type_checked_
end function

!   int g_strcmp0 (const char *str1, const char *str2);
function g_strcmp0(str1, str2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strcmp0
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

!  void g_test_minimized_result (double minimized_quantity, const char *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_test_minimized_result() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_test_maximized_result (double maximized_quantity, const char *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_test_maximized_result() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  int g_test_run (void);
function g_test_run() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_test_run
end function

!  void g_test_add_func (const char *testpath, GTestFunc test_func);
subroutine g_test_add_func(testpath, test_func) bind(c) 
  use iso_c_binding, only: c_char, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_funptr), value :: test_func
end subroutine

!  void g_test_add_data_func (const char *testpath, gconstpointer test_data, GTestDataFunc test_func);
subroutine g_test_add_data_func(testpath, test_data, test_func) bind(c) 
  use iso_c_binding, only: c_char, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  type(c_ptr), value :: test_data
  type(c_funptr), value :: test_func
end subroutine

!  void g_test_message (const char *format, ...) G_GNUC_PRINTF (1, 2);
subroutine g_test_message() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_test_bug_base (const char *uri_pattern);
subroutine g_test_bug_base(uri_pattern) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: uri_pattern
end subroutine

! void g_test_bug (const char *bug_uri_snippet);
subroutine g_test_bug(bug_uri_snippet) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: bug_uri_snippet
end subroutine

!  void g_test_timer_start (void);
subroutine g_test_timer_start() bind(c) 
  use iso_c_binding, only: 
end subroutine

! double g_test_timer_elapsed (void);
function g_test_timer_elapsed() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_timer_elapsed
end function

! double g_test_timer_last (void);
function g_test_timer_last() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_timer_last
end function

!  void g_test_queue_free (gpointer gfree_pointer);
subroutine g_test_queue_free(gfree_pointer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: gfree_pointer
end subroutine

! void g_test_queue_destroy (GDestroyNotify destroy_func, gpointer destroy_data);
subroutine g_test_queue_destroy(destroy_func, destroy_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: destroy_func
  type(c_ptr), value :: destroy_data
end subroutine

!  gboolean g_test_trap_fork (guint64 usec_timeout, GTestTrapFlags test_trap_flags);
function g_test_trap_fork(usec_timeout, test_trap_flags) bind(c) 
  use iso_c_binding, only: c_int, c_int64_t
  integer(c_int) :: g_test_trap_fork
  integer(c_int64_t), value :: usec_timeout
  integer(c_int), value :: test_trap_flags
end function

! gboolean g_test_trap_has_passed (void);
function g_test_trap_has_passed() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_test_trap_has_passed
end function

! gboolean g_test_trap_reached_timeout (void);
function g_test_trap_reached_timeout() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_test_trap_reached_timeout
end function

!  gint32 g_test_rand_int (void);
function g_test_rand_int() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_test_rand_int
end function

! gint32 g_test_rand_int_range (gint32 begin, gint32 end);
function g_test_rand_int_range(begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_test_rand_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! double g_test_rand_double (void);
function g_test_rand_double() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_rand_double
end function

! double g_test_rand_double_range (double range_start, double range_end);
function g_test_rand_double_range(range_start, range_end) bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_test_rand_double_range
  real(c_double), value :: range_start
  real(c_double), value :: range_end
end function

!  GTestCase* g_test_create_case (const char *test_name, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
function g_test_create_case(test_name, data_size, test_data, data_setup, data_t&
&est, data_teardown) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_funptr
  type(c_ptr) :: g_test_create_case
  character(kind=c_char), dimension(*) :: test_name
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end function

! GTestSuite* g_test_create_suite (const char *suite_name);
function g_test_create_suite(suite_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_test_create_suite
  character(kind=c_char), dimension(*) :: suite_name
end function

! GTestSuite* g_test_get_root (void);
function g_test_get_root() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_get_root
end function

! void g_test_suite_add (GTestSuite *suite, GTestCase *test_case);
subroutine g_test_suite_add(suite, test_case) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: test_case
end subroutine

! void g_test_suite_add_suite (GTestSuite *suite, GTestSuite *nestedsuite);
subroutine g_test_suite_add_suite(suite, nestedsuite) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: suite
  type(c_ptr), value :: nestedsuite
end subroutine

! int g_test_run_suite (GTestSuite *suite);
function g_test_run_suite(suite) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_test_run_suite
  type(c_ptr), value :: suite
end function

!  void g_test_trap_assertions (const char *domain, const char *file, int line, const char *func, guint64 assertion_flags, const char *pattern);
subroutine g_test_trap_assertions(domain, file, line, func, assertion_flags, pa&
&ttern) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_int64_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  integer(c_int64_t), value :: assertion_flags
  character(kind=c_char), dimension(*) :: pattern
end subroutine

! void g_assertion_message (const char *domain, const char *file, int line, const char *func, const char *message) G_GNUC_NORETURN;
subroutine g_assertion_message(domain, file, line, func, message) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: message
end subroutine

! void g_assertion_message_expr (const char *domain, const char *file, int line, const char *func, const char *expr) G_GNUC_NORETURN;
subroutine g_assertion_message_expr(domain, file, line, func, expr) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
end subroutine

! void g_assertion_message_cmpstr (const char *domain, const char *file, int line, const char *func, const char *expr, const char *arg1, const char *cmp, const char *arg2) G_GNUC_NORETURN;
subroutine g_assertion_message_cmpstr(domain, file, line, func, expr, arg1, cmp&
&, arg2) bind(c) 
  use iso_c_binding, only: c_char, c_int
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  character(kind=c_char), dimension(*) :: arg1
  character(kind=c_char), dimension(*) :: cmp
  character(kind=c_char), dimension(*) :: arg2
end subroutine

! void g_assertion_message_error (const char *domain, const char *file, int line, const char *func, const char *expr, const GError *error, GQuark error_domain, int error_code) G_GNUC_NORETURN;
subroutine g_assertion_message_error(domain, file, line, func, expr, error, err&
&or_domain, error_code) bind(c) 
  use iso_c_binding, only: c_char, c_int, c_ptr, c_int32_t
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: line
  character(kind=c_char), dimension(*) :: func
  character(kind=c_char), dimension(*) :: expr
  type(c_ptr), value :: error
  integer(c_int32_t), value :: error_domain
  integer(c_int), value :: error_code
end subroutine

! void g_test_add_vtable (const char *testpath, gsize data_size, gconstpointer test_data, GTestFixtureFunc data_setup, GTestFixtureFunc data_test, GTestFixtureFunc data_teardown);
subroutine g_test_add_vtable(testpath, data_size, test_data, data_setup, data_t&
&est, data_teardown) bind(c) 
  use iso_c_binding, only: c_char, c_size_t, c_ptr, c_funptr
  character(kind=c_char), dimension(*) :: testpath
  integer(c_size_t), value :: data_size
  type(c_ptr), value :: test_data
  type(c_funptr), value :: data_setup
  type(c_funptr), value :: data_test
  type(c_funptr), value :: data_teardown
end subroutine

!  const char* g_test_log_type_name (GTestLogType log_type);
function g_test_log_type_name(log_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_test_log_type_name
  integer(c_int), value :: log_type
end function

! GTestLogBuffer* g_test_log_buffer_new (void);
function g_test_log_buffer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_log_buffer_new
end function

! void g_test_log_buffer_free (GTestLogBuffer *tbuffer);
subroutine g_test_log_buffer_free(tbuffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tbuffer
end subroutine

! void g_test_log_buffer_push (GTestLogBuffer *tbuffer, guint n_bytes, const guint8 *bytes);
subroutine g_test_log_buffer_push(tbuffer, n_bytes, bytes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: tbuffer
  integer(c_int), value :: n_bytes
  type(c_ptr), value :: bytes
end subroutine

! GTestLogMsg* g_test_log_buffer_pop (GTestLogBuffer *tbuffer);
function g_test_log_buffer_pop(tbuffer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_test_log_buffer_pop
  type(c_ptr), value :: tbuffer
end function

! void g_test_log_msg_free (GTestLogMsg *tmsg);
subroutine g_test_log_msg_free(tmsg) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tmsg
end subroutine

!  void g_test_log_set_fatal_handler (GTestLogFatalFunc log_func, gpointer user_data);
subroutine g_test_log_set_fatal_handler(log_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: log_func
  type(c_ptr), value :: user_data
end subroutine

!   GSequence * g_sequence_new (GDestroyNotify data_destroy);
function g_sequence_new(data_destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_new
  type(c_funptr), value :: data_destroy
end function

! void g_sequence_free (GSequence *seq);
subroutine g_sequence_free(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: seq
end subroutine

! gint g_sequence_get_length (GSequence *seq);
function g_sequence_get_length(seq) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_get_length
  type(c_ptr), value :: seq
end function

! void g_sequence_foreach (GSequence *seq, GFunc func, gpointer user_data);
subroutine g_sequence_foreach(seq, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_sequence_foreach_range (GSequenceIter *begin, GSequenceIter *end, GFunc func, gpointer user_data);
subroutine g_sequence_foreach_range(begin, end, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! void g_sequence_sort (GSequence *seq, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort(seq, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_sort_iter (GSequence *seq, GSequenceIterCompareFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_iter(seq, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: seq
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

!  GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
function g_sequence_get_begin_iter(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get_begin_iter
  type(c_ptr), value :: seq
end function

! GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
function g_sequence_get_end_iter(seq) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get_end_iter
  type(c_ptr), value :: seq
end function

! GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq, gint pos);
function g_sequence_get_iter_at_pos(seq, pos) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_sequence_get_iter_at_pos
  type(c_ptr), value :: seq
  integer(c_int), value :: pos
end function

! GSequenceIter *g_sequence_append (GSequence *seq, gpointer data);
function g_sequence_append(seq, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_append
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GSequenceIter *g_sequence_prepend (GSequence *seq, gpointer data);
function g_sequence_prepend(seq, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_prepend
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
end function

! GSequenceIter *g_sequence_insert_before (GSequenceIter *iter, gpointer data);
function g_sequence_insert_before(iter, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_insert_before
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end function

! void g_sequence_move (GSequenceIter *src, GSequenceIter *dest);
subroutine g_sequence_move(src, dest) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src
  type(c_ptr), value :: dest
end subroutine

! void g_sequence_swap (GSequenceIter *a, GSequenceIter *b);
subroutine g_sequence_swap(a, b) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end subroutine

! GSequenceIter *g_sequence_insert_sorted (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_insert_sorted(seq, data, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_insert_sorted_iter(seq, data, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_insert_sorted_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! void g_sequence_sort_changed (GSequenceIter *iter, GCompareDataFunc cmp_func, gpointer cmp_data);
subroutine g_sequence_sort_changed(iter, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_sort_changed_iter (GSequenceIter *iter, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
subroutine g_sequence_sort_changed_iter(iter, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: iter
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end subroutine

! void g_sequence_remove (GSequenceIter *iter);
subroutine g_sequence_remove(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! void g_sequence_remove_range (GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_remove_range(begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! void g_sequence_move_range (GSequenceIter *dest, GSequenceIter *begin, GSequenceIter *end);
subroutine g_sequence_move_range(dest, begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end subroutine

! GSequenceIter *g_sequence_search (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_search(seq, data, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_search_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_search_iter(seq, data, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_search_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_lookup (GSequence *seq, gpointer data, GCompareDataFunc cmp_func, gpointer cmp_data);
function g_sequence_lookup(seq, data, cmp_func, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_lookup
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: cmp_func
  type(c_ptr), value :: cmp_data
end function

! GSequenceIter *g_sequence_lookup_iter (GSequence *seq, gpointer data, GSequenceIterCompareFunc iter_cmp, gpointer cmp_data);
function g_sequence_lookup_iter(seq, data, iter_cmp, cmp_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_sequence_lookup_iter
  type(c_ptr), value :: seq
  type(c_ptr), value :: data
  type(c_funptr), value :: iter_cmp
  type(c_ptr), value :: cmp_data
end function

!  gpointer g_sequence_get (GSequenceIter *iter);
function g_sequence_get(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_get
  type(c_ptr), value :: iter
end function

! void g_sequence_set (GSequenceIter *iter, gpointer data);
subroutine g_sequence_set(iter, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: data
end subroutine

!  gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
function g_sequence_iter_is_begin(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_is_begin
  type(c_ptr), value :: iter
end function

! gboolean g_sequence_iter_is_end (GSequenceIter *iter);
function g_sequence_iter_is_end(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_is_end
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
function g_sequence_iter_next(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_next
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
function g_sequence_iter_prev(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_prev
  type(c_ptr), value :: iter
end function

! gint g_sequence_iter_get_position (GSequenceIter *iter);
function g_sequence_iter_get_position(iter) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_get_position
  type(c_ptr), value :: iter
end function

! GSequenceIter *g_sequence_iter_move (GSequenceIter *iter, gint delta);
function g_sequence_iter_move(iter, delta) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_sequence_iter_move
  type(c_ptr), value :: iter
  integer(c_int), value :: delta
end function

! GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);
function g_sequence_iter_get_sequence(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_iter_get_sequence
  type(c_ptr), value :: iter
end function

!  gint g_sequence_iter_compare (GSequenceIter *a, GSequenceIter *b);
function g_sequence_iter_compare(a, b) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_sequence_iter_compare
  type(c_ptr), value :: a
  type(c_ptr), value :: b
end function

! GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin, GSequenceIter *end);
function g_sequence_range_get_midpoint(begin, end) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_sequence_range_get_midpoint
  type(c_ptr), value :: begin
  type(c_ptr), value :: end
end function

!   GDate* g_date_new (void);
function g_date_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_new
end function

! GDate* g_date_new_dmy (GDateDay day, GDateMonth month, GDateYear year);
function g_date_new_dmy(day, month, year) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr) :: g_date_new_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! GDate* g_date_new_julian (guint32 julian_day);
function g_date_new_julian(julian_day) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_date_new_julian
  integer(c_int32_t), value :: julian_day
end function

! void g_date_free (GDate *date);
subroutine g_date_free(date) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
end subroutine

!  gboolean g_date_valid (const GDate *date);
function g_date_valid(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_valid
  type(c_ptr), value :: date
end function

! gboolean g_date_valid_day (GDateDay day) G_GNUC_CONST;
function g_date_valid_day(day) bind(c) 
  use iso_c_binding, only: c_int, c_int8_t
  integer(c_int) :: g_date_valid_day
  integer(c_int8_t), value :: day
end function

! gboolean g_date_valid_month (GDateMonth month) G_GNUC_CONST;
function g_date_valid_month(month) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_date_valid_month
  integer(c_int), value :: month
end function

! gboolean g_date_valid_year (GDateYear year) G_GNUC_CONST;
function g_date_valid_year(year) bind(c) 
  use iso_c_binding, only: c_int, c_int16_t
  integer(c_int) :: g_date_valid_year
  integer(c_int16_t), value :: year
end function

! gboolean g_date_valid_weekday (GDateWeekday weekday) G_GNUC_CONST;
function g_date_valid_weekday(weekday) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_date_valid_weekday
  integer(c_int), value :: weekday
end function

! gboolean g_date_valid_julian (guint32 julian_date) G_GNUC_CONST;
function g_date_valid_julian(julian_date) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_date_valid_julian
  integer(c_int32_t), value :: julian_date
end function

! gboolean g_date_valid_dmy (GDateDay day, GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_valid_dmy(day, month, year) bind(c) 
  use iso_c_binding, only: c_int, c_int8_t, c_int16_t
  integer(c_int) :: g_date_valid_dmy
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

!  GDateWeekday g_date_get_weekday (const GDate *date);
function g_date_get_weekday(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_weekday
  type(c_ptr), value :: date
end function

! GDateMonth g_date_get_month (const GDate *date);
function g_date_get_month(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_month
  type(c_ptr), value :: date
end function

! GDateYear g_date_get_year (const GDate *date);
function g_date_get_year(date) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_date_get_year
  type(c_ptr), value :: date
end function

! GDateDay g_date_get_day (const GDate *date);
function g_date_get_day(date) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(c_int8_t) :: g_date_get_day
  type(c_ptr), value :: date
end function

! guint32 g_date_get_julian (const GDate *date);
function g_date_get_julian(date) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_date_get_julian
  type(c_ptr), value :: date
end function

! guint g_date_get_day_of_year (const GDate *date);
function g_date_get_day_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_day_of_year
  type(c_ptr), value :: date
end function

!  guint g_date_get_monday_week_of_year (const GDate *date);
function g_date_get_monday_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_monday_week_of_year
  type(c_ptr), value :: date
end function

! guint g_date_get_sunday_week_of_year (const GDate *date);
function g_date_get_sunday_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_sunday_week_of_year
  type(c_ptr), value :: date
end function

! guint g_date_get_iso8601_week_of_year (const GDate *date);
function g_date_get_iso8601_week_of_year(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_get_iso8601_week_of_year
  type(c_ptr), value :: date
end function

!  void g_date_clear (GDate *date, guint n_dates);
subroutine g_date_clear(date, n_dates) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_dates
end subroutine

!  void g_date_set_parse (GDate *date, const gchar *str);
subroutine g_date_set_parse(date, str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: date
  character(kind=c_char), dimension(*) :: str
end subroutine

! void g_date_set_time_t (GDate *date, time_t timet);
subroutine g_date_set_time_t(date, timet) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: date
  integer(c_long), value :: timet
end subroutine

! void g_date_set_time_val (GDate *date, GTimeVal *timeval);
subroutine g_date_set_time_val(date, timeval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: timeval
end subroutine

!  void g_date_set_time (GDate *date, GTime time_);
subroutine g_date_set_time(date, time_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: date
  integer(c_int32_t), value :: time_
end subroutine

!  void g_date_set_month (GDate *date, GDateMonth month);
subroutine g_date_set_month(date, month) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: month
end subroutine

! void g_date_set_day (GDate *date, GDateDay day);
subroutine g_date_set_day(date, day) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
end subroutine

! void g_date_set_year (GDate *date, GDateYear year);
subroutine g_date_set_year(date, year) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr), value :: date
  integer(c_int16_t), value :: year
end subroutine

! void g_date_set_dmy (GDate *date, GDateDay day, GDateMonth month, GDateYear y);
subroutine g_date_set_dmy(date, day, month, y) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t, c_int, c_int16_t
  type(c_ptr), value :: date
  integer(c_int8_t), value :: day
  integer(c_int), value :: month
  integer(c_int16_t), value :: y
end subroutine

! void g_date_set_julian (GDate *date, guint32 julian_date);
subroutine g_date_set_julian(date, julian_date) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: date
  integer(c_int32_t), value :: julian_date
end subroutine

! gboolean g_date_is_first_of_month (const GDate *date);
function g_date_is_first_of_month(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_is_first_of_month
  type(c_ptr), value :: date
end function

! gboolean g_date_is_last_of_month (const GDate *date);
function g_date_is_last_of_month(date) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_is_last_of_month
  type(c_ptr), value :: date
end function

!  void g_date_add_days (GDate *date, guint n_days);
subroutine g_date_add_days(date, n_days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

! void g_date_subtract_days (GDate *date, guint n_days);
subroutine g_date_subtract_days(date, n_days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_days
end subroutine

!  void g_date_add_months (GDate *date, guint n_months);
subroutine g_date_add_months(date, n_months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

! void g_date_subtract_months (GDate *date, guint n_months);
subroutine g_date_subtract_months(date, n_months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_months
end subroutine

!  void g_date_add_years (GDate *date, guint n_years);
subroutine g_date_add_years(date, n_years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! void g_date_subtract_years (GDate *date, guint n_years);
subroutine g_date_subtract_years(date, n_years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: date
  integer(c_int), value :: n_years
end subroutine

! gboolean g_date_is_leap_year (GDateYear year) G_GNUC_CONST;
function g_date_is_leap_year(year) bind(c) 
  use iso_c_binding, only: c_int, c_int16_t
  integer(c_int) :: g_date_is_leap_year
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_days_in_month (GDateMonth month, GDateYear year) G_GNUC_CONST;
function g_date_get_days_in_month(month, year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int, c_int16_t
  integer(c_int8_t) :: g_date_get_days_in_month
  integer(c_int), value :: month
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_monday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_monday_weeks_in_year(year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_monday_weeks_in_year
  integer(c_int16_t), value :: year
end function

! guint8 g_date_get_sunday_weeks_in_year (GDateYear year) G_GNUC_CONST;
function g_date_get_sunday_weeks_in_year(year) bind(c) 
  use iso_c_binding, only: c_int8_t, c_int16_t
  integer(c_int8_t) :: g_date_get_sunday_weeks_in_year
  integer(c_int16_t), value :: year
end function

!  gint g_date_days_between (const GDate *date1, const GDate *date2);
function g_date_days_between(date1, date2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_days_between
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end function

!  gint g_date_compare (const GDate *lhs, const GDate *rhs);
function g_date_compare(lhs, rhs) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_compare
  type(c_ptr), value :: lhs
  type(c_ptr), value :: rhs
end function

! void g_date_to_struct_tm (const GDate *date, struct tm *tm);
subroutine g_date_to_struct_tm(date, tm) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: tm
end subroutine

!  void g_date_clamp (GDate *date, const GDate *min_date, const GDate *max_date);
subroutine g_date_clamp(date, min_date, max_date) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date
  type(c_ptr), value :: min_date
  type(c_ptr), value :: max_date
end subroutine

!  void g_date_order (GDate *date1, GDate *date2);
subroutine g_date_order(date1, date2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: date1
  type(c_ptr), value :: date2
end subroutine

!  gsize g_date_strftime (gchar *s, gsize slen, const gchar *format, const GDate *date);
function g_date_strftime(s, slen, format, date) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_date_strftime
  character(kind=c_char), dimension(*) :: s
  integer(c_size_t), value :: slen
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: date
end function

!   GTimeZone * g_time_zone_new (const gchar *identifier);
function g_time_zone_new(identifier) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_time_zone_new
  character(kind=c_char), dimension(*) :: identifier
end function

! GTimeZone * g_time_zone_new_utc (void);
function g_time_zone_new_utc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_new_utc
end function

! GTimeZone * g_time_zone_new_local (void);
function g_time_zone_new_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_new_local
end function

!  GTimeZone * g_time_zone_ref (GTimeZone *tz);
function g_time_zone_ref(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_zone_ref
  type(c_ptr), value :: tz
end function

! void g_time_zone_unref (GTimeZone *tz);
subroutine g_time_zone_unref(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tz
end subroutine

!  gint g_time_zone_find_interval (GTimeZone *tz, GTimeType type, gint64 time);
function g_time_zone_find_interval(tz, type, time) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int64_t
  integer(c_int) :: g_time_zone_find_interval
  type(c_ptr), value :: tz
  integer(c_int), value :: type
  integer(c_int64_t), value :: time
end function

!  gint g_time_zone_adjust_time (GTimeZone *tz, GTimeType type, gint64 *time);
function g_time_zone_adjust_time(tz, type, time) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_time_zone_adjust_time
  type(c_ptr), value :: tz
  integer(c_int), value :: type
  type(c_ptr), value :: time
end function

!  const gchar * g_time_zone_get_abbreviation (GTimeZone *tz, gint interval);
function g_time_zone_get_abbreviation(tz, interval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_time_zone_get_abbreviation
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

! gint32 g_time_zone_get_offset (GTimeZone *tz, gint interval);
function g_time_zone_get_offset(tz, interval) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr, c_int
  integer(c_int32_t) :: g_time_zone_get_offset
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

! gboolean g_time_zone_is_dst (GTimeZone *tz, gint interval);
function g_time_zone_is_dst(tz, interval) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_time_zone_is_dst
  type(c_ptr), value :: tz
  integer(c_int), value :: interval
end function

!   void g_date_time_unref (GDateTime *datetime);
subroutine g_date_time_unref(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datetime
end subroutine

! GDateTime * g_date_time_ref (GDateTime *datetime);
function g_date_time_ref(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_ref
  type(c_ptr), value :: datetime
end function

!  GDateTime * g_date_time_new_now (GTimeZone *tz);
function g_date_time_new_now(tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now
  type(c_ptr), value :: tz
end function

! GDateTime * g_date_time_new_now_local (void);
function g_date_time_new_now_local() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now_local
end function

! GDateTime * g_date_time_new_now_utc (void);
function g_date_time_new_now_utc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_now_utc
end function

!  GDateTime * g_date_time_new_from_unix_local (gint64 t);
function g_date_time_new_from_unix_local(t) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_local
  integer(c_int64_t), value :: t
end function

! GDateTime * g_date_time_new_from_unix_utc (gint64 t);
function g_date_time_new_from_unix_utc(t) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_new_from_unix_utc
  integer(c_int64_t), value :: t
end function

!  GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
function g_date_time_new_from_timeval_local(tv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_local
  type(c_ptr), value :: tv
end function

! GDateTime * g_date_time_new_from_timeval_utc (const GTimeVal *tv);
function g_date_time_new_from_timeval_utc(tv) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_new_from_timeval_utc
  type(c_ptr), value :: tv
end function

!  GDateTime * g_date_time_new (GTimeZone *tz, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new(tz, year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new
  type(c_ptr), value :: tz
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GDateTime * g_date_time_new_local (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_local(year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_local
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

! GDateTime * g_date_time_new_utc (gint year, gint month, gint day, gint hour, gint minute, gdouble seconds);
function g_date_time_new_utc(year, month, day, hour, minute, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_new_utc
  integer(c_int), value :: year
  integer(c_int), value :: month
  integer(c_int), value :: day
  integer(c_int), value :: hour
  integer(c_int), value :: minute
  real(c_double), value :: seconds
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add (GDateTime *datetime, GTimeSpan timespan);
function g_date_time_add(datetime, timespan) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_date_time_add
  type(c_ptr), value :: datetime
  integer(c_int64_t), value :: timespan
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_years (GDateTime *datetime, gint years);
function g_date_time_add_years(datetime, years) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_years
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_months (GDateTime *datetime, gint months);
function g_date_time_add_months(datetime, months) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_months
  type(c_ptr), value :: datetime
  integer(c_int), value :: months
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_weeks (GDateTime *datetime, gint weeks);
function g_date_time_add_weeks(datetime, weeks) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_weeks
  type(c_ptr), value :: datetime
  integer(c_int), value :: weeks
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_days (GDateTime *datetime, gint days);
function g_date_time_add_days(datetime, days) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_days
  type(c_ptr), value :: datetime
  integer(c_int), value :: days
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_hours (GDateTime *datetime, gint hours);
function g_date_time_add_hours(datetime, hours) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_hours
  type(c_ptr), value :: datetime
  integer(c_int), value :: hours
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_minutes (GDateTime *datetime, gint minutes);
function g_date_time_add_minutes(datetime, minutes) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_date_time_add_minutes
  type(c_ptr), value :: datetime
  integer(c_int), value :: minutes
end function

! G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_seconds (GDateTime *datetime, gdouble seconds);
function g_date_time_add_seconds(datetime, seconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: g_date_time_add_seconds
  type(c_ptr), value :: datetime
  real(c_double), value :: seconds
end function

!  G_GNUC_WARN_UNUSED_RESULT GDateTime * g_date_time_add_full (GDateTime *datetime, gint years, gint months, gint days, gint hours, gint minutes, gdouble seconds);
function g_date_time_add_full(datetime, years, months, days, hours, minutes, se&
&conds) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_double
  type(c_ptr) :: g_date_time_add_full
  type(c_ptr), value :: datetime
  integer(c_int), value :: years
  integer(c_int), value :: months
  integer(c_int), value :: days
  integer(c_int), value :: hours
  integer(c_int), value :: minutes
  real(c_double), value :: seconds
end function

!  gint g_date_time_compare (gconstpointer dt1, gconstpointer dt2);
function g_date_time_compare(dt1, dt2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_compare
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

! GTimeSpan g_date_time_difference (GDateTime *end, GDateTime *begin);
function g_date_time_difference(end, begin) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_difference
  type(c_ptr), value :: end
  type(c_ptr), value :: begin
end function

! guint g_date_time_hash (gconstpointer datetime);
function g_date_time_hash(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_hash
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_equal (gconstpointer dt1, gconstpointer dt2);
function g_date_time_equal(dt1, dt2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_equal
  type(c_ptr), value :: dt1
  type(c_ptr), value :: dt2
end function

!  void g_date_time_get_ymd (GDateTime *datetime, gint *year, gint *month, gint *day);
subroutine g_date_time_get_ymd(datetime, year, month, day) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datetime
  type(c_ptr), value :: year
  type(c_ptr), value :: month
  type(c_ptr), value :: day
end subroutine

!  gint g_date_time_get_year (GDateTime *datetime);
function g_date_time_get_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_month (GDateTime *datetime);
function g_date_time_get_month(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_month
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_day_of_month (GDateTime *datetime);
function g_date_time_get_day_of_month(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_month
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_week_numbering_year (GDateTime *datetime);
function g_date_time_get_week_numbering_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_numbering_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_week_of_year (GDateTime *datetime);
function g_date_time_get_week_of_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_week_of_year
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_day_of_week (GDateTime *datetime);
function g_date_time_get_day_of_week(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_week
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_day_of_year (GDateTime *datetime);
function g_date_time_get_day_of_year(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_day_of_year
  type(c_ptr), value :: datetime
end function

!  gint g_date_time_get_hour (GDateTime *datetime);
function g_date_time_get_hour(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_hour
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_minute (GDateTime *datetime);
function g_date_time_get_minute(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_minute
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_second (GDateTime *datetime);
function g_date_time_get_second(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_second
  type(c_ptr), value :: datetime
end function

! gint g_date_time_get_microsecond (GDateTime *datetime);
function g_date_time_get_microsecond(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_get_microsecond
  type(c_ptr), value :: datetime
end function

! gdouble g_date_time_get_seconds (GDateTime *datetime);
function g_date_time_get_seconds(datetime) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_date_time_get_seconds
  type(c_ptr), value :: datetime
end function

!  gint64 g_date_time_to_unix (GDateTime *datetime);
function g_date_time_to_unix(datetime) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_to_unix
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_to_timeval (GDateTime *datetime, GTimeVal *tv);
function g_date_time_to_timeval(datetime, tv) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_to_timeval
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tv
end function

!  GTimeSpan g_date_time_get_utc_offset (GDateTime *datetime);
function g_date_time_get_utc_offset(datetime) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_date_time_get_utc_offset
  type(c_ptr), value :: datetime
end function

! const gchar * g_date_time_get_timezone_abbreviation (GDateTime *datetime);
function g_date_time_get_timezone_abbreviation(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_get_timezone_abbreviation
  type(c_ptr), value :: datetime
end function

! gboolean g_date_time_is_daylight_savings (GDateTime *datetime);
function g_date_time_is_daylight_savings(datetime) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_date_time_is_daylight_savings
  type(c_ptr), value :: datetime
end function

!  GDateTime * g_date_time_to_timezone (GDateTime *datetime, GTimeZone *tz);
function g_date_time_to_timezone(datetime, tz) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_timezone
  type(c_ptr), value :: datetime
  type(c_ptr), value :: tz
end function

! GDateTime * g_date_time_to_local (GDateTime *datetime);
function g_date_time_to_local(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_local
  type(c_ptr), value :: datetime
end function

! GDateTime * g_date_time_to_utc (GDateTime *datetime);
function g_date_time_to_utc(datetime) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_date_time_to_utc
  type(c_ptr), value :: datetime
end function

!  gchar * g_date_time_format (GDateTime *datetime, const gchar *format) G_GNUC_MALLOC;
function g_date_time_format(datetime, format) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_date_time_format
  type(c_ptr), value :: datetime
  character(kind=c_char), dimension(*) :: format
end function

!   GPatternSpec* g_pattern_spec_new (const gchar *pattern);
function g_pattern_spec_new(pattern) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_pattern_spec_new
  character(kind=c_char), dimension(*) :: pattern
end function

! void g_pattern_spec_free (GPatternSpec *pspec);
subroutine g_pattern_spec_free(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! gboolean g_pattern_spec_equal (GPatternSpec *pspec1, GPatternSpec *pspec2);
function g_pattern_spec_equal(pspec1, pspec2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_pattern_spec_equal
  type(c_ptr), value :: pspec1
  type(c_ptr), value :: pspec2
end function

! gboolean g_pattern_match (GPatternSpec *pspec, guint string_length, const gchar *string, const gchar *string_reversed);
function g_pattern_match(pspec, string_length, string, string_reversed) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_pattern_match
  type(c_ptr), value :: pspec
  integer(c_int), value :: string_length
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: string_reversed
end function

! gboolean g_pattern_match_string (GPatternSpec *pspec, const gchar *string);
function g_pattern_match_string(pspec, string) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_pattern_match_string
  type(c_ptr), value :: pspec
  character(kind=c_char), dimension(*) :: string
end function

! gboolean g_pattern_match_simple (const gchar *pattern, const gchar *string);
function g_pattern_match_simple(pattern, string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_pattern_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
end function

!   GQuark g_markup_error_quark (void);
function g_markup_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_markup_error_quark
end function

!  GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser, GMarkupParseFlags flags, gpointer user_data, GDestroyNotify user_data_dnotify);
function g_markup_parse_context_new(parser, flags, user_data, user_data_dnotify&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_markup_parse_context_new
  type(c_ptr), value :: parser
  integer(c_int), value :: flags
  type(c_ptr), value :: user_data
  type(c_funptr), value :: user_data_dnotify
end function

! void g_markup_parse_context_free (GMarkupParseContext *context);
subroutine g_markup_parse_context_free(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_markup_parse_context_parse (GMarkupParseContext *context, const gchar *text, gssize text_len, GError **error);
function g_markup_parse_context_parse(context, text, text_len, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_markup_parse_context_parse
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: text_len
  type(c_ptr), value :: error
end function

! void g_markup_parse_context_push (GMarkupParseContext *context, const GMarkupParser *parser, gpointer user_data);
subroutine g_markup_parse_context_push(context, parser, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: parser
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_markup_parse_context_pop (GMarkupParseContext *context);
function g_markup_parse_context_pop(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_pop
  type(c_ptr), value :: context
end function

!  gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context, GError **error);
function g_markup_parse_context_end_parse(context, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_markup_parse_context_end_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: error
end function

! G_CONST_RETURN gchar *g_markup_parse_context_get_element (GMarkupParseContext *context);
function g_markup_parse_context_get_element(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element
  type(c_ptr), value :: context
end function

! G_CONST_RETURN GSList *g_markup_parse_context_get_element_stack (GMarkupParseContext *context);
function g_markup_parse_context_get_element_stack(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_element_stack
  type(c_ptr), value :: context
end function

!  void g_markup_parse_context_get_position (GMarkupParseContext *context, gint *line_number, gint *char_number);
subroutine g_markup_parse_context_get_position(context, line_number, char_numbe&
&r) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: line_number
  type(c_ptr), value :: char_number
end subroutine

! gpointer g_markup_parse_context_get_user_data (GMarkupParseContext *context);
function g_markup_parse_context_get_user_data(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_parse_context_get_user_data
  type(c_ptr), value :: context
end function

!  gchar* g_markup_escape_text (const gchar *text, gssize length);
function g_markup_escape_text(text, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_markup_escape_text
  character(kind=c_char), dimension(*) :: text
  integer(c_size_t), value :: length
end function

!  gchar *g_markup_printf_escaped (const char *format, ...) G_GNUC_PRINTF (1, 2);
function g_markup_printf_escaped() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_markup_printf_escaped
end function

! gchar *g_markup_vprintf_escaped (const char *format, va_list args);
function g_markup_vprintf_escaped(format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_markup_vprintf_escaped
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!   GCompletion* g_completion_new (GCompletionFunc func);
function g_completion_new(func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_completion_new
  type(c_funptr), value :: func
end function

! void g_completion_add_items (GCompletion* cmp, GList* items);
subroutine g_completion_add_items(cmp, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! void g_completion_remove_items (GCompletion* cmp, GList* items);
subroutine g_completion_remove_items(cmp, items) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
  type(c_ptr), value :: items
end subroutine

! void g_completion_clear_items (GCompletion* cmp);
subroutine g_completion_clear_items(cmp) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
end subroutine

! GList* g_completion_complete (GCompletion* cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete(cmp, prefix, new_prefix) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_completion_complete
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  type(c_ptr), dimension(*) :: new_prefix
end function

! GList* g_completion_complete_utf8 (GCompletion *cmp, const gchar* prefix, gchar** new_prefix);
function g_completion_complete_utf8(cmp, prefix, new_prefix) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_completion_complete_utf8
  type(c_ptr), value :: cmp
  character(kind=c_char), dimension(*) :: prefix
  type(c_ptr), dimension(*) :: new_prefix
end function

! void g_completion_set_compare (GCompletion *cmp, GCompletionStrncmpFunc strncmp_func);
subroutine g_completion_set_compare(cmp, strncmp_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cmp
  type(c_funptr), value :: strncmp_func
end subroutine

! void g_completion_free (GCompletion* cmp);
subroutine g_completion_free(cmp) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cmp
end subroutine

!  gchar g_ascii_tolower (gchar c) G_GNUC_CONST;
function g_ascii_tolower(c) bind(c) 
  use iso_c_binding, only: c_int8_t
  integer(kind=c_int8_t) :: g_ascii_tolower
  integer(kind=c_int8_t), value :: c
end function

! gchar g_ascii_toupper (gchar c) G_GNUC_CONST;
function g_ascii_toupper(c) bind(c) 
  use iso_c_binding, only: c_int8_t
  integer(kind=c_int8_t) :: g_ascii_toupper
  integer(kind=c_int8_t), value :: c
end function

!  gint g_ascii_digit_value (gchar c) G_GNUC_CONST;
function g_ascii_digit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int8_t
  integer(c_int) :: g_ascii_digit_value
  integer(kind=c_int8_t), value :: c
end function

! gint g_ascii_xdigit_value (gchar c) G_GNUC_CONST;
function g_ascii_xdigit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int8_t
  integer(c_int) :: g_ascii_xdigit_value
  integer(kind=c_int8_t), value :: c
end function

!  gchar* g_strdelimit (gchar *string, const gchar *delimiters, gchar new_delimiter);
function g_strdelimit(string, delimiters, new_delimiter) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t
  type(c_ptr) :: g_strdelimit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  integer(kind=c_int8_t), value :: new_delimiter
end function

! gchar* g_strcanon (gchar *string, const gchar *valid_chars, gchar substitutor);
function g_strcanon(string, valid_chars, substitutor) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t
  type(c_ptr) :: g_strcanon
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: valid_chars
  integer(kind=c_int8_t), value :: substitutor
end function

! G_CONST_RETURN gchar* g_strerror (gint errnum) G_GNUC_CONST;
function g_strerror(errnum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_strerror
  integer(c_int), value :: errnum
end function

! G_CONST_RETURN gchar* g_strsignal (gint signum) G_GNUC_CONST;
function g_strsignal(signum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_strsignal
  integer(c_int), value :: signum
end function

! gchar* g_strreverse (gchar *string);
function g_strreverse(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strreverse
  character(kind=c_char), dimension(*) :: string
end function

! gsize g_strlcpy (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcpy(dest, src, dest_size) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_strlcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! gsize g_strlcat (gchar *dest, const gchar *src, gsize dest_size);
function g_strlcat(dest, src, dest_size) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_strlcat
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: dest_size
end function

! gchar * g_strstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strstr_len(haystack, haystack_len, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

! gchar * g_strrstr (const gchar *haystack, const gchar *needle);
function g_strrstr(haystack, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strrstr
  character(kind=c_char), dimension(*) :: haystack
  character(kind=c_char), dimension(*) :: needle
end function

! gchar * g_strrstr_len (const gchar *haystack, gssize haystack_len, const gchar *needle);
function g_strrstr_len(haystack, haystack_len, needle) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strrstr_len
  character(kind=c_char), dimension(*) :: haystack
  integer(c_size_t), value :: haystack_len
  character(kind=c_char), dimension(*) :: needle
end function

!  gboolean g_str_has_suffix (const gchar *str, const gchar *suffix);
function g_str_has_suffix(str, suffix) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_str_has_suffix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: suffix
end function

! gboolean g_str_has_prefix (const gchar *str, const gchar *prefix);
function g_str_has_prefix(str, prefix) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_str_has_prefix
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: prefix
end function

!  gdouble g_strtod (const gchar *nptr, gchar **endptr);
function g_strtod(nptr, endptr) bind(c) 
  use iso_c_binding, only: c_double, c_char, c_ptr
  real(c_double) :: g_strtod
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
end function

! gdouble g_ascii_strtod (const gchar *nptr, gchar **endptr);
function g_ascii_strtod(nptr, endptr) bind(c) 
  use iso_c_binding, only: c_double, c_char, c_ptr
  real(c_double) :: g_ascii_strtod
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
end function

! guint64 g_ascii_strtoull (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoull(nptr, endptr, base) bind(c) 
  use iso_c_binding, only: c_int64_t, c_char, c_ptr, c_int
  integer(c_int64_t) :: g_ascii_strtoull
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
  integer(c_int), value :: base
end function

! gint64 g_ascii_strtoll (const gchar *nptr, gchar **endptr, guint base);
function g_ascii_strtoll(nptr, endptr, base) bind(c) 
  use iso_c_binding, only: c_int64_t, c_char, c_ptr, c_int
  integer(c_int64_t) :: g_ascii_strtoll
  character(kind=c_char), dimension(*) :: nptr
  type(c_ptr), dimension(*) :: endptr
  integer(c_int), value :: base
end function

!  gchar * g_ascii_dtostr (gchar *buffer, gint buf_len, gdouble d);
function g_ascii_dtostr(buffer, buf_len, d) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_dtostr
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  real(c_double), value :: d
end function

! gchar * g_ascii_formatd (gchar *buffer, gint buf_len, const gchar *format, gdouble d);
function g_ascii_formatd(buffer, buf_len, format, d) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_double
  type(c_ptr) :: g_ascii_formatd
  character(kind=c_char), dimension(*) :: buffer
  integer(c_int), value :: buf_len
  character(kind=c_char), dimension(*) :: format
  real(c_double), value :: d
end function

!  gchar* g_strchug (gchar *string);
function g_strchug(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strchug
  character(kind=c_char), dimension(*) :: string
end function

!  gchar* g_strchomp (gchar *string);
function g_strchomp(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strchomp
  character(kind=c_char), dimension(*) :: string
end function

!  gint g_ascii_strcasecmp (const gchar *s1, const gchar *s2);
function g_ascii_strcasecmp(s1, s2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_ascii_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! gint g_ascii_strncasecmp (const gchar *s1, const gchar *s2, gsize n);
function g_ascii_strncasecmp(s1, s2, n) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t
  integer(c_int) :: g_ascii_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_size_t), value :: n
end function

! gchar* g_ascii_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strdown(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar* g_ascii_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_ascii_strup(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_ascii_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gint g_strcasecmp (const gchar *s1, const gchar *s2);
function g_strcasecmp(s1, s2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strcasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
end function

! gint g_strncasecmp (const gchar *s1, const gchar *s2, guint n);
function g_strncasecmp(s1, s2, n) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_strncasecmp
  character(kind=c_char), dimension(*) :: s1
  character(kind=c_char), dimension(*) :: s2
  integer(c_int), value :: n
end function

! gchar* g_strdown (gchar *string);
function g_strdown(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdown
  character(kind=c_char), dimension(*) :: string
end function

! gchar* g_strup (gchar *string);
function g_strup(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strup
  character(kind=c_char), dimension(*) :: string
end function

!  gchar* g_strdup (const gchar *str) G_GNUC_MALLOC;
function g_strdup(str) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdup
  character(kind=c_char), dimension(*) :: str
end function

! gchar* g_strdup_printf (const gchar *format, ...) G_GNUC_PRINTF (1, 2) G_GNUC_MALLOC;
function g_strdup_printf() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_strdup_printf
end function

! gchar* g_strdup_vprintf (const gchar *format, va_list args) G_GNUC_MALLOC;
function g_strdup_vprintf(format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strdup_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gchar* g_strndup (const gchar *str, gsize n) G_GNUC_MALLOC;
function g_strndup(str, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_strndup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: n
end function

! gchar* g_strnfill (gsize length, gchar fill_char) G_GNUC_MALLOC;
function g_strnfill(length, fill_char) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int8_t
  type(c_ptr) :: g_strnfill
  integer(c_size_t), value :: length
  integer(kind=c_int8_t), value :: fill_char
end function

!  gchar* g_strcompress (const gchar *source) G_GNUC_MALLOC;
function g_strcompress(source) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strcompress
  character(kind=c_char), dimension(*) :: source
end function

!  gchar* g_strescape (const gchar *source, const gchar *exceptions) G_GNUC_MALLOC;
function g_strescape(source, exceptions) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strescape
  character(kind=c_char), dimension(*) :: source
  character(kind=c_char), dimension(*) :: exceptions
end function

!  gpointer g_memdup (gconstpointer mem, guint byte_size) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(2);
function g_memdup(mem, byte_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_memdup
  type(c_ptr), value :: mem
  integer(c_int), value :: byte_size
end function

!  gchar** g_strsplit (const gchar *string, const gchar *delimiter, gint max_tokens) G_GNUC_MALLOC;
function g_strsplit(string, delimiter, max_tokens) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiter
  integer(c_int), value :: max_tokens
end function

! gchar ** g_strsplit_set (const gchar *string, const gchar *delimiters, gint max_tokens) G_GNUC_MALLOC;
function g_strsplit_set(string, delimiters, max_tokens) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_strsplit_set
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: delimiters
  integer(c_int), value :: max_tokens
end function

! gchar* g_strjoinv (const gchar *separator, gchar **str_array) G_GNUC_MALLOC;
function g_strjoinv(separator, str_array) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strjoinv
  character(kind=c_char), dimension(*) :: separator
  type(c_ptr), dimension(*) :: str_array
end function

! void g_strfreev (gchar **str_array);
subroutine g_strfreev(str_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), dimension(*) :: str_array
end subroutine

! gchar** g_strdupv (gchar **str_array) G_GNUC_MALLOC;
function g_strdupv(str_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_strdupv
  type(c_ptr), dimension(*) :: str_array
end function

! guint g_strv_length (gchar **str_array);
function g_strv_length(str_array) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_strv_length
  type(c_ptr), dimension(*) :: str_array
end function

!  gchar* g_stpcpy (gchar *dest, const char *src);
function g_stpcpy(dest, src) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_stpcpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
end function

!  G_CONST_RETURN gchar *g_strip_context (const gchar *msgid, const gchar *msgval) G_GNUC_FORMAT(1);
function g_strip_context(msgid, msgval) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_strip_context
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgval
end function

!  G_CONST_RETURN gchar *g_dgettext (const gchar *domain, const gchar *msgid) G_GNUC_FORMAT(2);
function g_dgettext(domain, msgid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
end function

! G_CONST_RETURN gchar *g_dcgettext (const gchar *domain, const gchar *msgid, int category) G_GNUC_FORMAT(2);
function g_dcgettext(domain, msgid, category) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_dcgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  integer(c_int), value :: category
end function

! G_CONST_RETURN gchar *g_dngettext (const gchar *domain, const gchar *msgid, const gchar *msgid_plural, gulong n) G_GNUC_FORMAT(3);
function g_dngettext(domain, msgid, msgid_plural, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_dngettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgid
  character(kind=c_char), dimension(*) :: msgid_plural
  integer(c_long), value :: n
end function

! G_CONST_RETURN gchar *g_dpgettext (const gchar *domain, const gchar *msgctxtid, gsize msgidoffset) G_GNUC_FORMAT(2);
function g_dpgettext(domain, msgctxtid, msgidoffset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_dpgettext
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: msgctxtid
  integer(c_size_t), value :: msgidoffset
end function

! G_CONST_RETURN gchar *g_dpgettext2 (const gchar *domain, const gchar *context, const gchar *msgid) G_GNUC_FORMAT(3);
function g_dpgettext2(domain, context, msgid) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_dpgettext2
  character(kind=c_char), dimension(*) :: domain
  character(kind=c_char), dimension(*) :: context
  character(kind=c_char), dimension(*) :: msgid
end function

!   GScanner* g_scanner_new (const GScannerConfig *config_templ);
function g_scanner_new(config_templ) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_scanner_new
  type(c_ptr), value :: config_templ
end function

! void g_scanner_destroy (GScanner *scanner);
subroutine g_scanner_destroy(scanner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! void g_scanner_input_file (GScanner *scanner, gint input_fd);
subroutine g_scanner_input_file(scanner, input_fd) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: scanner
  integer(c_int), value :: input_fd
end subroutine

! void g_scanner_sync_file_offset (GScanner *scanner);
subroutine g_scanner_sync_file_offset(scanner) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: scanner
end subroutine

! void g_scanner_input_text (GScanner *scanner, const gchar *text, guint text_len);
subroutine g_scanner_input_text(scanner, text, text_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: text
  integer(c_int), value :: text_len
end subroutine

! GTokenType g_scanner_get_next_token (GScanner *scanner);
function g_scanner_get_next_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_get_next_token
  type(c_ptr), value :: scanner
end function

! GTokenType g_scanner_peek_next_token (GScanner *scanner);
function g_scanner_peek_next_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_peek_next_token
  type(c_ptr), value :: scanner
end function

! GTokenType g_scanner_cur_token (GScanner *scanner);
function g_scanner_cur_token(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_token
  type(c_ptr), value :: scanner
end function

! guint g_scanner_cur_line (GScanner *scanner);
function g_scanner_cur_line(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_line
  type(c_ptr), value :: scanner
end function

! guint g_scanner_cur_position (GScanner *scanner);
function g_scanner_cur_position(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_cur_position
  type(c_ptr), value :: scanner
end function

! gboolean g_scanner_eof (GScanner *scanner);
function g_scanner_eof(scanner) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_eof
  type(c_ptr), value :: scanner
end function

! guint g_scanner_set_scope (GScanner *scanner, guint scope_id);
function g_scanner_set_scope(scanner, scope_id) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_scanner_set_scope
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
end function

! void g_scanner_scope_add_symbol (GScanner *scanner, guint scope_id, const gchar *symbol, gpointer value);
subroutine g_scanner_scope_add_symbol(scanner, scope_id, symbol, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
  type(c_ptr), value :: value
end subroutine

! void g_scanner_scope_remove_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
subroutine g_scanner_scope_remove_symbol(scanner, scope_id, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end subroutine

! gpointer g_scanner_scope_lookup_symbol (GScanner *scanner, guint scope_id, const gchar *symbol);
function g_scanner_scope_lookup_symbol(scanner, scope_id, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr) :: g_scanner_scope_lookup_symbol
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  character(kind=c_char), dimension(*) :: symbol
end function

! void g_scanner_scope_foreach_symbol (GScanner *scanner, guint scope_id, GHFunc func, gpointer user_data);
subroutine g_scanner_scope_foreach_symbol(scanner, scope_id, func, user_data) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: scanner
  integer(c_int), value :: scope_id
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_scanner_lookup_symbol (GScanner *scanner, const gchar *symbol);
function g_scanner_lookup_symbol(scanner, symbol) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_scanner_lookup_symbol
  type(c_ptr), value :: scanner
  character(kind=c_char), dimension(*) :: symbol
end function

! void g_scanner_unexp_token (GScanner *scanner, GTokenType expected_token, const gchar *identifier_spec, const gchar *symbol_spec, const gchar *symbol_name, const gchar *message, gint is_error);
subroutine g_scanner_unexp_token(scanner, expected_token, identifier_spec, symb&
&ol_spec, symbol_name, message, is_error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: scanner
  integer(c_int), value :: expected_token
  character(kind=c_char), dimension(*) :: identifier_spec
  character(kind=c_char), dimension(*) :: symbol_spec
  character(kind=c_char), dimension(*) :: symbol_name
  character(kind=c_char), dimension(*) :: message
  integer(c_int), value :: is_error
end subroutine

! void g_scanner_error (GScanner *scanner, const gchar *format, ...) G_GNUC_PRINTF (2,3);
subroutine g_scanner_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_scanner_warn (GScanner *scanner, const gchar *format, ...) G_GNUC_PRINTF (2,3);
subroutine g_scanner_warn() bind(c) 
  use iso_c_binding, only: 
end subroutine

!     char *alloca ();
function alloca() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: alloca
end function

!     void g_qsort_with_data (gconstpointer pbase, gint total_elems, gsize size, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_qsort_with_data(pbase, total_elems, size, compare_func, user_data)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_size_t, c_funptr
  type(c_ptr), value :: pbase
  integer(c_int), value :: total_elems
  integer(c_size_t), value :: size
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!   GHashTable* g_hash_table_new (GHashFunc hash_func, GEqualFunc key_equal_func);
function g_hash_table_new(hash_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end function

! GHashTable* g_hash_table_new_full (GHashFunc hash_func, GEqualFunc key_equal_func, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_hash_table_new_full(hash_func, key_equal_func, key_destroy_func, val&
&ue_destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_new_full
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! void g_hash_table_destroy (GHashTable *hash_table);
subroutine g_hash_table_destroy(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! void g_hash_table_insert (GHashTable *hash_table, gpointer key, gpointer value);
subroutine g_hash_table_insert(hash_table, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! void g_hash_table_replace (GHashTable *hash_table, gpointer key, gpointer value);
subroutine g_hash_table_replace(hash_table, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! gboolean g_hash_table_remove (GHashTable *hash_table, gconstpointer key);
function g_hash_table_remove(hash_table, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_remove
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! void g_hash_table_remove_all (GHashTable *hash_table);
subroutine g_hash_table_remove_all(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! gboolean g_hash_table_steal (GHashTable *hash_table, gconstpointer key);
function g_hash_table_steal(hash_table, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_steal
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! void g_hash_table_steal_all (GHashTable *hash_table);
subroutine g_hash_table_steal_all(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

! gpointer g_hash_table_lookup (GHashTable *hash_table, gconstpointer key);
function g_hash_table_lookup(hash_table, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_lookup
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: key
end function

! gboolean g_hash_table_lookup_extended (GHashTable *hash_table, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_hash_table_lookup_extended(hash_table, lookup_key, orig_key, value) &
&bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_lookup_extended
  type(c_ptr), value :: hash_table
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! void g_hash_table_foreach (GHashTable *hash_table, GHFunc func, gpointer user_data);
subroutine g_hash_table_foreach(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! gpointer g_hash_table_find (GHashTable *hash_table, GHRFunc predicate, gpointer user_data);
function g_hash_table_find(hash_table, predicate, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_hash_table_find
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: predicate
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_foreach_remove (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_remove(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_remove
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_foreach_steal (GHashTable *hash_table, GHRFunc func, gpointer user_data);
function g_hash_table_foreach_steal(hash_table, func, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_funptr
  integer(c_int) :: g_hash_table_foreach_steal
  type(c_ptr), value :: hash_table
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! guint g_hash_table_size (GHashTable *hash_table);
function g_hash_table_size(hash_table) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_size
  type(c_ptr), value :: hash_table
end function

! GList * g_hash_table_get_keys (GHashTable *hash_table);
function g_hash_table_get_keys(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_get_keys
  type(c_ptr), value :: hash_table
end function

! GList * g_hash_table_get_values (GHashTable *hash_table);
function g_hash_table_get_values(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_get_values
  type(c_ptr), value :: hash_table
end function

!  void g_hash_table_iter_init (GHashTableIter *iter, GHashTable *hash_table);
subroutine g_hash_table_iter_init(iter, hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
  type(c_ptr), value :: hash_table
end subroutine

! gboolean g_hash_table_iter_next (GHashTableIter *iter, gpointer *key, gpointer *value);
function g_hash_table_iter_next(iter, key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hash_table_iter_next
  type(c_ptr), value :: iter
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

! GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
function g_hash_table_iter_get_hash_table(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_iter_get_hash_table
  type(c_ptr), value :: iter
end function

! void g_hash_table_iter_remove (GHashTableIter *iter);
subroutine g_hash_table_iter_remove(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! void g_hash_table_iter_steal (GHashTableIter *iter);
subroutine g_hash_table_iter_steal(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

!  GHashTable* g_hash_table_ref (GHashTable *hash_table);
function g_hash_table_ref(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hash_table_ref
  type(c_ptr), value :: hash_table
end function

! void g_hash_table_unref (GHashTable *hash_table);
subroutine g_hash_table_unref(hash_table) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hash_table
end subroutine

!  gboolean g_str_equal (gconstpointer v1, gconstpointer v2);
function g_str_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_str_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_str_hash (gconstpointer v);
function g_str_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_str_hash
  type(c_ptr), value :: v
end function

!  gboolean g_int_equal (gconstpointer v1, gconstpointer v2);
function g_int_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_int_hash (gconstpointer v);
function g_int_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int_hash
  type(c_ptr), value :: v
end function

!  gboolean g_int64_equal (gconstpointer v1, gconstpointer v2);
function g_int64_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int64_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_int64_hash (gconstpointer v);
function g_int64_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_int64_hash
  type(c_ptr), value :: v
end function

!  gboolean g_double_equal (gconstpointer v1, gconstpointer v2);
function g_double_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_double_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

! guint g_double_hash (gconstpointer v);
function g_double_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_double_hash
  type(c_ptr), value :: v
end function

!  guint g_direct_hash (gconstpointer v) G_GNUC_CONST;
function g_direct_hash(v) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_direct_hash
  type(c_ptr), value :: v
end function

! gboolean g_direct_equal (gconstpointer v1, gconstpointer v2) G_GNUC_CONST;
function g_direct_equal(v1, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_direct_equal
  type(c_ptr), value :: v1
  type(c_ptr), value :: v2
end function

!   GQuark g_spawn_error_quark (void);
function g_spawn_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_spawn_error_quark
end function

!  void g_spawn_close_pid (GPid pid);
subroutine g_spawn_close_pid(pid) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: pid
end subroutine

!   void g_datalist_init (GData **datalist);
subroutine g_datalist_init(datalist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! void g_datalist_clear (GData **datalist);
subroutine g_datalist_clear(datalist) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: datalist
end subroutine

! gpointer g_datalist_id_get_data (GData **datalist, GQuark key_id);
function g_datalist_id_get_data(datalist, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_get_data
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! void g_datalist_id_set_data_full (GData **datalist, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_datalist_id_set_data_full(datalist, key_id, data, destroy_func) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! gpointer g_datalist_id_remove_no_notify (GData **datalist, GQuark key_id);
function g_datalist_id_remove_no_notify(datalist, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_datalist_id_remove_no_notify
  type(c_ptr), value :: datalist
  integer(c_int32_t), value :: key_id
end function

! void g_datalist_foreach (GData **datalist, GDataForeachFunc func, gpointer user_data);
subroutine g_datalist_foreach(datalist, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: datalist
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_datalist_set_flags (GData **datalist, guint flags);
subroutine g_datalist_set_flags(datalist, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! void g_datalist_unset_flags (GData **datalist, guint flags);
subroutine g_datalist_unset_flags(datalist, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: datalist
  integer(c_int), value :: flags
end subroutine

! guint g_datalist_get_flags (GData **datalist);
function g_datalist_get_flags(datalist) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_datalist_get_flags
  type(c_ptr), value :: datalist
end function

!  void g_dataset_destroy (gconstpointer dataset_location);
subroutine g_dataset_destroy(dataset_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dataset_location
end subroutine

! gpointer g_dataset_id_get_data (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_get_data(dataset_location, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_get_data
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! void g_dataset_id_set_data_full (gconstpointer dataset_location, GQuark key_id, gpointer data, GDestroyNotify destroy_func);
subroutine g_dataset_id_set_data_full(dataset_location, key_id, data, destroy_f&
&unc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_func
end subroutine

! gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location, GQuark key_id);
function g_dataset_id_remove_no_notify(dataset_location, key_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_dataset_id_remove_no_notify
  type(c_ptr), value :: dataset_location
  integer(c_int32_t), value :: key_id
end function

! void g_dataset_foreach (gconstpointer dataset_location, GDataForeachFunc func, gpointer user_data);
subroutine g_dataset_foreach(dataset_location, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: dataset_location
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!   char * g_uri_unescape_string (const char *escaped_string, const char *illegal_characters);
function g_uri_unescape_string(escaped_string, illegal_characters) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_string
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! char * g_uri_unescape_segment (const char *escaped_string, const char *escaped_string_end, const char *illegal_characters);
function g_uri_unescape_segment(escaped_string, escaped_string_end, illegal_cha&
&racters) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_unescape_segment
  character(kind=c_char), dimension(*) :: escaped_string
  character(kind=c_char), dimension(*) :: escaped_string_end
  character(kind=c_char), dimension(*) :: illegal_characters
end function

! char * g_uri_parse_scheme (const char *uri);
function g_uri_parse_scheme(uri) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_uri_parse_scheme
  character(kind=c_char), dimension(*) :: uri
end function

! char * g_uri_escape_string (const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
function g_uri_escape_string(unescaped, reserved_chars_allowed, allow_utf8) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_uri_escape_string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  integer(c_int), value :: allow_utf8
end function

!   GRelation* g_relation_new (gint fields);
function g_relation_new(fields) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_relation_new
  integer(c_int), value :: fields
end function

! void g_relation_destroy (GRelation *relation);
subroutine g_relation_destroy(relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: relation
end subroutine

! void g_relation_index (GRelation *relation, gint field, GHashFunc hash_func, GEqualFunc key_equal_func);
subroutine g_relation_index(relation, field, hash_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: relation
  integer(c_int), value :: field
  type(c_funptr), value :: hash_func
  type(c_funptr), value :: key_equal_func
end subroutine

! gint g_relation_delete (GRelation *relation, gconstpointer key, gint field);
function g_relation_delete(relation, key, field) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_relation_delete
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! GTuples* g_relation_select (GRelation *relation, gconstpointer key, gint field);
function g_relation_select(relation, key, field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_relation_select
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! gint g_relation_count (GRelation *relation, gconstpointer key, gint field);
function g_relation_count(relation, key, field) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_relation_count
  type(c_ptr), value :: relation
  type(c_ptr), value :: key
  integer(c_int), value :: field
end function

! void g_relation_print (GRelation *relation);
subroutine g_relation_print(relation) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: relation
end subroutine

!  void g_tuples_destroy (GTuples *tuples);
subroutine g_tuples_destroy(tuples) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tuples
end subroutine

! gpointer g_tuples_index (GTuples *tuples, gint index_, gint field);
function g_tuples_index(tuples, index_, field) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_tuples_index
  type(c_ptr), value :: tuples
  integer(c_int), value :: index_
  integer(c_int), value :: field
end function

!   gboolean g_hostname_is_non_ascii (const gchar *hostname);
function g_hostname_is_non_ascii(hostname) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_hostname_is_non_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! gboolean g_hostname_is_ascii_encoded (const gchar *hostname);
function g_hostname_is_ascii_encoded(hostname) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_hostname_is_ascii_encoded
  character(kind=c_char), dimension(*) :: hostname
end function

! gboolean g_hostname_is_ip_address (const gchar *hostname);
function g_hostname_is_ip_address(hostname) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_hostname_is_ip_address
  character(kind=c_char), dimension(*) :: hostname
end function

!  gchar *g_hostname_to_ascii (const gchar *hostname);
function g_hostname_to_ascii(hostname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_ascii
  character(kind=c_char), dimension(*) :: hostname
end function

! gchar *g_hostname_to_unicode (const gchar *hostname);
function g_hostname_to_unicode(hostname) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_hostname_to_unicode
  character(kind=c_char), dimension(*) :: hostname
end function

!   void g_hook_list_init (GHookList *hook_list, guint hook_size);
subroutine g_hook_list_init(hook_list, hook_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: hook_size
end subroutine

! void g_hook_list_clear (GHookList *hook_list);
subroutine g_hook_list_clear(hook_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
end subroutine

! GHook* g_hook_alloc (GHookList *hook_list);
function g_hook_alloc(hook_list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hook_alloc
  type(c_ptr), value :: hook_list
end function

! void g_hook_free (GHookList *hook_list, GHook *hook);
subroutine g_hook_free(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! GHook * g_hook_ref (GHookList *hook_list, GHook *hook);
function g_hook_ref(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_hook_ref
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end function

! void g_hook_unref (GHookList *hook_list, GHook *hook);
subroutine g_hook_unref(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! gboolean g_hook_destroy (GHookList *hook_list, gulong hook_id);
function g_hook_destroy(hook_list, hook_id) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_long
  integer(c_int) :: g_hook_destroy
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! void g_hook_destroy_link (GHookList *hook_list, GHook *hook);
subroutine g_hook_destroy_link(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! void g_hook_prepend (GHookList *hook_list, GHook *hook);
subroutine g_hook_prepend(hook_list, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
end subroutine

! void g_hook_insert_before (GHookList *hook_list, GHook *sibling, GHook *hook);
subroutine g_hook_insert_before(hook_list, sibling, hook) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: sibling
  type(c_ptr), value :: hook
end subroutine

! void g_hook_insert_sorted (GHookList *hook_list, GHook *hook, GHookCompareFunc func);
subroutine g_hook_insert_sorted(hook_list, hook, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  type(c_funptr), value :: func
end subroutine

! GHook* g_hook_get (GHookList *hook_list, gulong hook_id);
function g_hook_get(hook_list, hook_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr) :: g_hook_get
  type(c_ptr), value :: hook_list
  integer(c_long), value :: hook_id
end function

! GHook* g_hook_find (GHookList *hook_list, gboolean need_valids, GHookFindFunc func, gpointer data);
function g_hook_find(hook_list, need_valids, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr) :: g_hook_find
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end function

! GHook* g_hook_find_data (GHookList *hook_list, gboolean need_valids, gpointer data);
function g_hook_find_data(hook_list, need_valids, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_hook_find_data
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: data
end function

! GHook* g_hook_find_func (GHookList *hook_list, gboolean need_valids, gpointer func);
function g_hook_find_func(hook_list, need_valids, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_hook_find_func
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: func
end function

! GHook* g_hook_find_func_data (GHookList *hook_list, gboolean need_valids, gpointer func, gpointer data);
function g_hook_find_func_data(hook_list, need_valids, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_hook_find_func_data
  type(c_ptr), value :: hook_list
  integer(c_int), value :: need_valids
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

!  GHook* g_hook_first_valid (GHookList *hook_list, gboolean may_be_in_call);
function g_hook_first_valid(hook_list, may_be_in_call) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_hook_first_valid
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_be_in_call
end function

!  GHook* g_hook_next_valid (GHookList *hook_list, GHook *hook, gboolean may_be_in_call);
function g_hook_next_valid(hook_list, hook, may_be_in_call) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_hook_next_valid
  type(c_ptr), value :: hook_list
  type(c_ptr), value :: hook
  integer(c_int), value :: may_be_in_call
end function

!  gint g_hook_compare_ids (GHook *new_hook, GHook *sibling);
function g_hook_compare_ids(new_hook, sibling) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_hook_compare_ids
  type(c_ptr), value :: new_hook
  type(c_ptr), value :: sibling
end function

!  void g_hook_list_invoke (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke(hook_list, may_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
end subroutine

!  void g_hook_list_invoke_check (GHookList *hook_list, gboolean may_recurse);
subroutine g_hook_list_invoke_check(hook_list, may_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
end subroutine

!  void g_hook_list_marshal (GHookList *hook_list, gboolean may_recurse, GHookMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal(hook_list, may_recurse, marshaller, marshal_data&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

! void g_hook_list_marshal_check (GHookList *hook_list, gboolean may_recurse, GHookCheckMarshaller marshaller, gpointer marshal_data);
subroutine g_hook_list_marshal_check(hook_list, may_recurse, marshaller, marsha&
&l_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: hook_list
  integer(c_int), value :: may_recurse
  type(c_funptr), value :: marshaller
  type(c_ptr), value :: marshal_data
end subroutine

! void g_dir_rewind (GDir *dir);
subroutine g_dir_rewind(dir) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dir
end subroutine

! void g_dir_close (GDir *dir);
subroutine g_dir_close(dir) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dir
end subroutine

!   GQuark g_thread_error_quark (void);
function g_thread_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_thread_error_quark
end function

!  guint64 (*g_thread_gettime) (void);
function guint64() bind(c) 
  use iso_c_binding, only: c_int64_t
  integer(c_int64_t) :: guint64
end function

!  void g_thread_init (GThreadFunctions *vtable);
subroutine g_thread_init(vtable) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: vtable
end subroutine

!  void g_thread_init_with_errorcheck_mutexes (GThreadFunctions* vtable);
subroutine g_thread_init_with_errorcheck_mutexes(vtable) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: vtable
end subroutine

!  gboolean g_thread_get_initialized (void);
function g_thread_get_initialized() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_get_initialized
end function

!  GMutex* g_static_mutex_get_mutex_impl (GMutex **mutex);
function g_static_mutex_get_mutex_impl(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_static_mutex_get_mutex_impl
  type(c_ptr), value :: mutex
end function

!  GThread* g_thread_create_full (GThreadFunc func, gpointer data, gulong stack_size, gboolean joinable, gboolean bound, GThreadPriority priority, GError **error);
function g_thread_create_full(func, data, stack_size, joinable, bound, priority&
&, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_long, c_int
  type(c_ptr) :: g_thread_create_full
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  integer(c_long), value :: stack_size
  integer(c_int), value :: joinable
  integer(c_int), value :: bound
  integer(c_int), value :: priority
  type(c_ptr), value :: error
end function

! GThread* g_thread_self (void);
function g_thread_self() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_thread_self
end function

! void g_thread_exit (gpointer retval);
subroutine g_thread_exit(retval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: retval
end subroutine

! gpointer g_thread_join (GThread *thread);
function g_thread_join(thread) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_thread_join
  type(c_ptr), value :: thread
end function

!  void g_thread_set_priority (GThread *thread, GThreadPriority priority);
subroutine g_thread_set_priority(thread, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: thread
  integer(c_int), value :: priority
end subroutine

!  void g_static_mutex_init (GStaticMutex *mutex);
subroutine g_static_mutex_init(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_mutex_free (GStaticMutex *mutex);
subroutine g_static_mutex_free(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

!  void g_static_private_init (GStaticPrivate *private_key);
subroutine g_static_private_init(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: private_key
end subroutine

! gpointer g_static_private_get (GStaticPrivate *private_key);
function g_static_private_get(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_static_private_get
  type(c_ptr), value :: private_key
end function

! void g_static_private_set (GStaticPrivate *private_key, gpointer data, GDestroyNotify notify);
subroutine g_static_private_set(private_key, data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: private_key
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void g_static_private_free (GStaticPrivate *private_key);
subroutine g_static_private_free(private_key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: private_key
end subroutine

!  void g_static_rec_mutex_init (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_init(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_rec_mutex_lock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_lock(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);
function g_static_rec_mutex_trylock(mutex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_static_rec_mutex_trylock
  type(c_ptr), value :: mutex
end function

! void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_unlock(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

! void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex, guint depth);
subroutine g_static_rec_mutex_lock_full(mutex, depth) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: mutex
  integer(c_int), value :: depth
end subroutine

! guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);
function g_static_rec_mutex_unlock_full(mutex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_static_rec_mutex_unlock_full
  type(c_ptr), value :: mutex
end function

! void g_static_rec_mutex_free (GStaticRecMutex *mutex);
subroutine g_static_rec_mutex_free(mutex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: mutex
end subroutine

!  void g_static_rw_lock_init (GStaticRWLock* lock);
subroutine g_static_rw_lock_init(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_reader_lock (GStaticRWLock* lock);
subroutine g_static_rw_lock_reader_lock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! gboolean g_static_rw_lock_reader_trylock (GStaticRWLock* lock);
function g_static_rw_lock_reader_trylock(lock) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_static_rw_lock_reader_trylock
  type(c_ptr), value :: lock
end function

! void g_static_rw_lock_reader_unlock (GStaticRWLock* lock);
subroutine g_static_rw_lock_reader_unlock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_writer_lock (GStaticRWLock* lock);
subroutine g_static_rw_lock_writer_lock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! gboolean g_static_rw_lock_writer_trylock (GStaticRWLock* lock);
function g_static_rw_lock_writer_trylock(lock) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_static_rw_lock_writer_trylock
  type(c_ptr), value :: lock
end function

! void g_static_rw_lock_writer_unlock (GStaticRWLock* lock);
subroutine g_static_rw_lock_writer_unlock(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

! void g_static_rw_lock_free (GStaticRWLock* lock);
subroutine g_static_rw_lock_free(lock) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: lock
end subroutine

!  void g_thread_foreach (GFunc thread_func, gpointer user_data);
subroutine g_thread_foreach(thread_func, user_data) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr), value :: thread_func
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_once_impl (GOnce *once, GThreadFunc func, gpointer arg);
function g_once_impl(once, func, arg) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_once_impl
  type(c_ptr), value :: once
  type(c_funptr), value :: func
  type(c_ptr), value :: arg
end function

! gboolean g_once_init_enter_impl (volatile gsize *value_location);
function g_once_init_enter_impl(value_location) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_once_init_enter_impl
  type(c_ptr), value :: value_location
end function

! void g_once_init_leave (volatile gsize *value_location, gsize initialization_value);
subroutine g_once_init_leave(value_location, initialization_value) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: value_location
  integer(c_size_t), value :: initialization_value
end subroutine

!   GCache* g_cache_new (GCacheNewFunc value_new_func, GCacheDestroyFunc value_destroy_func, GCacheDupFunc key_dup_func, GCacheDestroyFunc key_destroy_func, GHashFunc hash_key_func, GHashFunc hash_value_func, GEqualFunc key_equal_func);
function g_cache_new(value_new_func, value_destroy_func, key_dup_func, key_dest&
&roy_func, hash_key_func, hash_value_func, key_equal_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cache_new
  type(c_funptr), value :: value_new_func
  type(c_funptr), value :: value_destroy_func
  type(c_funptr), value :: key_dup_func
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: hash_key_func
  type(c_funptr), value :: hash_value_func
  type(c_funptr), value :: key_equal_func
end function

! void g_cache_destroy (GCache *cache);
subroutine g_cache_destroy(cache) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
end subroutine

! gpointer g_cache_insert (GCache *cache, gpointer key);
function g_cache_insert(cache, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_cache_insert
  type(c_ptr), value :: cache
  type(c_ptr), value :: key
end function

! void g_cache_remove (GCache *cache, gconstpointer value);
subroutine g_cache_remove(cache, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: cache
  type(c_ptr), value :: value
end subroutine

! void g_cache_key_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_key_foreach(cache, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_cache_value_foreach (GCache *cache, GHFunc func, gpointer user_data);
subroutine g_cache_value_foreach(cache, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!   GError* g_error_new (GQuark domain, gint code, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
function g_error_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_error_new
end function

!  GError* g_error_new_literal (GQuark domain, gint code, const gchar *message);
function g_error_new_literal(domain, code, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_literal
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end function

! GError* g_error_new_valist (GQuark domain, gint code, const gchar *format, va_list args);
function g_error_new_valist(domain, code, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr) :: g_error_new_valist
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  void g_error_free (GError *error);
subroutine g_error_free(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: error
end subroutine

! GError* g_error_copy (const GError *error);
function g_error_copy(error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_error_copy
  type(c_ptr), value :: error
end function

!  gboolean g_error_matches (const GError *error, GQuark domain, gint code);
function g_error_matches(error, domain, code) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_error_matches
  type(c_ptr), value :: error
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
end function

!  void g_set_error (GError **err, GQuark domain, gint code, const gchar *format, ...) G_GNUC_PRINTF (4, 5);
subroutine g_set_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_set_error_literal (GError **err, GQuark domain, gint code, const gchar *message);
subroutine g_set_error_literal(err, domain, code, message) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_int, c_char
  type(c_ptr), value :: err
  integer(c_int32_t), value :: domain
  integer(c_int), value :: code
  character(kind=c_char), dimension(*) :: message
end subroutine

!  void g_propagate_error (GError **dest, GError *src);
subroutine g_propagate_error(dest, src) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dest
  type(c_ptr), value :: src
end subroutine

!  void g_clear_error (GError **err);
subroutine g_clear_error(err) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: err
end subroutine

!  void g_prefix_error (GError **err, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_prefix_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_propagate_prefixed_error (GError **dest, GError *src, const gchar *format, ...) G_GNUC_PRINTF (3, 4);
subroutine g_propagate_prefixed_error() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_CONST_RETURN gchar* g_get_host_name (void);
function g_get_host_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_host_name
end function

! gchar* g_get_prgname (void);
function g_get_prgname() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_prgname
end function

! void g_set_prgname (const gchar *prgname);
subroutine g_set_prgname(prgname) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: prgname
end subroutine

! G_CONST_RETURN gchar* g_get_application_name (void);
function g_get_application_name() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_application_name
end function

! void g_set_application_name (const gchar *application_name);
subroutine g_set_application_name(application_name) bind(c) 
  use iso_c_binding, only: c_char
  character(kind=c_char), dimension(*) :: application_name
end subroutine

!  void g_reload_user_special_dirs_cache (void);
subroutine g_reload_user_special_dirs_cache() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_CONST_RETURN gchar* g_get_user_data_dir (void);
function g_get_user_data_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_data_dir
end function

! G_CONST_RETURN gchar* g_get_user_config_dir (void);
function g_get_user_config_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_config_dir
end function

! G_CONST_RETURN gchar* g_get_user_cache_dir (void);
function g_get_user_cache_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_cache_dir
end function

! G_CONST_RETURN gchar* G_CONST_RETURN * g_get_system_data_dirs (void);
function g_get_system_data_dirs() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_system_data_dirs
end function

!  G_CONST_RETURN gchar* G_CONST_RETURN * g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void));
function g_win32_get_system_data_dirs_for_module() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_get_system_data_dirs_for_module
end function

!  const gchar * g_get_user_runtime_dir (void);
function g_get_user_runtime_dir() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_user_runtime_dir
end function

!  G_CONST_RETURN gchar* G_CONST_RETURN * g_get_language_names (void);
function g_get_language_names() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_language_names
end function

!  gchar **g_get_locale_variants (const gchar *locale);
function g_get_locale_variants(locale) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_get_locale_variants
  character(kind=c_char), dimension(*) :: locale
end function

!  G_CONST_RETURN gchar* g_get_user_special_dir (GUserDirectory directory);
function g_get_user_special_dir(directory) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_get_user_special_dir
  integer(c_int), value :: directory
end function

!  guint g_parse_debug_string (const gchar *string, const GDebugKey *keys, guint nkeys);
function g_parse_debug_string(string, keys, nkeys) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_parse_debug_string
  character(kind=c_char), dimension(*) :: string
  type(c_ptr), value :: keys
  integer(c_int), value :: nkeys
end function

!  gint g_snprintf (gchar *string, gulong n, gchar const *format, ...) G_GNUC_PRINTF (3, 4);
function g_snprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_snprintf
end function

! gint g_vsnprintf (gchar *string, gulong n, gchar const *format, va_list args);
function g_vsnprintf(string, n, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_long, c_ptr
  integer(c_int) :: g_vsnprintf
  character(kind=c_char), dimension(*) :: string
  integer(c_long), value :: n
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!  gboolean g_path_is_absolute (const gchar *file_name);
function g_path_is_absolute(file_name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_path_is_absolute
  character(kind=c_char), dimension(*) :: file_name
end function

!  G_CONST_RETURN gchar* g_path_skip_root (const gchar *file_name);
function g_path_skip_root(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_skip_root
  character(kind=c_char), dimension(*) :: file_name
end function

!  G_CONST_RETURN gchar* g_basename (const gchar *file_name);
function g_basename(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_basename
  character(kind=c_char), dimension(*) :: file_name
end function

! gchar* g_path_get_basename (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_basename(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_get_basename
  character(kind=c_char), dimension(*) :: file_name
end function

! gchar* g_path_get_dirname (const gchar *file_name) G_GNUC_MALLOC;
function g_path_get_dirname(file_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_path_get_dirname
  character(kind=c_char), dimension(*) :: file_name
end function

!  void g_nullify_pointer (gpointer *nullify_location);
subroutine g_nullify_pointer(nullify_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: nullify_location
end subroutine

! gchar** g_listenv (void);
function g_listenv() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_listenv
end function

! gchar** g_get_environ (void);
function g_get_environ() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_get_environ
end function

!  void g_atexit (GVoidFunc func);
subroutine g_atexit(func) bind(c) 
  use iso_c_binding, only: c_funptr
  type(c_funptr), value :: func
end subroutine

!  int atexit (void (*)(void));
function atexit() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: atexit
end function

! gint g_bit_nth_msf (gulong mask, gint nth_bit) G_GNUC_CONST;
function g_bit_nth_msf(mask, nth_bit) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int) :: g_bit_nth_msf
  integer(c_long), value :: mask
  integer(c_int), value :: nth_bit
end function

! guint g_bit_storage (gulong number) G_GNUC_CONST;
function g_bit_storage(number) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int) :: g_bit_storage
  integer(c_long), value :: number
end function

! gpointer g_trash_stack_pop (GTrashStack **stack_p);
function g_trash_stack_pop(stack_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_trash_stack_pop
  type(c_ptr), value :: stack_p
end function

! gpointer g_trash_stack_peek (GTrashStack **stack_p);
function g_trash_stack_peek(stack_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_trash_stack_peek
  type(c_ptr), value :: stack_p
end function

! guint g_trash_stack_height (GTrashStack **stack_p);
function g_trash_stack_height(stack_p) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_trash_stack_height
  type(c_ptr), value :: stack_p
end function

!  const gchar * glib_check_version (guint required_major, guint required_minor, guint required_micro);
function glib_check_version(required_major, required_minor, required_micro) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: glib_check_version
  integer(c_int), value :: required_major
  integer(c_int), value :: required_minor
  integer(c_int), value :: required_micro
end function

!   GStringChunk* g_string_chunk_new (gsize size);
function g_string_chunk_new(size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_chunk_new
  integer(c_size_t), value :: size
end function

! void g_string_chunk_free (GStringChunk *chunk);
subroutine g_string_chunk_free(chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! void g_string_chunk_clear (GStringChunk *chunk);
subroutine g_string_chunk_clear(chunk) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: chunk
end subroutine

! gchar* g_string_chunk_insert (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert(chunk, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

! gchar* g_string_chunk_insert_len (GStringChunk *chunk, const gchar *string, gssize len);
function g_string_chunk_insert_len(chunk, string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_chunk_insert_len
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end function

! gchar* g_string_chunk_insert_const (GStringChunk *chunk, const gchar *string);
function g_string_chunk_insert_const(chunk, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_chunk_insert_const
  type(c_ptr), value :: chunk
  character(kind=c_char), dimension(*) :: string
end function

!  GString* g_string_new (const gchar *init);
function g_string_new(init) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_new
  character(kind=c_char), dimension(*) :: init
end function

! GString* g_string_new_len (const gchar *init, gssize len);
function g_string_new_len(init, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_new_len
  character(kind=c_char), dimension(*) :: init
  integer(c_size_t), value :: len
end function

! GString* g_string_sized_new (gsize dfl_size);
function g_string_sized_new(dfl_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_sized_new
  integer(c_size_t), value :: dfl_size
end function

! gchar* g_string_free (GString *string, gboolean free_segment);
function g_string_free(string, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_string_free
  type(c_ptr), value :: string
  integer(c_int), value :: free_segment
end function

! gboolean g_string_equal (const GString *v, const GString *v2);
function g_string_equal(v, v2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_string_equal
  type(c_ptr), value :: v
  type(c_ptr), value :: v2
end function

! guint g_string_hash (const GString *str);
function g_string_hash(str) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_string_hash
  type(c_ptr), value :: str
end function

! GString* g_string_assign (GString *string, const gchar *rval);
function g_string_assign(string, rval) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_assign
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: rval
end function

! GString* g_string_truncate (GString *string, gsize len);
function g_string_truncate(string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_truncate
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GString* g_string_set_size (GString *string, gsize len);
function g_string_set_size(string, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_set_size
  type(c_ptr), value :: string
  integer(c_size_t), value :: len
end function

! GString* g_string_insert_len (GString *string, gssize pos, const gchar *val, gssize len);
function g_string_insert_len(string, pos, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_append (GString *string, const gchar *val);
function g_string_append(string, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_append
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_append_len (GString *string, const gchar *val, gssize len);
function g_string_append_len(string, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_append_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_append_c (GString *string, gchar c);
function g_string_append_c(string, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr) :: g_string_append_c
  type(c_ptr), value :: string
  integer(kind=c_int8_t), value :: c
end function

! GString* g_string_append_unichar (GString *string, gunichar wc);
function g_string_append_unichar(string, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_string_append_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GString* g_string_prepend (GString *string, const gchar *val);
function g_string_prepend(string, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_string_prepend
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_prepend_c (GString *string, gchar c);
function g_string_prepend_c(string, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr) :: g_string_prepend_c
  type(c_ptr), value :: string
  integer(kind=c_int8_t), value :: c
end function

! GString* g_string_prepend_unichar (GString *string, gunichar wc);
function g_string_prepend_unichar(string, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_string_prepend_unichar
  type(c_ptr), value :: string
  integer(c_int32_t), value :: wc
end function

! GString* g_string_prepend_len (GString *string, const gchar *val, gssize len);
function g_string_prepend_len(string, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_string_prepend_len
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_insert (GString *string, gssize pos, const gchar *val);
function g_string_insert(string, pos, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_insert
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_insert_c (GString *string, gssize pos, gchar c);
function g_string_insert_c(string, pos, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int8_t
  type(c_ptr) :: g_string_insert_c
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(kind=c_int8_t), value :: c
end function

! GString* g_string_insert_unichar (GString *string, gssize pos, gunichar wc);
function g_string_insert_unichar(string, pos, wc) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_string_insert_unichar
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_int32_t), value :: wc
end function

! GString* g_string_overwrite (GString *string, gsize pos, const gchar *val);
function g_string_overwrite(string, pos, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
end function

! GString* g_string_overwrite_len (GString *string, gsize pos, const gchar *val, gssize len);
function g_string_overwrite_len(string, pos, val, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_string_overwrite_len
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  character(kind=c_char), dimension(*) :: val
  integer(c_size_t), value :: len
end function

! GString* g_string_erase (GString *string, gssize pos, gssize len);
function g_string_erase(string, pos, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_string_erase
  type(c_ptr), value :: string
  integer(c_size_t), value :: pos
  integer(c_size_t), value :: len
end function

! GString* g_string_ascii_down (GString *string);
function g_string_ascii_down(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_ascii_down
  type(c_ptr), value :: string
end function

! GString* g_string_ascii_up (GString *string);
function g_string_ascii_up(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_ascii_up
  type(c_ptr), value :: string
end function

! void g_string_vprintf (GString *string, const gchar *format, va_list args);
subroutine g_string_vprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! void g_string_printf (GString *string, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_string_printf() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_string_append_vprintf (GString *string, const gchar *format, va_list args);
subroutine g_string_append_vprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end subroutine

! void g_string_append_printf (GString *string, const gchar *format, ...) G_GNUC_PRINTF (2, 3);
subroutine g_string_append_printf() bind(c) 
  use iso_c_binding, only: 
end subroutine

! GString * g_string_append_uri_escaped(GString *string, const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);
function g_string_append_uri_escaped(string, unescaped, reserved_chars_allowed,&
& allow_utf8) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_string_append_uri_escaped
  type(c_ptr), value :: string
  character(kind=c_char), dimension(*) :: unescaped
  character(kind=c_char), dimension(*) :: reserved_chars_allowed
  integer(c_int), value :: allow_utf8
end function

!  static inline GString* g_string_append_c_inline (GString *gstring, gchar c)  GString* g_string_down (GString *string);
function g_string_append_c_inline(gstring, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr) :: g_string_append_c_inline
  type(c_ptr), value :: gstring
  integer(kind=c_int8_t), value :: c
end function

! GString* g_string_up (GString *string);
function g_string_up(string) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_string_up
  type(c_ptr), value :: string
end function

!   gint g_atomic_int_exchange_and_add (volatile gint G_GNUC_MAY_ALIAS *atomic, gint val);
function g_atomic_int_exchange_and_add(atomic, val) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_int_exchange_and_add
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end function

! void g_atomic_int_add (volatile gint G_GNUC_MAY_ALIAS *atomic, gint val);
subroutine g_atomic_int_add(atomic, val) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: atomic
  integer(c_int), value :: val
end subroutine

! gboolean g_atomic_int_compare_and_exchange (volatile gint G_GNUC_MAY_ALIAS *atomic, gint oldval, gint newval);
function g_atomic_int_compare_and_exchange(atomic, oldval, newval) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_int_compare_and_exchange
  type(c_ptr), value :: atomic
  integer(c_int), value :: oldval
  integer(c_int), value :: newval
end function

! gboolean g_atomic_pointer_compare_and_exchange (volatile gpointer G_GNUC_MAY_ALIAS *atomic, gpointer oldval, gpointer newval);
function g_atomic_pointer_compare_and_exchange(atomic, oldval, newval) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_pointer_compare_and_exchange
  type(c_ptr), value :: atomic
  type(c_ptr), value :: oldval
  type(c_ptr), value :: newval
end function

!  gint g_atomic_int_get (volatile gint G_GNUC_MAY_ALIAS *atomic);
function g_atomic_int_get(atomic) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_atomic_int_get
  type(c_ptr), value :: atomic
end function

! void g_atomic_int_set (volatile gint G_GNUC_MAY_ALIAS *atomic, gint newval);
subroutine g_atomic_int_set(atomic, newval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: atomic
  integer(c_int), value :: newval
end subroutine

! gpointer g_atomic_pointer_get (volatile gpointer G_GNUC_MAY_ALIAS *atomic);
function g_atomic_pointer_get(atomic) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_atomic_pointer_get
  type(c_ptr), value :: atomic
end function

! void g_atomic_pointer_set (volatile gpointer G_GNUC_MAY_ALIAS *atomic, gpointer newval);
subroutine g_atomic_pointer_set(atomic, newval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: atomic
  type(c_ptr), value :: newval
end subroutine

!   GQuark g_key_file_error_quark (void);
function g_key_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_key_file_error_quark
end function

!  GKeyFile *g_key_file_new (void);
function g_key_file_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_new
end function

! void g_key_file_free (GKeyFile *key_file);
subroutine g_key_file_free(key_file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: key_file
end subroutine

! void g_key_file_set_list_separator (GKeyFile *key_file, gchar separator);
subroutine g_key_file_set_list_separator(key_file, separator) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr), value :: key_file
  integer(kind=c_int8_t), value :: separator
end subroutine

! gboolean g_key_file_load_from_file (GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_file(key_file, file, flags, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_file
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_data (GKeyFile *key_file, const gchar *data, gsize length, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data(key_file, data, length, flags, error) bind(c&
&) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_key_file_load_from_data
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_dirs (GKeyFile *key_file, const gchar *file, const gchar **search_dirs, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_dirs(key_file, file, search_dirs, full_path, flag&
&s, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: search_dirs
  type(c_ptr), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file, const gchar *file, gchar **full_path, GKeyFileFlags flags, GError **error);
function g_key_file_load_from_data_dirs(key_file, file, full_path, flags, error&
&) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_load_from_data_dirs
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: full_path
  integer(c_int), value :: flags
  type(c_ptr), value :: error
end function

! gchar *g_key_file_to_data (GKeyFile *key_file, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_to_data(key_file, length, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_to_data
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_start_group (GKeyFile *key_file) G_GNUC_MALLOC;
function g_key_file_get_start_group(key_file) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_get_start_group
  type(c_ptr), value :: key_file
end function

! gchar **g_key_file_get_groups (GKeyFile *key_file, gsize *length) G_GNUC_MALLOC;
function g_key_file_get_groups(key_file, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_key_file_get_groups
  type(c_ptr), value :: key_file
  type(c_ptr), value :: length
end function

! gchar **g_key_file_get_keys (GKeyFile *key_file, const gchar *group_name, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_keys(key_file, group_name, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_keys
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_key_file_has_group (GKeyFile *key_file, const gchar *group_name);
function g_key_file_has_group(key_file, group_name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_has_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
end function

! gboolean g_key_file_has_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_has_key(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_has_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_value(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_value
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_value (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *value);
subroutine g_key_file_set_value(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: value
end subroutine

! gchar *g_key_file_get_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_string(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *string);
subroutine g_key_file_set_string(key_file, group_name, key, string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: string
end subroutine

! gchar *g_key_file_get_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, GError **error) G_GNUC_MALLOC;
function g_key_file_get_locale_string(key_file, group_name, key, locale, error)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: error
end function

! void g_key_file_set_locale_string (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar *string);
subroutine g_key_file_set_locale_string(key_file, group_name, key, locale, stri&
&ng) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: string
end subroutine

! gboolean g_key_file_get_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_boolean(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_get_boolean
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_boolean (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean value);
subroutine g_key_file_set_boolean(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

! gint g_key_file_get_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_integer(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_get_integer
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_integer (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint value);
subroutine g_key_file_set_integer(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), value :: value
end subroutine

! gint64 g_key_file_get_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_int64(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_int64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_int64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint64 value);
subroutine g_key_file_set_int64(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! guint64 g_key_file_get_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_uint64(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr, c_char
  integer(c_int64_t) :: g_key_file_get_uint64
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_uint64 (GKeyFile *key_file, const gchar *group_name, const gchar *key, guint64 value);
subroutine g_key_file_set_uint64(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int64_t), value :: value
end subroutine

! gdouble g_key_file_get_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_get_double(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_double, c_ptr, c_char
  real(c_double) :: g_key_file_get_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! void g_key_file_set_double (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble value);
subroutine g_key_file_set_double(key_file, group_name, key, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), value :: value
end subroutine

! gchar **g_key_file_get_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_string_list(key_file, group_name, key, length, error) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar * const list[], gsize length);
subroutine g_key_file_set_string_list(key_file, group_name, key, list, length) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gchar **g_key_file_get_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_locale_string_list(key_file, group_name, key, locale, l&
&ength, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_locale_string_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_locale_string_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *locale, const gchar * const list[], gsize length);
subroutine g_key_file_set_locale_string_list(key_file, group_name, key, locale,&
& list, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: locale
  character(kind=c_char), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gboolean *g_key_file_get_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_boolean_list(key_file, group_name, key, length, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_boolean_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_boolean_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gboolean list[], gsize length);
subroutine g_key_file_set_boolean_list(key_file, group_name, key, list, length)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gint *g_key_file_get_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_integer_list(key_file, group_name, key, length, error) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_integer_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gdouble list[], gsize length);
subroutine g_key_file_set_double_list(key_file, group_name, key, list, length) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  real(c_double), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gdouble *g_key_file_get_double_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gsize *length, GError **error) G_GNUC_MALLOC;
function g_key_file_get_double_list(key_file, group_name, key, length, error) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_double_list
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_key_file_set_integer_list (GKeyFile *key_file, const gchar *group_name, const gchar *key, gint list[], gsize length);
subroutine g_key_file_set_integer_list(key_file, group_name, key, list, length)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_size_t
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  integer(c_int), dimension(*) :: list
  integer(c_size_t), value :: length
end subroutine

! gboolean g_key_file_set_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, const gchar *comment, GError **error);
function g_key_file_set_comment(key_file, group_name, key, comment, error) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_set_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  character(kind=c_char), dimension(*) :: comment
  type(c_ptr), value :: error
end function

! gchar *g_key_file_get_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error) G_GNUC_MALLOC;
function g_key_file_get_comment(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_key_file_get_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

!  gboolean g_key_file_remove_comment (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_comment(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_comment
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gboolean g_key_file_remove_key (GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);
function g_key_file_remove_key(key_file, group_name, key, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_key
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: error
end function

! gboolean g_key_file_remove_group (GKeyFile *key_file, const gchar *group_name, GError **error);
function g_key_file_remove_group(key_file, group_name, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_key_file_remove_group
  type(c_ptr), value :: key_file
  character(kind=c_char), dimension(*) :: group_name
  type(c_ptr), value :: error
end function

!   GQueue* g_queue_new (void);
function g_queue_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_new
end function

! void g_queue_free (GQueue *queue);
subroutine g_queue_free(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_queue_init (GQueue *queue);
subroutine g_queue_init(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! void g_queue_clear (GQueue *queue);
subroutine g_queue_clear(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! gboolean g_queue_is_empty (GQueue *queue);
function g_queue_is_empty(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_is_empty
  type(c_ptr), value :: queue
end function

! guint g_queue_get_length (GQueue *queue);
function g_queue_get_length(queue) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_get_length
  type(c_ptr), value :: queue
end function

! void g_queue_reverse (GQueue *queue);
subroutine g_queue_reverse(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
end subroutine

! GQueue * g_queue_copy (GQueue *queue);
function g_queue_copy(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_copy
  type(c_ptr), value :: queue
end function

! void g_queue_foreach (GQueue *queue, GFunc func, gpointer user_data);
subroutine g_queue_foreach(queue, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GList * g_queue_find (GQueue *queue, gconstpointer data);
function g_queue_find(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_find
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! GList * g_queue_find_custom (GQueue *queue, gconstpointer data, GCompareFunc func);
function g_queue_find_custom(queue, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_queue_find_custom
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! void g_queue_sort (GQueue *queue, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_queue_sort(queue, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!  void g_queue_push_head (GQueue *queue, gpointer data);
subroutine g_queue_push_head(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_push_tail (GQueue *queue, gpointer data);
subroutine g_queue_push_tail(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_push_nth (GQueue *queue, gpointer data, gint n);
subroutine g_queue_push_nth(queue, data, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  integer(c_int), value :: n
end subroutine

! gpointer g_queue_pop_head (GQueue *queue);
function g_queue_pop_head(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_head
  type(c_ptr), value :: queue
end function

! gpointer g_queue_pop_tail (GQueue *queue);
function g_queue_pop_tail(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_tail
  type(c_ptr), value :: queue
end function

! gpointer g_queue_pop_nth (GQueue *queue, guint n);
function g_queue_pop_nth(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gpointer g_queue_peek_head (GQueue *queue);
function g_queue_peek_head(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_head
  type(c_ptr), value :: queue
end function

! gpointer g_queue_peek_tail (GQueue *queue);
function g_queue_peek_tail(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_tail
  type(c_ptr), value :: queue
end function

! gpointer g_queue_peek_nth (GQueue *queue, guint n);
function g_queue_peek_nth(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gint g_queue_index (GQueue *queue, gconstpointer data);
function g_queue_index(queue, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end function

! void g_queue_remove (GQueue *queue, gconstpointer data);
subroutine g_queue_remove(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_remove_all (GQueue *queue, gconstpointer data);
subroutine g_queue_remove_all(queue, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_before (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_before(queue, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_after (GQueue *queue, GList *sibling, gpointer data);
subroutine g_queue_insert_after(queue, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end subroutine

! void g_queue_insert_sorted (GQueue *queue, gpointer data, GCompareDataFunc func, gpointer user_data);
subroutine g_queue_insert_sorted(queue, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_queue_push_head_link (GQueue *queue, GList *link_);
subroutine g_queue_push_head_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_push_tail_link (GQueue *queue, GList *link_);
subroutine g_queue_push_tail_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_push_nth_link (GQueue *queue, gint n, GList *link_);
subroutine g_queue_push_nth_link(queue, n, link_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: queue
  integer(c_int), value :: n
  type(c_ptr), value :: link_
end subroutine

! GList* g_queue_pop_head_link (GQueue *queue);
function g_queue_pop_head_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_head_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_pop_tail_link (GQueue *queue);
function g_queue_pop_tail_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_pop_tail_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_pop_nth_link (GQueue *queue, guint n);
function g_queue_pop_nth_link(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_pop_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! GList* g_queue_peek_head_link (GQueue *queue);
function g_queue_peek_head_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_head_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_peek_tail_link (GQueue *queue);
function g_queue_peek_tail_link(queue) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_queue_peek_tail_link
  type(c_ptr), value :: queue
end function

! GList* g_queue_peek_nth_link (GQueue *queue, guint n);
function g_queue_peek_nth_link(queue, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_queue_peek_nth_link
  type(c_ptr), value :: queue
  integer(c_int), value :: n
end function

! gint g_queue_link_index (GQueue *queue, GList *link_);
function g_queue_link_index(queue, link_) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_queue_link_index
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end function

! void g_queue_unlink (GQueue *queue, GList *link_);
subroutine g_queue_unlink(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

! void g_queue_delete_link (GQueue *queue, GList *link_);
subroutine g_queue_delete_link(queue, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: queue
  type(c_ptr), value :: link_
end subroutine

!   gint g_win32_ftruncate (gint f, guint size);
function g_win32_ftruncate(f, size) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_win32_ftruncate
  integer(c_int), value :: f
  integer(c_int), value :: size
end function

!  gchar* g_win32_getlocale (void);
function g_win32_getlocale() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_getlocale
end function

!  gchar* g_win32_error_message (gint error);
function g_win32_error_message(error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_win32_error_message
  integer(c_int), value :: error
end function

!  gchar* g_win32_get_package_installation_directory_of_module (gpointer hmodule);
function g_win32_get_package_installation_directory_of_module(hmodule) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_win32_get_package_installation_directory_of_module
  type(c_ptr), value :: hmodule
end function

!  guint g_win32_get_windows_version (void);
function g_win32_get_windows_version() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_win32_get_windows_version
end function

!  gchar* g_win32_locale_filename_from_utf8 (const gchar *utf8filename);
function g_win32_locale_filename_from_utf8(utf8filename) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_win32_locale_filename_from_utf8
  character(kind=c_char), dimension(*) :: utf8filename
end function

!   GArray* g_array_new (gboolean zero_terminated, gboolean clear_, guint element_size);
function g_array_new(zero_terminated, clear_, element_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_new
  integer(c_int), value :: zero_terminated
  integer(c_int), value :: clear_
  integer(c_int), value :: element_size
end function

! GArray* g_array_sized_new (gboolean zero_terminated, gboolean clear_, guint element_size, guint reserved_size);
function g_array_sized_new(zero_terminated, clear_, element_size, reserved_size&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_sized_new
  integer(c_int), value :: zero_terminated
  integer(c_int), value :: clear_
  integer(c_int), value :: element_size
  integer(c_int), value :: reserved_size
end function

! gchar* g_array_free (GArray *array, gboolean free_segment);
function g_array_free(array, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_segment
end function

! GArray *g_array_ref (GArray *array);
function g_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_array_ref
  type(c_ptr), value :: array
end function

! void g_array_unref (GArray *array);
subroutine g_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! guint g_array_get_element_size (GArray *array);
function g_array_get_element_size(array) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_array_get_element_size
  type(c_ptr), value :: array
end function

! GArray* g_array_append_vals (GArray *array, gconstpointer data, guint len);
function g_array_append_vals(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_append_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_prepend_vals (GArray *array, gconstpointer data, guint len);
function g_array_prepend_vals(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_prepend_vals
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_insert_vals (GArray *array, guint index_, gconstpointer data, guint len);
function g_array_insert_vals(array, index_, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_insert_vals
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GArray* g_array_set_size (GArray *array, guint length);
function g_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GArray* g_array_remove_index (GArray *array, guint index_);
function g_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GArray* g_array_remove_index_fast (GArray *array, guint index_);
function g_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GArray* g_array_remove_range (GArray *array, guint index_, guint length);
function g_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! void g_array_sort (GArray *array, GCompareFunc compare_func);
subroutine g_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_array_sort_with_data (GArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!  GPtrArray* g_ptr_array_new (void);
function g_ptr_array_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_ptr_array_new
end function

! GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify element_free_func);
function g_ptr_array_new_with_free_func(element_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_ptr_array_new_with_free_func
  type(c_funptr), value :: element_free_func
end function

! GPtrArray* g_ptr_array_sized_new (guint reserved_size);
function g_ptr_array_sized_new(reserved_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_sized_new
  integer(c_int), value :: reserved_size
end function

! gpointer* g_ptr_array_free (GPtrArray *array, gboolean free_seg);
function g_ptr_array_free(array, free_seg) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_seg
end function

! GPtrArray* g_ptr_array_ref (GPtrArray *array);
function g_ptr_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_ptr_array_ref
  type(c_ptr), value :: array
end function

! void g_ptr_array_unref (GPtrArray *array);
subroutine g_ptr_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! void g_ptr_array_set_free_func (GPtrArray *array, GDestroyNotify element_free_func);
subroutine g_ptr_array_set_free_func(array, element_free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: element_free_func
end subroutine

! void g_ptr_array_set_size (GPtrArray *array, gint length);
subroutine g_ptr_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: length
end subroutine

! gpointer g_ptr_array_remove_index (GPtrArray *array, guint index_);
function g_ptr_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! gpointer g_ptr_array_remove_index_fast (GPtrArray *array, guint index_);
function g_ptr_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_ptr_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! gboolean g_ptr_array_remove (GPtrArray *array, gpointer data);
function g_ptr_array_remove(array, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_ptr_array_remove
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! gboolean g_ptr_array_remove_fast (GPtrArray *array, gpointer data);
function g_ptr_array_remove_fast(array, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_ptr_array_remove_fast
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end function

! void g_ptr_array_remove_range (GPtrArray *array, guint index_, guint length);
subroutine g_ptr_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end subroutine

! void g_ptr_array_add (GPtrArray *array, gpointer data);
subroutine g_ptr_array_add(array, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
  type(c_ptr), value :: data
end subroutine

! void g_ptr_array_sort (GPtrArray *array, GCompareFunc compare_func);
subroutine g_ptr_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_ptr_array_sort_with_data (GPtrArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_ptr_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

! void g_ptr_array_foreach (GPtrArray *array, GFunc func, gpointer user_data);
subroutine g_ptr_array_foreach(array, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  GByteArray* g_byte_array_new (void);
function g_byte_array_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_byte_array_new
end function

! GByteArray* g_byte_array_sized_new (guint reserved_size);
function g_byte_array_sized_new(reserved_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_sized_new
  integer(c_int), value :: reserved_size
end function

! guint8* g_byte_array_free (GByteArray *array, gboolean free_segment);
function g_byte_array_free(array, free_segment) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_free
  type(c_ptr), value :: array
  integer(c_int), value :: free_segment
end function

! GByteArray *g_byte_array_ref (GByteArray *array);
function g_byte_array_ref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_byte_array_ref
  type(c_ptr), value :: array
end function

! void g_byte_array_unref (GByteArray *array);
subroutine g_byte_array_unref(array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: array
end subroutine

! GByteArray* g_byte_array_append (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_append(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_append
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GByteArray* g_byte_array_prepend (GByteArray *array, const guint8 *data, guint len);
function g_byte_array_prepend(array, data, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_prepend
  type(c_ptr), value :: array
  type(c_ptr), value :: data
  integer(c_int), value :: len
end function

! GByteArray* g_byte_array_set_size (GByteArray *array, guint length);
function g_byte_array_set_size(array, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_set_size
  type(c_ptr), value :: array
  integer(c_int), value :: length
end function

! GByteArray* g_byte_array_remove_index (GByteArray *array, guint index_);
function g_byte_array_remove_index(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GByteArray* g_byte_array_remove_index_fast (GByteArray *array, guint index_);
function g_byte_array_remove_index_fast(array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_index_fast
  type(c_ptr), value :: array
  integer(c_int), value :: index_
end function

! GByteArray* g_byte_array_remove_range (GByteArray *array, guint index_, guint length);
function g_byte_array_remove_range(array, index_, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_byte_array_remove_range
  type(c_ptr), value :: array
  integer(c_int), value :: index_
  integer(c_int), value :: length
end function

! void g_byte_array_sort (GByteArray *array, GCompareFunc compare_func);
subroutine g_byte_array_sort(array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
end subroutine

! void g_byte_array_sort_with_data (GByteArray *array, GCompareDataFunc compare_func, gpointer user_data);
subroutine g_byte_array_sort_with_data(array, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end subroutine

!   GQuark g_option_error_quark (void);
function g_option_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_option_error_quark
end function

!  GOptionContext *g_option_context_new (const gchar *parameter_string);
function g_option_context_new(parameter_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_option_context_new
  character(kind=c_char), dimension(*) :: parameter_string
end function

! void g_option_context_set_summary (GOptionContext *context, const gchar *summary);
subroutine g_option_context_set_summary(context, summary) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: summary
end subroutine

! G_CONST_RETURN gchar *g_option_context_get_summary (GOptionContext *context);
function g_option_context_get_summary(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_summary
  type(c_ptr), value :: context
end function

! void g_option_context_set_description (GOptionContext *context, const gchar *description);
subroutine g_option_context_set_description(context, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: description
end subroutine

! G_CONST_RETURN gchar *g_option_context_get_description (GOptionContext *context);
function g_option_context_get_description(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_description
  type(c_ptr), value :: context
end function

! void g_option_context_free (GOptionContext *context);
subroutine g_option_context_free(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void g_option_context_set_help_enabled (GOptionContext *context, gboolean help_enabled);
subroutine g_option_context_set_help_enabled(context, help_enabled) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: help_enabled
end subroutine

! gboolean g_option_context_get_help_enabled (GOptionContext *context);
function g_option_context_get_help_enabled(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_option_context_get_help_enabled
  type(c_ptr), value :: context
end function

! void g_option_context_set_ignore_unknown_options (GOptionContext *context, gboolean ignore_unknown);
subroutine g_option_context_set_ignore_unknown_options(context, ignore_unknown)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  integer(c_int), value :: ignore_unknown
end subroutine

! gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);
function g_option_context_get_ignore_unknown_options(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_option_context_get_ignore_unknown_options
  type(c_ptr), value :: context
end function

!  void g_option_context_add_main_entries (GOptionContext *context, const GOptionEntry *entries, const gchar *translation_domain);
subroutine g_option_context_add_main_entries(context, entries, translation_doma&
&in) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  type(c_ptr), value :: entries
  character(kind=c_char), dimension(*) :: translation_domain
end subroutine

! gboolean g_option_context_parse (GOptionContext *context, gint *argc, gchar ***argv, GError **error);
function g_option_context_parse(context, argc, argv, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_option_context_parse
  type(c_ptr), value :: context
  type(c_ptr), value :: argc
  type(c_ptr), dimension(*) :: argv
  type(c_ptr), value :: error
end function

! void g_option_context_set_translate_func (GOptionContext *context, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_context_set_translate_func(context, func, data, destroy_not&
&ify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! void g_option_context_set_translation_domain (GOptionContext *context, const gchar *domain);
subroutine g_option_context_set_translation_domain(context, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: context
  character(kind=c_char), dimension(*) :: domain
end subroutine

!  void g_option_context_add_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_add_group(context, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! void g_option_context_set_main_group (GOptionContext *context, GOptionGroup *group);
subroutine g_option_context_set_main_group(context, group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: group
end subroutine

! GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
function g_option_context_get_main_group(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_option_context_get_main_group
  type(c_ptr), value :: context
end function

! gchar *g_option_context_get_help (GOptionContext *context, gboolean main_help, GOptionGroup *group);
function g_option_context_get_help(context, main_help, group) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_option_context_get_help
  type(c_ptr), value :: context
  integer(c_int), value :: main_help
  type(c_ptr), value :: group
end function

!  GOptionGroup *g_option_group_new (const gchar *name, const gchar *description, const gchar *help_description, gpointer user_data, GDestroyNotify destroy);
function g_option_group_new(name, description, help_description, user_data, des&
&troy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr) :: g_option_group_new
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: description
  character(kind=c_char), dimension(*) :: help_description
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy
end function

! void g_option_group_set_parse_hooks (GOptionGroup *group, GOptionParseFunc pre_parse_func, GOptionParseFunc post_parse_func);
subroutine g_option_group_set_parse_hooks(group, pre_parse_func, post_parse_fun&
&c) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: pre_parse_func
  type(c_funptr), value :: post_parse_func
end subroutine

! void g_option_group_set_error_hook (GOptionGroup *group, GOptionErrorFunc error_func);
subroutine g_option_group_set_error_hook(group, error_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: group
  integer(c_int), value :: error_func
end subroutine

! void g_option_group_free (GOptionGroup *group);
subroutine g_option_group_free(group) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
end subroutine

! void g_option_group_add_entries (GOptionGroup *group, const GOptionEntry *entries);
subroutine g_option_group_add_entries(group, entries) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: group
  type(c_ptr), value :: entries
end subroutine

! void g_option_group_set_translate_func (GOptionGroup *group, GTranslateFunc func, gpointer data, GDestroyNotify destroy_notify);
subroutine g_option_group_set_translate_func(group, func, data, destroy_notify)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: group
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_notify
end subroutine

! void g_option_group_set_translation_domain (GOptionGroup *group, const gchar *domain);
subroutine g_option_group_set_translation_domain(group, domain) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: group
  character(kind=c_char), dimension(*) :: domain
end subroutine

!   GSList* g_slist_alloc (void) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_alloc() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_alloc
end function

! void g_slist_free (GSList *list);
subroutine g_slist_free(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

! void g_slist_free_1 (GSList *list);
subroutine g_slist_free_1(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: list
end subroutine

!  void g_slist_free_full (GSList *list, GDestroyNotify free_func);
subroutine g_slist_free_full(list, free_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: free_func
end subroutine

! GSList* g_slist_append (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_append(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_append
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_prepend (GSList *list, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_prepend(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_prepend
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_insert (GSList *list, gpointer data, gint position) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert(list, data, position) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_insert
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  integer(c_int), value :: position
end function

! GSList* g_slist_insert_sorted (GSList *list, gpointer data, GCompareFunc func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! GSList* g_slist_insert_sorted_with_data (GSList *list, gpointer data, GCompareDataFunc func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_sorted_with_data(list, data, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_insert_sorted_with_data
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end function

! GSList* g_slist_insert_before (GSList *slist, GSList *sibling, gpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_insert_before(slist, sibling, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_insert_before
  type(c_ptr), value :: slist
  type(c_ptr), value :: sibling
  type(c_ptr), value :: data
end function

! GSList* g_slist_concat (GSList *list1, GSList *list2) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_concat(list1, list2) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_concat
  type(c_ptr), value :: list1
  type(c_ptr), value :: list2
end function

! GSList* g_slist_remove (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_remove_all (GSList *list, gconstpointer data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_all(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove_all
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_remove_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_remove_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_remove_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GSList* g_slist_delete_link (GSList *list, GSList *link_) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_delete_link(list, link_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_delete_link
  type(c_ptr), value :: list
  type(c_ptr), value :: link_
end function

! GSList* g_slist_reverse (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_reverse(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_reverse
  type(c_ptr), value :: list
end function

! GSList* g_slist_copy (GSList *list) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_copy(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_copy
  type(c_ptr), value :: list
end function

! GSList* g_slist_nth (GSList *list, guint n);
function g_slist_nth(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_nth
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

! GSList* g_slist_find (GSList *list, gconstpointer data);
function g_slist_find(list, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_find
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_find_custom (GSList *list, gconstpointer data, GCompareFunc func);
function g_slist_find_custom(list, data, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_find_custom
  type(c_ptr), value :: list
  type(c_ptr), value :: data
  type(c_funptr), value :: func
end function

! gint g_slist_position (GSList *list, GSList *llink);
function g_slist_position(list, llink) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_position
  type(c_ptr), value :: list
  type(c_ptr), value :: llink
end function

! gint g_slist_index (GSList *list, gconstpointer data);
function g_slist_index(list, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_index
  type(c_ptr), value :: list
  type(c_ptr), value :: data
end function

! GSList* g_slist_last (GSList *list);
function g_slist_last(list) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_slist_last
  type(c_ptr), value :: list
end function

! guint g_slist_length (GSList *list);
function g_slist_length(list) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_slist_length
  type(c_ptr), value :: list
end function

! void g_slist_foreach (GSList *list, GFunc func, gpointer user_data);
subroutine g_slist_foreach(list, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: list
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

! GSList* g_slist_sort (GSList *list, GCompareFunc compare_func) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort(list, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
end function

! GSList* g_slist_sort_with_data (GSList *list, GCompareDataFunc compare_func, gpointer user_data) G_GNUC_WARN_UNUSED_RESULT;
function g_slist_sort_with_data(list, compare_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_slist_sort_with_data
  type(c_ptr), value :: list
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

! gpointer g_slist_nth_data (GSList *list, guint n);
function g_slist_nth_data(list, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_slist_nth_data
  type(c_ptr), value :: list
  integer(c_int), value :: n
end function

!  void g_slist_push_allocator (gpointer dummy);
subroutine g_slist_push_allocator(dummy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dummy
end subroutine

! void g_slist_pop_allocator (void);
subroutine g_slist_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GQuark g_bookmark_file_error_quark (void);
function g_bookmark_file_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_bookmark_file_error_quark
end function

!  GBookmarkFile *g_bookmark_file_new (void);
function g_bookmark_file_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_new
end function

! void g_bookmark_file_free (GBookmarkFile *bookmark);
subroutine g_bookmark_file_free(bookmark) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: bookmark
end subroutine

!  gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_load_from_file(bookmark, filename, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_load_from_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark, const gchar *data, gsize length, GError **error);
function g_bookmark_file_load_from_data(bookmark, data, length, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_bookmark_file_load_from_data
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: data
  integer(c_size_t), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark, const gchar *file, gchar **full_path, GError **error);
function g_bookmark_file_load_from_data_dirs(bookmark, file, full_path, error) &
&bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_load_from_data_dirs
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: file
  type(c_ptr), dimension(*) :: full_path
  type(c_ptr), value :: error
end function

! gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_to_data(bookmark, length, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_to_data
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark, const gchar *filename, GError **error);
function g_bookmark_file_to_file(bookmark, filename, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_to_file
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: filename
  type(c_ptr), value :: error
end function

!  void g_bookmark_file_set_title (GBookmarkFile *bookmark, const gchar *uri, const gchar *title);
subroutine g_bookmark_file_set_title(bookmark, uri, title) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: title
end subroutine

! gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_title(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_title
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_description (GBookmarkFile *bookmark, const gchar *uri, const gchar *description);
subroutine g_bookmark_file_set_description(bookmark, uri, description) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: description
end subroutine

! gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_description(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_description
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark, const gchar *uri, const gchar *mime_type);
subroutine g_bookmark_file_set_mime_type(bookmark, uri, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark, const gchar *uri, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_mime_type(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_mime_type
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_groups (GBookmarkFile *bookmark, const gchar *uri, const gchar **groups, gsize length);
subroutine g_bookmark_file_set_groups(bookmark, uri, groups, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), dimension(*) :: groups
  integer(c_size_t), value :: length
end subroutine

! void g_bookmark_file_add_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group);
subroutine g_bookmark_file_add_group(bookmark, uri, group) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
end subroutine

! gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_has_group(bookmark, uri, group, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_groups(bookmark, uri, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_groups
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! void g_bookmark_file_add_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec);
subroutine g_bookmark_file_add_application(bookmark, uri, name, exec) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
end subroutine

! gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_has_application(bookmark, uri, name, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark, const gchar *uri, gsize *length, GError **error) G_GNUC_MALLOC;
function g_bookmark_file_get_applications(bookmark, uri, length, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_bookmark_file_get_applications
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: length
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, const gchar *exec, gint count, time_t stamp, GError **error);
function g_bookmark_file_set_app_info(bookmark, uri, name, exec, count, stamp, &
&error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_long
  integer(c_int) :: g_bookmark_file_set_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: exec
  integer(c_int), value :: count
  integer(c_long), value :: stamp
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, gchar **exec, guint *count, time_t *stamp, GError **error);
function g_bookmark_file_get_app_info(bookmark, uri, name, exec, count, stamp, &
&error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_app_info
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), dimension(*) :: exec
  type(c_ptr), value :: count
  type(c_ptr), value :: stamp
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_is_private (GBookmarkFile *bookmark, const gchar *uri, gboolean is_private);
subroutine g_bookmark_file_set_is_private(bookmark, uri, is_private) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_int), value :: is_private
end subroutine

! gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_is_private(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_is_private
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_icon (GBookmarkFile *bookmark, const gchar *uri, const gchar *href, const gchar *mime_type);
subroutine g_bookmark_file_set_icon(bookmark, uri, href, mime_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: href
  character(kind=c_char), dimension(*) :: mime_type
end subroutine

! gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark, const gchar *uri, gchar **href, gchar **mime_type, GError **error);
function g_bookmark_file_get_icon(bookmark, uri, href, mime_type, error) bind(c&
&) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_get_icon
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), dimension(*) :: href
  type(c_ptr), dimension(*) :: mime_type
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_added (GBookmarkFile *bookmark, const gchar *uri, time_t added);
subroutine g_bookmark_file_set_added(bookmark, uri, added) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: added
end subroutine

! time_t g_bookmark_file_get_added (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_added(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_added
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_modified (GBookmarkFile *bookmark, const gchar *uri, time_t modified);
subroutine g_bookmark_file_set_modified(bookmark, uri, modified) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: modified
end subroutine

! time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_modified(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_modified
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! void g_bookmark_file_set_visited (GBookmarkFile *bookmark, const gchar *uri, time_t visited);
subroutine g_bookmark_file_set_visited(bookmark, uri, visited) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  integer(c_long), value :: visited
end subroutine

! time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_get_visited(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char
  integer(c_long) :: g_bookmark_file_get_visited
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark, const gchar *uri);
function g_bookmark_file_has_item(bookmark, uri) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_has_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
end function

! gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
function g_bookmark_file_get_size(bookmark) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_bookmark_file_get_size
  type(c_ptr), value :: bookmark
end function

! gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark, gsize *length) G_GNUC_MALLOC;
function g_bookmark_file_get_uris(bookmark, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_bookmark_file_get_uris
  type(c_ptr), value :: bookmark
  type(c_ptr), value :: length
end function

! gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark, const gchar *uri, const gchar *group, GError **error);
function g_bookmark_file_remove_group(bookmark, uri, group, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_group
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: group
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark, const gchar *uri, const gchar *name, GError **error);
function g_bookmark_file_remove_application(bookmark, uri, name, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_application
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark, const gchar *uri, GError **error);
function g_bookmark_file_remove_item(bookmark, uri, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_remove_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: uri
  type(c_ptr), value :: error
end function

! gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark, const gchar *old_uri, const gchar *new_uri, GError **error);
function g_bookmark_file_move_item(bookmark, old_uri, new_uri, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_bookmark_file_move_item
  type(c_ptr), value :: bookmark
  character(kind=c_char), dimension(*) :: old_uri
  character(kind=c_char), dimension(*) :: new_uri
  type(c_ptr), value :: error
end function

!   GThreadPool* g_thread_pool_new (GFunc func, gpointer user_data, gint max_threads, gboolean exclusive, GError **error);
function g_thread_pool_new(func, user_data, max_threads, exclusive, error) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_thread_pool_new
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
  integer(c_int), value :: max_threads
  integer(c_int), value :: exclusive
  type(c_ptr), value :: error
end function

!  void g_thread_pool_push (GThreadPool *pool, gpointer data, GError **error);
subroutine g_thread_pool_push(pool, data, error) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pool
  type(c_ptr), value :: data
  type(c_ptr), value :: error
end subroutine

!  void g_thread_pool_set_max_threads (GThreadPool *pool, gint max_threads, GError **error);
subroutine g_thread_pool_set_max_threads(pool, max_threads, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pool
  integer(c_int), value :: max_threads
  type(c_ptr), value :: error
end subroutine

! gint g_thread_pool_get_max_threads (GThreadPool *pool);
function g_thread_pool_get_max_threads(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_max_threads
  type(c_ptr), value :: pool
end function

!  guint g_thread_pool_get_num_threads (GThreadPool *pool);
function g_thread_pool_get_num_threads(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_get_num_threads
  type(c_ptr), value :: pool
end function

!  guint g_thread_pool_unprocessed (GThreadPool *pool);
function g_thread_pool_unprocessed(pool) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_thread_pool_unprocessed
  type(c_ptr), value :: pool
end function

!  void g_thread_pool_free (GThreadPool *pool, gboolean immediate, gboolean wait_);
subroutine g_thread_pool_free(pool, immediate, wait_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: pool
  integer(c_int), value :: immediate
  integer(c_int), value :: wait_
end subroutine

!  void g_thread_pool_set_max_unused_threads (gint max_threads);
subroutine g_thread_pool_set_max_unused_threads(max_threads) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: max_threads
end subroutine

! gint g_thread_pool_get_max_unused_threads (void);
function g_thread_pool_get_max_unused_threads() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_max_unused_threads
end function

! guint g_thread_pool_get_num_unused_threads (void);
function g_thread_pool_get_num_unused_threads() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_num_unused_threads
end function

!  void g_thread_pool_stop_unused_threads (void);
subroutine g_thread_pool_stop_unused_threads() bind(c) 
  use iso_c_binding, only: 
end subroutine

!  void g_thread_pool_set_sort_function (GThreadPool *pool, GCompareDataFunc func, gpointer user_data);
subroutine g_thread_pool_set_sort_function(pool, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: pool
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_thread_pool_set_max_idle_time (guint interval);
subroutine g_thread_pool_set_max_idle_time(interval) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: interval
end subroutine

! guint g_thread_pool_get_max_idle_time (void);
function g_thread_pool_get_max_idle_time() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_thread_pool_get_max_idle_time
end function

!   gint g_printf (gchar const *format, ...) G_GNUC_PRINTF (1, 2);
function g_printf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_printf
end function

! gint g_fprintf (FILE *file, gchar const *format, ...) G_GNUC_PRINTF (2, 3);
function g_fprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_fprintf
end function

! gint g_sprintf (gchar *string, gchar const *format, ...) G_GNUC_PRINTF (2, 3);
function g_sprintf() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_sprintf
end function

!  gint g_vprintf (gchar const *format, va_list args);
function g_vprintf(format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_vprintf
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vfprintf (FILE *file, gchar const *format, va_list args);
function g_vfprintf(file, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_vfprintf
  type(c_ptr), value :: file
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vsprintf (gchar *string, gchar const *format, va_list args);
function g_vsprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_vsprintf
  character(kind=c_char), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

! gint g_vasprintf (gchar **string, gchar const *format, va_list args);
function g_vasprintf(string, format, args) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_vasprintf
  type(c_ptr), dimension(*) :: string
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: args
end function

!   GQuark g_regex_error_quark (void);
function g_regex_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_regex_error_quark
end function

!  GRegex *g_regex_new (const gchar *pattern, GRegexCompileFlags compile_options, GRegexMatchFlags match_options, GError **error);
function g_regex_new(pattern, compile_options, match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_new
  character(kind=c_char), dimension(*) :: pattern
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! GRegex *g_regex_ref (GRegex *regex);
function g_regex_ref(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_regex_ref
  type(c_ptr), value :: regex
end function

! void g_regex_unref (GRegex *regex);
subroutine g_regex_unref(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: regex
end subroutine

! const gchar *g_regex_get_pattern (const GRegex *regex);
function g_regex_get_pattern(regex) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_regex_get_pattern
  type(c_ptr), value :: regex
end function

! gint g_regex_get_max_backref (const GRegex *regex);
function g_regex_get_max_backref(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_max_backref
  type(c_ptr), value :: regex
end function

! gint g_regex_get_capture_count (const GRegex *regex);
function g_regex_get_capture_count(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_capture_count
  type(c_ptr), value :: regex
end function

! gint g_regex_get_string_number (const GRegex *regex, const gchar *name);
function g_regex_get_string_number(regex, name) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_get_string_number
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: name
end function

! gchar *g_regex_escape_string (const gchar *string, gint length);
function g_regex_escape_string(string, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_escape_string
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: length
end function

!  GRegexCompileFlags g_regex_get_compile_flags (const GRegex *regex);
function g_regex_get_compile_flags(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_compile_flags
  type(c_ptr), value :: regex
end function

! GRegexMatchFlags g_regex_get_match_flags (const GRegex *regex);
function g_regex_get_match_flags(regex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_regex_get_match_flags
  type(c_ptr), value :: regex
end function

!  gboolean g_regex_match_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_match_simple(pattern, string, compile_options, match_options) &
&bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_regex_match_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! gboolean g_regex_match (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match(regex, string, match_options, match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_match
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! gboolean g_regex_match_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_full(regex, string, string_len, start_position, match_op&
&tions, match_info, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_regex_match_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! gboolean g_regex_match_all (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options, GMatchInfo **match_info);
function g_regex_match_all(regex, string, match_options, match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_regex_match_all
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
end function

! gboolean g_regex_match_all_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GMatchInfo **match_info, GError **error);
function g_regex_match_all_full(regex, string, string_len, start_position, matc&
&h_options, match_info, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char, c_size_t
  integer(c_int) :: g_regex_match_all_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

!  gchar **g_regex_split_simple (const gchar *pattern, const gchar *string, GRegexCompileFlags compile_options, GRegexMatchFlags match_options);
function g_regex_split_simple(pattern, string, compile_options, match_options) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split_simple
  character(kind=c_char), dimension(*) :: pattern
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: compile_options
  integer(c_int), value :: match_options
end function

! gchar **g_regex_split (const GRegex *regex, const gchar *string, GRegexMatchFlags match_options);
function g_regex_split(regex, string, match_options) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_regex_split
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_int), value :: match_options
end function

! gchar **g_regex_split_full (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, gint max_tokens, GError **error);
function g_regex_split_full(regex, string, string_len, start_position, match_op&
&tions, max_tokens, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_split_full
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  integer(c_int), value :: max_tokens
  type(c_ptr), value :: error
end function

!  gchar *g_regex_replace (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace(regex, string, string_len, start_position, replacement&
&, match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! gchar *g_regex_replace_literal (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, const gchar *replacement, GRegexMatchFlags match_options, GError **error);
function g_regex_replace_literal(regex, string, string_len, start_position, rep&
&lacement, match_options, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_regex_replace_literal
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  character(kind=c_char), dimension(*) :: replacement
  integer(c_int), value :: match_options
  type(c_ptr), value :: error
end function

! gchar *g_regex_replace_eval (const GRegex *regex, const gchar *string, gssize string_len, gint start_position, GRegexMatchFlags match_options, GRegexEvalCallback eval, gpointer user_data, GError **error);
function g_regex_replace_eval(regex, string, string_len, start_position, match_&
&options, eval, user_data, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int, c_funptr
  type(c_ptr) :: g_regex_replace_eval
  type(c_ptr), value :: regex
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: string_len
  integer(c_int), value :: start_position
  integer(c_int), value :: match_options
  type(c_funptr), value :: eval
  type(c_ptr), value :: user_data
  type(c_ptr), value :: error
end function

! gboolean g_regex_check_replacement (const gchar *replacement, gboolean *has_references, GError **error);
function g_regex_check_replacement(replacement, has_references, error) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_regex_check_replacement
  character(kind=c_char), dimension(*) :: replacement
  type(c_ptr), value :: has_references
  type(c_ptr), value :: error
end function

!  GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
function g_match_info_get_regex(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_get_regex
  type(c_ptr), value :: match_info
end function

! const gchar *g_match_info_get_string (const GMatchInfo *match_info);
function g_match_info_get_string(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_get_string
  type(c_ptr), value :: match_info
end function

!  void g_match_info_free (GMatchInfo *match_info);
subroutine g_match_info_free(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: match_info
end subroutine

! gboolean g_match_info_next (GMatchInfo *match_info, GError **error);
function g_match_info_next(match_info, error) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_next
  type(c_ptr), value :: match_info
  type(c_ptr), value :: error
end function

! gboolean g_match_info_matches (const GMatchInfo *match_info);
function g_match_info_matches(match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_matches
  type(c_ptr), value :: match_info
end function

! gint g_match_info_get_match_count (const GMatchInfo *match_info);
function g_match_info_get_match_count(match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_get_match_count
  type(c_ptr), value :: match_info
end function

! gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
function g_match_info_is_partial_match(match_info) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_is_partial_match
  type(c_ptr), value :: match_info
end function

! gchar *g_match_info_expand_references(const GMatchInfo *match_info, const gchar *string_to_expand, GError **error);
function g_match_info_expand_references(match_info, string_to_expand, error) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_match_info_expand_references
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: string_to_expand
  type(c_ptr), value :: error
end function

! gchar *g_match_info_fetch (const GMatchInfo *match_info, gint match_num);
function g_match_info_fetch(match_info, match_num) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_match_info_fetch
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
end function

! gboolean g_match_info_fetch_pos (const GMatchInfo *match_info, gint match_num, gint *start_pos, gint *end_pos);
function g_match_info_fetch_pos(match_info, match_num, start_pos, end_pos) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_match_info_fetch_pos
  type(c_ptr), value :: match_info
  integer(c_int), value :: match_num
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! gchar *g_match_info_fetch_named (const GMatchInfo *match_info, const gchar *name);
function g_match_info_fetch_named(match_info, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_match_info_fetch_named
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
end function

! gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info, const gchar *name, gint *start_pos, gint *end_pos);
function g_match_info_fetch_named_pos(match_info, name, start_pos, end_pos) bin&
&d(c) 
  use iso_c_binding, only: c_int, c_ptr, c_char
  integer(c_int) :: g_match_info_fetch_named_pos
  type(c_ptr), value :: match_info
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: start_pos
  type(c_ptr), value :: end_pos
end function

! gchar **g_match_info_fetch_all (const GMatchInfo *match_info);
function g_match_info_fetch_all(match_info) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_match_info_fetch_all
  type(c_ptr), value :: match_info
end function

!   void g_variant_unref (GVariant *value);
subroutine g_variant_unref(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
end subroutine

! GVariant * g_variant_ref (GVariant *value);
function g_variant_ref(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_ref
  type(c_ptr), value :: value
end function

! GVariant * g_variant_ref_sink (GVariant *value);
function g_variant_ref_sink(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_ref_sink
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_floating (GVariant *value);
function g_variant_is_floating(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_is_floating
  type(c_ptr), value :: value
end function

!  const GVariantType * g_variant_get_type (GVariant *value);
function g_variant_get_type(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_type
  type(c_ptr), value :: value
end function

! const gchar * g_variant_get_type_string (GVariant *value);
function g_variant_get_type_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_type_string
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_of_type (GVariant *value, const GVariantType *type);
function g_variant_is_of_type(value, type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_is_of_type
  type(c_ptr), value :: value
  type(c_ptr), value :: type
end function

! gboolean g_variant_is_container (GVariant *value);
function g_variant_is_container(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_is_container
  type(c_ptr), value :: value
end function

! GVariantClass g_variant_classify (GVariant *value);
function g_variant_classify(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_classify
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_boolean (gboolean value);
function g_variant_new_boolean(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_variant_new_boolean
  integer(c_int), value :: value
end function

! GVariant * g_variant_new_byte (guchar value);
function g_variant_new_byte(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr) :: g_variant_new_byte
  integer(kind=c_int8_t), value :: value
end function

! GVariant * g_variant_new_int16 (gint16 value);
function g_variant_new_int16(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_int16
  integer(c_int16_t), value :: value
end function

! GVariant * g_variant_new_uint16 (guint16 value);
function g_variant_new_uint16(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int16_t
  type(c_ptr) :: g_variant_new_uint16
  integer(c_int16_t), value :: value
end function

! GVariant * g_variant_new_int32 (gint32 value);
function g_variant_new_int32(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_int32
  integer(c_int32_t), value :: value
end function

! GVariant * g_variant_new_uint32 (guint32 value);
function g_variant_new_uint32(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_uint32
  integer(c_int32_t), value :: value
end function

! GVariant * g_variant_new_int64 (gint64 value);
function g_variant_new_int64(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_int64
  integer(c_int64_t), value :: value
end function

! GVariant * g_variant_new_uint64 (guint64 value);
function g_variant_new_uint64(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr) :: g_variant_new_uint64
  integer(c_int64_t), value :: value
end function

! GVariant * g_variant_new_handle (gint32 value);
function g_variant_new_handle(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_variant_new_handle
  integer(c_int32_t), value :: value
end function

! GVariant * g_variant_new_double (gdouble value);
function g_variant_new_double(value) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr) :: g_variant_new_double
  real(c_double), value :: value
end function

! GVariant * g_variant_new_string (const gchar *string);
function g_variant_new_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_string
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_object_path (const gchar *object_path);
function g_variant_new_object_path(object_path) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_object_path
  character(kind=c_char), dimension(*) :: object_path
end function

! gboolean g_variant_is_object_path (const gchar *string);
function g_variant_is_object_path(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_variant_is_object_path
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_signature (const gchar *signature);
function g_variant_new_signature(signature) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_signature
  character(kind=c_char), dimension(*) :: signature
end function

! gboolean g_variant_is_signature (const gchar *string);
function g_variant_is_signature(string) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_variant_is_signature
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_variant (GVariant *value);
function g_variant_new_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_variant
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_strv (const gchar * const *strv, gssize length);
function g_variant_new_strv(strv, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_strv
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

! GVariant * g_variant_new_bytestring (const gchar *string);
function g_variant_new_bytestring(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_bytestring
  character(kind=c_char), dimension(*) :: string
end function

! GVariant * g_variant_new_bytestring_array (const gchar * const *strv, gssize length);
function g_variant_new_bytestring_array(strv, length) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_variant_new_bytestring_array
  character(kind=c_char), dimension(*) :: strv
  integer(c_size_t), value :: length
end function

!  gboolean g_variant_get_boolean (GVariant *value);
function g_variant_get_boolean(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_get_boolean
  type(c_ptr), value :: value
end function

! guchar g_variant_get_byte (GVariant *value);
function g_variant_get_byte(value) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_variant_get_byte
  type(c_ptr), value :: value
end function

! gint16 g_variant_get_int16 (GVariant *value);
function g_variant_get_int16(value) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_int16
  type(c_ptr), value :: value
end function

! guint16 g_variant_get_uint16 (GVariant *value);
function g_variant_get_uint16(value) bind(c) 
  use iso_c_binding, only: c_int16_t, c_ptr
  integer(c_int16_t) :: g_variant_get_uint16
  type(c_ptr), value :: value
end function

! gint32 g_variant_get_int32 (GVariant *value);
function g_variant_get_int32(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_int32
  type(c_ptr), value :: value
end function

! guint32 g_variant_get_uint32 (GVariant *value);
function g_variant_get_uint32(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_uint32
  type(c_ptr), value :: value
end function

! gint64 g_variant_get_int64 (GVariant *value);
function g_variant_get_int64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_int64
  type(c_ptr), value :: value
end function

! guint64 g_variant_get_uint64 (GVariant *value);
function g_variant_get_uint64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_variant_get_uint64
  type(c_ptr), value :: value
end function

! gint32 g_variant_get_handle (GVariant *value);
function g_variant_get_handle(value) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_variant_get_handle
  type(c_ptr), value :: value
end function

! gdouble g_variant_get_double (GVariant *value);
function g_variant_get_double(value) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_variant_get_double
  type(c_ptr), value :: value
end function

! GVariant * g_variant_get_variant (GVariant *value);
function g_variant_get_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_variant
  type(c_ptr), value :: value
end function

! const gchar * g_variant_get_string (GVariant *value, gsize *length);
function g_variant_get_string(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar * g_variant_dup_string (GVariant *value, gsize *length);
function g_variant_dup_string(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_string
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar ** g_variant_get_strv (GVariant *value, gsize *length);
function g_variant_get_strv(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar ** g_variant_dup_strv (GVariant *value, gsize *length);
function g_variant_dup_strv(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_strv
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar * g_variant_get_bytestring (GVariant *value);
function g_variant_get_bytestring(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_bytestring
  type(c_ptr), value :: value
end function

! gchar * g_variant_dup_bytestring (GVariant *value, gsize *length);
function g_variant_dup_bytestring(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! const gchar ** g_variant_get_bytestring_array (GVariant *value, gsize *length);
function g_variant_get_bytestring_array(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

! gchar ** g_variant_dup_bytestring_array (GVariant *value, gsize *length);
function g_variant_dup_bytestring_array(value, length) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_dup_bytestring_array
  type(c_ptr), value :: value
  type(c_ptr), value :: length
end function

!  GVariant * g_variant_new_maybe (const GVariantType *child_type, GVariant *child);
function g_variant_new_maybe(child_type, child) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_maybe
  type(c_ptr), value :: child_type
  type(c_ptr), value :: child
end function

! GVariant * g_variant_new_array (const GVariantType *child_type, GVariant * const *children, gsize n_children);
function g_variant_new_array(child_type, children, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_array
  type(c_ptr), value :: child_type
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GVariant * g_variant_new_tuple (GVariant * const *children, gsize n_children);
function g_variant_new_tuple(children, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_new_tuple
  type(c_ptr), value :: children
  integer(c_size_t), value :: n_children
end function

! GVariant * g_variant_new_dict_entry (GVariant *key, GVariant *value);
function g_variant_new_dict_entry(key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_new_dict_entry
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end function

!  GVariant * g_variant_get_maybe (GVariant *value);
function g_variant_get_maybe(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_maybe
  type(c_ptr), value :: value
end function

! gsize g_variant_n_children (GVariant *value);
function g_variant_n_children(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_n_children
  type(c_ptr), value :: value
end function

! GVariant * g_variant_get_child_value (GVariant *value, gsize index_);
function g_variant_get_child_value(value, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_child_value
  type(c_ptr), value :: value
  integer(c_size_t), value :: index_
end function

! GVariant * g_variant_lookup_value (GVariant *dictionary, const gchar *key, const GVariantType *expected_type);
function g_variant_lookup_value(dictionary, key, expected_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_lookup_value
  type(c_ptr), value :: dictionary
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: expected_type
end function

! gconstpointer g_variant_get_fixed_array (GVariant *value, gsize *n_elements, gsize element_size);
function g_variant_get_fixed_array(value, n_elements, element_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_variant_get_fixed_array
  type(c_ptr), value :: value
  type(c_ptr), value :: n_elements
  integer(c_size_t), value :: element_size
end function

!  gsize g_variant_get_size (GVariant *value);
function g_variant_get_size(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_get_size
  type(c_ptr), value :: value
end function

! gconstpointer g_variant_get_data (GVariant *value);
function g_variant_get_data(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_data
  type(c_ptr), value :: value
end function

! void g_variant_store (GVariant *value, gpointer data);
subroutine g_variant_store(value, data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: data
end subroutine

!  gchar * g_variant_print (GVariant *value, gboolean type_annotate);
function g_variant_print(value, type_annotate) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_variant_print
  type(c_ptr), value :: value
  integer(c_int), value :: type_annotate
end function

! GString * g_variant_print_string (GVariant *value, GString *string, gboolean type_annotate);
function g_variant_print_string(value, string, type_annotate) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_variant_print_string
  type(c_ptr), value :: value
  type(c_ptr), value :: string
  integer(c_int), value :: type_annotate
end function

!  guint g_variant_hash (gconstpointer value);
function g_variant_hash(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_hash
  type(c_ptr), value :: value
end function

! gboolean g_variant_equal (gconstpointer one, gconstpointer two);
function g_variant_equal(one, two) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_equal
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

!  GVariant * g_variant_get_normal_form (GVariant *value);
function g_variant_get_normal_form(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_get_normal_form
  type(c_ptr), value :: value
end function

! gboolean g_variant_is_normal_form (GVariant *value);
function g_variant_is_normal_form(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_is_normal_form
  type(c_ptr), value :: value
end function

! GVariant * g_variant_byteswap (GVariant *value);
function g_variant_byteswap(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_byteswap
  type(c_ptr), value :: value
end function

! GVariant * g_variant_new_from_data (const GVariantType *type, gconstpointer data, gsize size, gboolean trusted, GDestroyNotify notify, gpointer user_data);
function g_variant_new_from_data(type, data, size, trusted, notify, user_data) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int, c_funptr
  type(c_ptr) :: g_variant_new_from_data
  type(c_ptr), value :: type
  type(c_ptr), value :: data
  integer(c_size_t), value :: size
  integer(c_int), value :: trusted
  type(c_funptr), value :: notify
  type(c_ptr), value :: user_data
end function

!  GVariantIter * g_variant_iter_new (GVariant *value);
function g_variant_iter_new(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_new
  type(c_ptr), value :: value
end function

! gsize g_variant_iter_init (GVariantIter *iter, GVariant *value);
function g_variant_iter_init(iter, value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_init
  type(c_ptr), value :: iter
  type(c_ptr), value :: value
end function

! GVariantIter * g_variant_iter_copy (GVariantIter *iter);
function g_variant_iter_copy(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_copy
  type(c_ptr), value :: iter
end function

! gsize g_variant_iter_n_children (GVariantIter *iter);
function g_variant_iter_n_children(iter) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_variant_iter_n_children
  type(c_ptr), value :: iter
end function

! void g_variant_iter_free (GVariantIter *iter);
subroutine g_variant_iter_free(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: iter
end subroutine

! GVariant * g_variant_iter_next_value (GVariantIter *iter);
function g_variant_iter_next_value(iter) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_iter_next_value
  type(c_ptr), value :: iter
end function

!  GQuark g_variant_parser_get_error_quark (void);
function g_variant_parser_get_error_quark() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_variant_parser_get_error_quark
end function

!  GVariantBuilder * g_variant_builder_new (const GVariantType *type);
function g_variant_builder_new(type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_new
  type(c_ptr), value :: type
end function

! void g_variant_builder_unref (GVariantBuilder *builder);
subroutine g_variant_builder_unref(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! GVariantBuilder * g_variant_builder_ref (GVariantBuilder *builder);
function g_variant_builder_ref(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_ref
  type(c_ptr), value :: builder
end function

! void g_variant_builder_init (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_init(builder, type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! GVariant * g_variant_builder_end (GVariantBuilder *builder);
function g_variant_builder_end(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_variant_builder_end
  type(c_ptr), value :: builder
end function

! void g_variant_builder_clear (GVariantBuilder *builder);
subroutine g_variant_builder_clear(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! void g_variant_builder_open (GVariantBuilder *builder, const GVariantType *type);
subroutine g_variant_builder_open(builder, type) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: type
end subroutine

! void g_variant_builder_close (GVariantBuilder *builder);
subroutine g_variant_builder_close(builder) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
end subroutine

! void g_variant_builder_add_value (GVariantBuilder *builder, GVariant *value);
subroutine g_variant_builder_add_value(builder, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: builder
  type(c_ptr), value :: value
end subroutine

! GVariant * g_variant_new_va (const gchar *format_string, const gchar **endptr, va_list *app);
function g_variant_new_va(format_string, endptr, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_va
  character(kind=c_char), dimension(*) :: format_string
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: app
end function

! void g_variant_get_va (GVariant *value, const gchar *format_string, const gchar **endptr, va_list *app);
subroutine g_variant_get_va(value, format_string, endptr, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: format_string
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: app
end subroutine

!  GVariant * g_variant_parse (const GVariantType *type, const gchar *text, const gchar *limit, const gchar **endptr, GError **error);
function g_variant_parse(type, text, limit, endptr, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_parse
  type(c_ptr), value :: type
  character(kind=c_char), dimension(*) :: text
  character(kind=c_char), dimension(*) :: limit
  type(c_ptr), dimension(*) :: endptr
  type(c_ptr), value :: error
end function

! GVariant * g_variant_new_parsed_va (const gchar *format, va_list *app);
function g_variant_new_parsed_va(format, app) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_variant_new_parsed_va
  character(kind=c_char), dimension(*) :: format
  type(c_ptr), value :: app
end function

!  gint g_variant_compare (gconstpointer one, gconstpointer two);
function g_variant_compare(one, two) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_variant_compare
  type(c_ptr), value :: one
  type(c_ptr), value :: two
end function

!   GMainContext *g_main_context_new (void);
function g_main_context_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_new
end function

! GMainContext *g_main_context_ref (GMainContext *context);
function g_main_context_ref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_ref
  type(c_ptr), value :: context
end function

! void g_main_context_unref (GMainContext *context);
subroutine g_main_context_unref(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! GMainContext *g_main_context_default (void);
function g_main_context_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_default
end function

!  gboolean g_main_context_iteration (GMainContext *context, gboolean may_block);
function g_main_context_iteration(context, may_block) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_iteration
  type(c_ptr), value :: context
  integer(c_int), value :: may_block
end function

! gboolean g_main_context_pending (GMainContext *context);
function g_main_context_pending(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_pending
  type(c_ptr), value :: context
end function

!  GSource *g_main_context_find_source_by_id (GMainContext *context, guint source_id);
function g_main_context_find_source_by_id(context, source_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_main_context_find_source_by_id
  type(c_ptr), value :: context
  integer(c_int), value :: source_id
end function

! GSource *g_main_context_find_source_by_user_data (GMainContext *context, gpointer user_data);
function g_main_context_find_source_by_user_data(context, user_data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_find_source_by_user_data
  type(c_ptr), value :: context
  type(c_ptr), value :: user_data
end function

! GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context, GSourceFuncs *funcs, gpointer user_data);
function g_main_context_find_source_by_funcs_user_data(context, funcs, user_dat&
&a) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_main_context_find_source_by_funcs_user_data
  type(c_ptr), value :: context
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

!  void g_main_context_wakeup (GMainContext *context);
subroutine g_main_context_wakeup(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_main_context_acquire (GMainContext *context);
function g_main_context_acquire(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_acquire
  type(c_ptr), value :: context
end function

! void g_main_context_release (GMainContext *context);
subroutine g_main_context_release(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! gboolean g_main_context_is_owner (GMainContext *context);
function g_main_context_is_owner(context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_is_owner
  type(c_ptr), value :: context
end function

! gboolean g_main_context_wait (GMainContext *context, GCond *cond, GMutex *mutex);
function g_main_context_wait(context, cond, mutex) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_wait
  type(c_ptr), value :: context
  type(c_ptr), value :: cond
  type(c_ptr), value :: mutex
end function

!  gboolean g_main_context_prepare (GMainContext *context, gint *priority);
function g_main_context_prepare(context, priority) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_prepare
  type(c_ptr), value :: context
  type(c_ptr), value :: priority
end function

! gint g_main_context_query (GMainContext *context, gint max_priority, gint *timeout_, GPollFD *fds, gint n_fds);
function g_main_context_query(context, max_priority, timeout_, fds, n_fds) bind&
&(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_query
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: timeout_
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! gint g_main_context_check (GMainContext *context, gint max_priority, GPollFD *fds, gint n_fds);
function g_main_context_check(context, max_priority, fds, n_fds) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_context_check
  type(c_ptr), value :: context
  integer(c_int), value :: max_priority
  type(c_ptr), value :: fds
  integer(c_int), value :: n_fds
end function

! void g_main_context_dispatch (GMainContext *context);
subroutine g_main_context_dispatch(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

!  void g_main_context_set_poll_func (GMainContext *context, GPollFunc func);
subroutine g_main_context_set_poll_func(context, func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: func
end subroutine

! GPollFunc g_main_context_get_poll_func (GMainContext *context);
function g_main_context_get_poll_func(context) bind(c) 
  use iso_c_binding, only: c_funptr, c_ptr
  type(c_funptr) :: g_main_context_get_poll_func
  type(c_ptr), value :: context
end function

!  void g_main_context_add_poll (GMainContext *context, GPollFD *fd, gint priority);
subroutine g_main_context_add_poll(context, fd, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
  integer(c_int), value :: priority
end subroutine

! void g_main_context_remove_poll (GMainContext *context, GPollFD *fd);
subroutine g_main_context_remove_poll(context, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
  type(c_ptr), value :: fd
end subroutine

!  gint g_main_depth (void);
function g_main_depth() bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_main_depth
end function

! GSource *g_main_current_source (void);
function g_main_current_source() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_current_source
end function

!  void g_main_context_push_thread_default (GMainContext *context);
subroutine g_main_context_push_thread_default(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! void g_main_context_pop_thread_default (GMainContext *context);
subroutine g_main_context_pop_thread_default(context) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: context
end subroutine

! GMainContext *g_main_context_get_thread_default (void);
function g_main_context_get_thread_default() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_context_get_thread_default
end function

!  GMainLoop *g_main_loop_new (GMainContext *context, gboolean is_running);
function g_main_loop_new(context, is_running) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_main_loop_new
  type(c_ptr), value :: context
  integer(c_int), value :: is_running
end function

! void g_main_loop_run (GMainLoop *loop);
subroutine g_main_loop_run(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! void g_main_loop_quit (GMainLoop *loop);
subroutine g_main_loop_quit(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! GMainLoop *g_main_loop_ref (GMainLoop *loop);
function g_main_loop_ref(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_loop_ref
  type(c_ptr), value :: loop
end function

! void g_main_loop_unref (GMainLoop *loop);
subroutine g_main_loop_unref(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: loop
end subroutine

! gboolean g_main_loop_is_running (GMainLoop *loop);
function g_main_loop_is_running(loop) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_main_loop_is_running
  type(c_ptr), value :: loop
end function

! GMainContext *g_main_loop_get_context (GMainLoop *loop);
function g_main_loop_get_context(loop) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_main_loop_get_context
  type(c_ptr), value :: loop
end function

!  GSource *g_source_new (GSourceFuncs *source_funcs, guint struct_size);
function g_source_new(source_funcs, struct_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr) :: g_source_new
  type(c_funptr), value :: source_funcs
  integer(c_int), value :: struct_size
end function

! GSource *g_source_ref (GSource *source);
function g_source_ref(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_ref
  type(c_ptr), value :: source
end function

! void g_source_unref (GSource *source);
subroutine g_source_unref(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  guint g_source_attach (GSource *source, GMainContext *context);
function g_source_attach(source, context) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_attach
  type(c_ptr), value :: source
  type(c_ptr), value :: context
end function

! void g_source_destroy (GSource *source);
subroutine g_source_destroy(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  void g_source_set_priority (GSource *source, gint priority);
subroutine g_source_set_priority(source, priority) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: priority
end subroutine

! gint g_source_get_priority (GSource *source);
function g_source_get_priority(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_get_priority
  type(c_ptr), value :: source
end function

! void g_source_set_can_recurse (GSource *source, gboolean can_recurse);
subroutine g_source_set_can_recurse(source, can_recurse) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: source
  integer(c_int), value :: can_recurse
end subroutine

! gboolean g_source_get_can_recurse (GSource *source);
function g_source_get_can_recurse(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_get_can_recurse
  type(c_ptr), value :: source
end function

! guint g_source_get_id (GSource *source);
function g_source_get_id(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_get_id
  type(c_ptr), value :: source
end function

!  GMainContext *g_source_get_context (GSource *source);
function g_source_get_context(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_get_context
  type(c_ptr), value :: source
end function

!  void g_source_set_callback (GSource *source, GSourceFunc func, gpointer data, GDestroyNotify notify);
subroutine g_source_set_callback(source, func, data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: func
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

!  void g_source_set_funcs (GSource *source, GSourceFuncs *funcs);
subroutine g_source_set_funcs(source, funcs) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: source
  type(c_funptr), value :: funcs
end subroutine

! gboolean g_source_is_destroyed (GSource *source);
function g_source_is_destroyed(source) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_is_destroyed
  type(c_ptr), value :: source
end function

!  void g_source_set_name (GSource *source, const char *name);
subroutine g_source_set_name(source, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: name
end subroutine

! G_CONST_RETURN char* g_source_get_name (GSource *source);
function g_source_get_name(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_source_get_name
  type(c_ptr), value :: source
end function

! void g_source_set_name_by_id (guint tag, const char *name);
subroutine g_source_set_name_by_id(tag, name) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int), value :: tag
  character(kind=c_char), dimension(*) :: name
end subroutine

!  void g_source_set_callback_indirect (GSource *source, gpointer callback_data, GSourceCallbackFuncs *callback_funcs);
subroutine g_source_set_callback_indirect(source, callback_data, callback_funcs&
&) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: callback_data
  type(c_ptr), value :: callback_funcs
end subroutine

!  void g_source_add_poll (GSource *source, GPollFD *fd);
subroutine g_source_add_poll(source, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

! void g_source_remove_poll (GSource *source, GPollFD *fd);
subroutine g_source_remove_poll(source, fd) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: fd
end subroutine

!  void g_source_add_child_source (GSource *source, GSource *child_source);
subroutine g_source_add_child_source(source, child_source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: child_source
end subroutine

! void g_source_remove_child_source (GSource *source, GSource *child_source);
subroutine g_source_remove_child_source(source, child_source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: child_source
end subroutine

!  void g_source_get_current_time (GSource *source, GTimeVal *timeval);
subroutine g_source_get_current_time(source, timeval) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: timeval
end subroutine

!  gint64 g_source_get_time (GSource *source);
function g_source_get_time(source) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_source_get_time
  type(c_ptr), value :: source
end function

!    GSource *g_idle_source_new (void);
function g_idle_source_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_idle_source_new
end function

! GSource *g_child_watch_source_new (GPid pid);
function g_child_watch_source_new(pid) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_child_watch_source_new
  integer(c_int), value :: pid
end function

! GSource *g_timeout_source_new (guint interval);
function g_timeout_source_new(interval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new
  integer(c_int), value :: interval
end function

! GSource *g_timeout_source_new_seconds (guint interval);
function g_timeout_source_new_seconds(interval) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_timeout_source_new_seconds
  integer(c_int), value :: interval
end function

!  void g_get_current_time (GTimeVal *result);
subroutine g_get_current_time(result) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: result
end subroutine

! gint64 g_get_monotonic_time (void);
function g_get_monotonic_time() bind(c) 
  use iso_c_binding, only: c_int64_t
  integer(c_int64_t) :: g_get_monotonic_time
end function

! gint64 g_get_real_time (void);
function g_get_real_time() bind(c) 
  use iso_c_binding, only: c_int64_t
  integer(c_int64_t) :: g_get_real_time
end function

!  gboolean g_source_remove (guint tag);
function g_source_remove(tag) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int) :: g_source_remove
  integer(c_int), value :: tag
end function

! gboolean g_source_remove_by_user_data (gpointer user_data);
function g_source_remove_by_user_data(user_data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_source_remove_by_user_data
  type(c_ptr), value :: user_data
end function

! gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs, gpointer user_data);
function g_source_remove_by_funcs_user_data(funcs, user_data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_source_remove_by_funcs_user_data
  type(c_funptr), value :: funcs
  type(c_ptr), value :: user_data
end function

!  guint g_timeout_add_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_full(priority, interval, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_timeout_add (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_timeout_add_seconds_full (gint priority, guint interval, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_timeout_add_seconds_full(priority, interval, function, data, notify)&
& bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds_full
  integer(c_int), value :: priority
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_timeout_add_seconds (guint interval, GSourceFunc function, gpointer data);
function g_timeout_add_seconds(interval, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_timeout_add_seconds
  integer(c_int), value :: interval
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_child_watch_add_full (gint priority, GPid pid, GChildWatchFunc function, gpointer data, GDestroyNotify notify);
function g_child_watch_add_full(priority, pid, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add_full
  integer(c_int), value :: priority
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! guint g_child_watch_add (GPid pid, GChildWatchFunc function, gpointer data);
function g_child_watch_add(pid, function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_child_watch_add
  integer(c_int), value :: pid
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_idle_add (GSourceFunc function, gpointer data);
function g_idle_add(function, data) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end function

! guint g_idle_add_full (gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
function g_idle_add_full(priority, function, data, notify) bind(c) 
  use iso_c_binding, only: c_int, c_funptr, c_ptr
  integer(c_int) :: g_idle_add_full
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end function

! gboolean g_idle_remove_by_data (gpointer data);
function g_idle_remove_by_data(data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_idle_remove_by_data
  type(c_ptr), value :: data
end function

!  void g_main_context_invoke_full (GMainContext *context, gint priority, GSourceFunc function, gpointer data, GDestroyNotify notify);
subroutine g_main_context_invoke_full(context, priority, function, data, notify&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: context
  integer(c_int), value :: priority
  type(c_funptr), value :: function
  type(c_ptr), value :: data
  type(c_funptr), value :: notify
end subroutine

! void g_main_context_invoke (GMainContext *context, GSourceFunc function, gpointer data);
subroutine g_main_context_invoke(context, function, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: context
  type(c_funptr), value :: function
  type(c_ptr), value :: data
end subroutine

!   GTimer* g_timer_new (void);
function g_timer_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_timer_new
end function

! void g_timer_destroy (GTimer *timer);
subroutine g_timer_destroy(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_start (GTimer *timer);
subroutine g_timer_start(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_stop (GTimer *timer);
subroutine g_timer_stop(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_reset (GTimer *timer);
subroutine g_timer_reset(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! void g_timer_continue (GTimer *timer);
subroutine g_timer_continue(timer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: timer
end subroutine

! gdouble g_timer_elapsed (GTimer *timer, gulong *microseconds);
function g_timer_elapsed(timer, microseconds) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_timer_elapsed
  type(c_ptr), value :: timer
  type(c_ptr), value :: microseconds
end function

!  void g_usleep (gulong microseconds);
subroutine g_usleep(microseconds) bind(c) 
  use iso_c_binding, only: c_long
  integer(c_long), value :: microseconds
end subroutine

!  void g_time_val_add (GTimeVal *time_, glong microseconds);
subroutine g_time_val_add(time_, microseconds) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: time_
  integer(c_long), value :: microseconds
end subroutine

! gboolean g_time_val_from_iso8601 (const gchar *iso_date, GTimeVal *time_);
function g_time_val_from_iso8601(iso_date, time_) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_ptr
  integer(c_int) :: g_time_val_from_iso8601
  character(kind=c_char), dimension(*) :: iso_date
  type(c_ptr), value :: time_
end function

! gchar* g_time_val_to_iso8601 (GTimeVal *time_) G_GNUC_MALLOC;
function g_time_val_to_iso8601(time_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_time_val_to_iso8601
  type(c_ptr), value :: time_
end function

!   GTree* g_tree_new (GCompareFunc key_compare_func);
function g_tree_new(key_compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new
  type(c_funptr), value :: key_compare_func
end function

! GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func, gpointer key_compare_data);
function g_tree_new_with_data(key_compare_func, key_compare_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_with_data
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
end function

! GTree* g_tree_new_full (GCompareDataFunc key_compare_func, gpointer key_compare_data, GDestroyNotify key_destroy_func, GDestroyNotify value_destroy_func);
function g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, &
&value_destroy_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_new_full
  type(c_funptr), value :: key_compare_func
  type(c_ptr), value :: key_compare_data
  type(c_funptr), value :: key_destroy_func
  type(c_funptr), value :: value_destroy_func
end function

! GTree* g_tree_ref (GTree *tree);
function g_tree_ref(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tree_ref
  type(c_ptr), value :: tree
end function

! void g_tree_unref (GTree *tree);
subroutine g_tree_unref(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
end subroutine

! void g_tree_destroy (GTree *tree);
subroutine g_tree_destroy(tree) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
end subroutine

! void g_tree_insert (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_insert(tree, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! void g_tree_replace (GTree *tree, gpointer key, gpointer value);
subroutine g_tree_replace(tree, key, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
  type(c_ptr), value :: value
end subroutine

! gboolean g_tree_remove (GTree *tree, gconstpointer key);
function g_tree_remove(tree, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_remove
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gboolean g_tree_steal (GTree *tree, gconstpointer key);
function g_tree_steal(tree, key) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_steal
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gpointer g_tree_lookup (GTree *tree, gconstpointer key);
function g_tree_lookup(tree, key) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_tree_lookup
  type(c_ptr), value :: tree
  type(c_ptr), value :: key
end function

! gboolean g_tree_lookup_extended (GTree *tree, gconstpointer lookup_key, gpointer *orig_key, gpointer *value);
function g_tree_lookup_extended(tree, lookup_key, orig_key, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_lookup_extended
  type(c_ptr), value :: tree
  type(c_ptr), value :: lookup_key
  type(c_ptr), value :: orig_key
  type(c_ptr), value :: value
end function

! void g_tree_foreach (GTree *tree, GTraverseFunc func, gpointer user_data);
subroutine g_tree_foreach(tree, func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: tree
  type(c_funptr), value :: func
  type(c_ptr), value :: user_data
end subroutine

!  void g_tree_traverse (GTree *tree, GTraverseFunc traverse_func, GTraverseType traverse_type, gpointer user_data);
subroutine g_tree_traverse(tree, traverse_func, traverse_type, user_data) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_funptr, c_int
  type(c_ptr), value :: tree
  type(c_funptr), value :: traverse_func
  integer(c_int), value :: traverse_type
  type(c_ptr), value :: user_data
end subroutine

!  gpointer g_tree_search (GTree *tree, GCompareFunc search_func, gconstpointer user_data);
function g_tree_search(tree, search_func, user_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_tree_search
  type(c_ptr), value :: tree
  type(c_funptr), value :: search_func
  type(c_ptr), value :: user_data
end function

! gint g_tree_height (GTree *tree);
function g_tree_height(tree) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_height
  type(c_ptr), value :: tree
end function

! gint g_tree_nnodes (GTree *tree);
function g_tree_nnodes(tree) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_tree_nnodes
  type(c_ptr), value :: tree
end function

!   GNode* g_node_new (gpointer data);
function g_node_new(data) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_new
  type(c_ptr), value :: data
end function

! void g_node_destroy (GNode *root);
subroutine g_node_destroy(root) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: root
end subroutine

! void g_node_unlink (GNode *node);
subroutine g_node_unlink(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: node
end subroutine

! GNode* g_node_copy_deep (GNode *node, GCopyFunc copy_func, gpointer data);
function g_node_copy_deep(node, copy_func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_node_copy_deep
  type(c_ptr), value :: node
  type(c_funptr), value :: copy_func
  type(c_ptr), value :: data
end function

! GNode* g_node_copy (GNode *node);
function g_node_copy(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_copy
  type(c_ptr), value :: node
end function

! GNode* g_node_insert (GNode *parent, gint position, GNode *node);
function g_node_insert(parent, position, node) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_insert
  type(c_ptr), value :: parent
  integer(c_int), value :: position
  type(c_ptr), value :: node
end function

! GNode* g_node_insert_before (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_before(parent, sibling, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_insert_before
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_insert_after (GNode *parent, GNode *sibling, GNode *node);
function g_node_insert_after(parent, sibling, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_insert_after
  type(c_ptr), value :: parent
  type(c_ptr), value :: sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_prepend (GNode *parent, GNode *node);
function g_node_prepend(parent, node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_prepend
  type(c_ptr), value :: parent
  type(c_ptr), value :: node
end function

! guint g_node_n_nodes (GNode *root, GTraverseFlags flags);
function g_node_n_nodes(root, flags) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_n_nodes
  type(c_ptr), value :: root
  integer(c_int), value :: flags
end function

! GNode* g_node_get_root (GNode *node);
function g_node_get_root(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_get_root
  type(c_ptr), value :: node
end function

! gboolean g_node_is_ancestor (GNode *node, GNode *descendant);
function g_node_is_ancestor(node, descendant) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_is_ancestor
  type(c_ptr), value :: node
  type(c_ptr), value :: descendant
end function

! guint g_node_depth (GNode *node);
function g_node_depth(node) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_depth
  type(c_ptr), value :: node
end function

! GNode* g_node_find (GNode *root, GTraverseType order, GTraverseFlags flags, gpointer data);
function g_node_find(root, order, flags, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_find
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

!  void g_node_traverse (GNode *root, GTraverseType order, GTraverseFlags flags, gint max_depth, GNodeTraverseFunc func, gpointer data);
subroutine g_node_traverse(root, order, flags, max_depth, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: root
  integer(c_int), value :: order
  integer(c_int), value :: flags
  integer(c_int), value :: max_depth
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

!  guint g_node_max_height (GNode *root);
function g_node_max_height(root) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_max_height
  type(c_ptr), value :: root
end function

!  void g_node_children_foreach (GNode *node, GTraverseFlags flags, GNodeForeachFunc func, gpointer data);
subroutine g_node_children_foreach(node, flags, func, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_funptr
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_funptr), value :: func
  type(c_ptr), value :: data
end subroutine

! void g_node_reverse_children (GNode *node);
subroutine g_node_reverse_children(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: node
end subroutine

! guint g_node_n_children (GNode *node);
function g_node_n_children(node) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_n_children
  type(c_ptr), value :: node
end function

! GNode* g_node_nth_child (GNode *node, guint n);
function g_node_nth_child(node, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_nth_child
  type(c_ptr), value :: node
  integer(c_int), value :: n
end function

! GNode* g_node_last_child (GNode *node);
function g_node_last_child(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_last_child
  type(c_ptr), value :: node
end function

! GNode* g_node_find_child (GNode *node, GTraverseFlags flags, gpointer data);
function g_node_find_child(node, flags, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_node_find_child
  type(c_ptr), value :: node
  integer(c_int), value :: flags
  type(c_ptr), value :: data
end function

! gint g_node_child_position (GNode *node, GNode *child);
function g_node_child_position(node, child) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_child_position
  type(c_ptr), value :: node
  type(c_ptr), value :: child
end function

! gint g_node_child_index (GNode *node, gpointer data);
function g_node_child_index(node, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_node_child_index
  type(c_ptr), value :: node
  type(c_ptr), value :: data
end function

!  GNode* g_node_first_sibling (GNode *node);
function g_node_first_sibling(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_first_sibling
  type(c_ptr), value :: node
end function

! GNode* g_node_last_sibling (GNode *node);
function g_node_last_sibling(node) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_node_last_sibling
  type(c_ptr), value :: node
end function

!  void g_node_push_allocator (gpointer dummy);
subroutine g_node_push_allocator(dummy) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: dummy
end subroutine

! void g_node_pop_allocator (void);
subroutine g_node_pop_allocator() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   gboolean g_get_charset (G_CONST_RETURN char **charset);
function g_get_charset(charset) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_get_charset
  type(c_ptr), dimension(*) :: charset
end function

!  gboolean g_unichar_isalnum (gunichar c) G_GNUC_CONST;
function g_unichar_isalnum(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isalnum
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isalpha (gunichar c) G_GNUC_CONST;
function g_unichar_isalpha(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isalpha
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iscntrl (gunichar c) G_GNUC_CONST;
function g_unichar_iscntrl(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_iscntrl
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isdigit(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isdigit
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isgraph (gunichar c) G_GNUC_CONST;
function g_unichar_isgraph(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isgraph
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_islower (gunichar c) G_GNUC_CONST;
function g_unichar_islower(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_islower
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isprint (gunichar c) G_GNUC_CONST;
function g_unichar_isprint(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isprint
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_ispunct (gunichar c) G_GNUC_CONST;
function g_unichar_ispunct(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_ispunct
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isspace (gunichar c) G_GNUC_CONST;
function g_unichar_isspace(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isspace
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isupper (gunichar c) G_GNUC_CONST;
function g_unichar_isupper(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isupper
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isxdigit (gunichar c) G_GNUC_CONST;
function g_unichar_isxdigit(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isxdigit
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_istitle (gunichar c) G_GNUC_CONST;
function g_unichar_istitle(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_istitle
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_isdefined (gunichar c) G_GNUC_CONST;
function g_unichar_isdefined(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_isdefined
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iswide (gunichar c) G_GNUC_CONST;
function g_unichar_iswide(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_iswide
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iswide_cjk(gunichar c) G_GNUC_CONST;
function g_unichar_iswide_cjk(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_iswide_cjk
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_iszerowidth(gunichar c) G_GNUC_CONST;
function g_unichar_iszerowidth(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_iszerowidth
  integer(c_int32_t), value :: c
end function

! gboolean g_unichar_ismark (gunichar c) G_GNUC_CONST;
function g_unichar_ismark(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_ismark
  integer(c_int32_t), value :: c
end function

!  gunichar g_unichar_toupper (gunichar c) G_GNUC_CONST;
function g_unichar_toupper(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_toupper
  integer(c_int32_t), value :: c
end function

! gunichar g_unichar_tolower (gunichar c) G_GNUC_CONST;
function g_unichar_tolower(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_tolower
  integer(c_int32_t), value :: c
end function

! gunichar g_unichar_totitle (gunichar c) G_GNUC_CONST;
function g_unichar_totitle(c) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_unichar_totitle
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_digit_value (gunichar c) G_GNUC_CONST;
function g_unichar_digit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_digit_value
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_xdigit_value (gunichar c) G_GNUC_CONST;
function g_unichar_xdigit_value(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_xdigit_value
  integer(c_int32_t), value :: c
end function

!  GUnicodeType g_unichar_type (gunichar c) G_GNUC_CONST;
function g_unichar_type(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_type
  integer(c_int32_t), value :: c
end function

!  GUnicodeBreakType g_unichar_break_type (gunichar c) G_GNUC_CONST;
function g_unichar_break_type(c) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_break_type
  integer(c_int32_t), value :: c
end function

!  gint g_unichar_combining_class (gunichar uc) G_GNUC_CONST;
function g_unichar_combining_class(uc) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_combining_class
  integer(c_int32_t), value :: uc
end function

!  void g_unicode_canonical_ordering (gunichar *string, gsize len);
subroutine g_unicode_canonical_ordering(string, len) bind(c) 
  use iso_c_binding, only: c_char, c_size_t
  character(kind=c_char), dimension(*) :: string
  integer(c_size_t), value :: len
end subroutine

!  gunichar *g_unicode_canonical_decomposition (gunichar ch, gsize *result_len) G_GNUC_MALLOC;
function g_unicode_canonical_decomposition(ch, result_len) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_unicode_canonical_decomposition
  integer(c_int32_t), value :: ch
  type(c_ptr), value :: result_len
end function

!  gunichar g_utf8_get_char (const gchar *p) G_GNUC_PURE;
function g_utf8_get_char(p) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_utf8_get_char
  character(kind=c_char), dimension(*) :: p
end function

! gunichar g_utf8_get_char_validated (const gchar *p, gssize max_len) G_GNUC_PURE;
function g_utf8_get_char_validated(p, max_len) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char, c_size_t
  integer(c_int32_t) :: g_utf8_get_char_validated
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max_len
end function

!  gchar* g_utf8_offset_to_pointer (const gchar *str, glong offset) G_GNUC_PURE;
function g_utf8_offset_to_pointer(str, offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_offset_to_pointer
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: offset
end function

! glong g_utf8_pointer_to_offset (const gchar *str, const gchar *pos) G_GNUC_PURE;
function g_utf8_pointer_to_offset(str, pos) bind(c) 
  use iso_c_binding, only: c_long, c_char
  integer(c_long) :: g_utf8_pointer_to_offset
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: pos
end function

! gchar* g_utf8_prev_char (const gchar *p) G_GNUC_PURE;
function g_utf8_prev_char(p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_prev_char
  character(kind=c_char), dimension(*) :: p
end function

! gchar* g_utf8_find_next_char (const gchar *p, const gchar *end) G_GNUC_PURE;
function g_utf8_find_next_char(p, end) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_next_char
  character(kind=c_char), dimension(*) :: p
  character(kind=c_char), dimension(*) :: end
end function

! gchar* g_utf8_find_prev_char (const gchar *str, const gchar *p) G_GNUC_PURE;
function g_utf8_find_prev_char(str, p) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_utf8_find_prev_char
  character(kind=c_char), dimension(*) :: str
  character(kind=c_char), dimension(*) :: p
end function

!  glong g_utf8_strlen (const gchar *p, gssize max) G_GNUC_PURE;
function g_utf8_strlen(p, max) bind(c) 
  use iso_c_binding, only: c_long, c_char, c_size_t
  integer(c_long) :: g_utf8_strlen
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: max
end function

!  gchar* g_utf8_strncpy (gchar *dest, const gchar *src, gsize n);
function g_utf8_strncpy(dest, src, n) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strncpy
  character(kind=c_char), dimension(*) :: dest
  character(kind=c_char), dimension(*) :: src
  integer(c_size_t), value :: n
end function

!  gchar* g_utf8_strchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strchr(p, len, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! gchar* g_utf8_strrchr (const gchar *p, gssize len, gunichar c);
function g_utf8_strrchr(p, len, c) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int32_t
  type(c_ptr) :: g_utf8_strrchr
  character(kind=c_char), dimension(*) :: p
  integer(c_size_t), value :: len
  integer(c_int32_t), value :: c
end function

! gchar* g_utf8_strreverse (const gchar *str, gssize len);
function g_utf8_strreverse(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strreverse
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gunichar2 *g_utf8_to_utf16 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_utf16(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar * g_utf8_to_ucs4 (const gchar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf8_to_ucs4(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar * g_utf8_to_ucs4_fast (const gchar *str, glong len, glong *items_written) G_GNUC_MALLOC;
function g_utf8_to_ucs4_fast(str, len, items_written) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf8_to_ucs4_fast
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_written
end function

! gunichar * g_utf16_to_ucs4 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_ucs4(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_ucs4
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gchar* g_utf16_to_utf8 (const gunichar2 *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_utf16_to_utf8(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_utf16_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gunichar2 *g_ucs4_to_utf16 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf16(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf16
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

! gchar* g_ucs4_to_utf8 (const gunichar *str, glong len, glong *items_read, glong *items_written, GError **error) G_GNUC_MALLOC;
function g_ucs4_to_utf8(str, len, items_read, items_written, error) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long
  type(c_ptr) :: g_ucs4_to_utf8
  character(kind=c_char), dimension(*) :: str
  integer(c_long), value :: len
  type(c_ptr), value :: items_read
  type(c_ptr), value :: items_written
  type(c_ptr), value :: error
end function

!  gint g_unichar_to_utf8 (gunichar c, gchar *outbuf);
function g_unichar_to_utf8(c, outbuf) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_to_utf8
  integer(c_int32_t), value :: c
  character(kind=c_char), dimension(*) :: outbuf
end function

!  gboolean g_utf8_validate (const gchar *str, gssize max_len, const gchar **end);
function g_utf8_validate(str, max_len, end) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_utf8_validate
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: max_len
  type(c_ptr), dimension(*) :: end
end function

!  gboolean g_unichar_validate (gunichar ch) G_GNUC_CONST;
function g_unichar_validate(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_validate
  integer(c_int32_t), value :: ch
end function

!  gchar *g_utf8_strup (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strup(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strup
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_strdown (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_strdown(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_strdown
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_casefold (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_casefold(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_casefold
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gchar *g_utf8_normalize (const gchar *str, gssize len, GNormalizeMode mode) G_GNUC_MALLOC;
function g_utf8_normalize(str, len, mode) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_utf8_normalize
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
  integer(c_int), value :: mode
end function

!  gint g_utf8_collate (const gchar *str1, const gchar *str2) G_GNUC_PURE;
function g_utf8_collate(str1, str2) bind(c) 
  use iso_c_binding, only: c_int, c_char
  integer(c_int) :: g_utf8_collate
  character(kind=c_char), dimension(*) :: str1
  character(kind=c_char), dimension(*) :: str2
end function

! gchar *g_utf8_collate_key (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

! gchar *g_utf8_collate_key_for_filename (const gchar *str, gssize len) G_GNUC_MALLOC;
function g_utf8_collate_key_for_filename(str, len) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t
  type(c_ptr) :: g_utf8_collate_key_for_filename
  character(kind=c_char), dimension(*) :: str
  integer(c_size_t), value :: len
end function

!  gboolean g_unichar_get_mirror_char (gunichar ch, gunichar *mirrored_ch);
function g_unichar_get_mirror_char(ch, mirrored_ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t, c_char
  integer(c_int) :: g_unichar_get_mirror_char
  integer(c_int32_t), value :: ch
  character(kind=c_char), dimension(*) :: mirrored_ch
end function

!  GUnicodeScript g_unichar_get_script (gunichar ch) G_GNUC_CONST;
function g_unichar_get_script(ch) bind(c) 
  use iso_c_binding, only: c_int, c_int32_t
  integer(c_int) :: g_unichar_get_script
  integer(c_int32_t), value :: ch
end function

!   GRand* g_rand_new_with_seed (guint32 seed);
function g_rand_new_with_seed(seed) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_rand_new_with_seed
  integer(c_int32_t), value :: seed
end function

! GRand* g_rand_new_with_seed_array (const guint32 *seed, guint seed_length);
function g_rand_new_with_seed_array(seed, seed_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_rand_new_with_seed_array
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end function

! GRand* g_rand_new (void);
function g_rand_new() bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_rand_new
end function

! void g_rand_free (GRand *rand_);
subroutine g_rand_free(rand_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: rand_
end subroutine

! GRand* g_rand_copy (GRand *rand_);
function g_rand_copy(rand_) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_rand_copy
  type(c_ptr), value :: rand_
end function

! void g_rand_set_seed (GRand *rand_, guint32 seed);
subroutine g_rand_set_seed(rand_, seed) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: seed
end subroutine

! void g_rand_set_seed_array (GRand *rand_, const guint32 *seed, guint seed_length);
subroutine g_rand_set_seed_array(rand_, seed, seed_length) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: rand_
  type(c_ptr), value :: seed
  integer(c_int), value :: seed_length
end subroutine

!  guint32 g_rand_int (GRand *rand_);
function g_rand_int(rand_) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int
  type(c_ptr), value :: rand_
end function

! gint32 g_rand_int_range (GRand *rand_, gint32 begin, gint32 end);
function g_rand_int_range(rand_, begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t, c_ptr
  integer(c_int32_t) :: g_rand_int_range
  type(c_ptr), value :: rand_
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! gdouble g_rand_double (GRand *rand_);
function g_rand_double(rand_) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_rand_double
  type(c_ptr), value :: rand_
end function

! gdouble g_rand_double_range (GRand *rand_, gdouble begin, gdouble end);
function g_rand_double_range(rand_, begin, end) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_rand_double_range
  type(c_ptr), value :: rand_
  real(c_double), value :: begin
  real(c_double), value :: end
end function

! void g_random_set_seed (guint32 seed);
subroutine g_random_set_seed(seed) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t), value :: seed
end subroutine

!  guint32 g_random_int (void);
function g_random_int() bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_random_int
end function

! gint32 g_random_int_range (gint32 begin, gint32 end);
function g_random_int_range(begin, end) bind(c) 
  use iso_c_binding, only: c_int32_t
  integer(c_int32_t) :: g_random_int_range
  integer(c_int32_t), value :: begin
  integer(c_int32_t), value :: end
end function

! gdouble g_random_double (void);
function g_random_double() bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_random_double
end function

! gdouble g_random_double_range (gdouble begin, gdouble end);
function g_random_double_range(begin, end) bind(c) 
  use iso_c_binding, only: c_double
  real(c_double) :: g_random_double_range
  real(c_double), value :: begin
  real(c_double), value :: end
end function

!   GQuark g_quark_try_string (const gchar *string);
function g_quark_try_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_try_string
  character(kind=c_char), dimension(*) :: string
end function

! GQuark g_quark_from_static_string (const gchar *string);
function g_quark_from_static_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_static_string
  character(kind=c_char), dimension(*) :: string
end function

! GQuark g_quark_from_string (const gchar *string);
function g_quark_from_string(string) bind(c) 
  use iso_c_binding, only: c_int32_t, c_char
  integer(c_int32_t) :: g_quark_from_string
  character(kind=c_char), dimension(*) :: string
end function

! G_CONST_RETURN gchar* g_quark_to_string (GQuark quark) G_GNUC_CONST;
function g_quark_to_string(quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_quark_to_string
  integer(c_int32_t), value :: quark
end function

!  G_CONST_RETURN gchar* g_intern_string (const gchar *string);
function g_intern_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_intern_string
  character(kind=c_char), dimension(*) :: string
end function

! G_CONST_RETURN gchar* g_intern_static_string (const gchar *string);
function g_intern_static_string(string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_intern_static_string
  character(kind=c_char), dimension(*) :: string
end function

!   GClosure* g_cclosure_new (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new(callback_func, user_data, destroy_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GClosure* g_cclosure_new_swap (GCallback callback_func, gpointer user_data, GClosureNotify destroy_data);
function g_cclosure_new_swap(callback_func, user_data, destroy_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: user_data
  type(c_funptr), value :: destroy_data
end function

! GClosure* g_signal_type_cclosure_new (GType itype, guint struct_offset);
function g_signal_type_cclosure_new(itype, struct_offset) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_signal_type_cclosure_new
  integer(c_size_t), value :: itype
  integer(c_int), value :: struct_offset
end function

!  GClosure* g_closure_ref (GClosure *closure);
function g_closure_ref(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_closure_ref
  type(c_ptr), value :: closure
end function

! void g_closure_sink (GClosure *closure);
subroutine g_closure_sink(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

! void g_closure_unref (GClosure *closure);
subroutine g_closure_unref(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

!  GClosure* g_closure_new_simple (guint sizeof_closure, gpointer data);
function g_closure_new_simple(sizeof_closure, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_closure_new_simple
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: data
end function

! void g_closure_add_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_finalize_notifier(closure, notify_data, notify_func) b&
&ind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_remove_finalize_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_finalize_notifier(closure, notify_data, notify_func&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_add_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_add_invalidate_notifier(closure, notify_data, notify_func)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_remove_invalidate_notifier (GClosure *closure, gpointer notify_data, GClosureNotify notify_func);
subroutine g_closure_remove_invalidate_notifier(closure, notify_data, notify_fu&
&nc) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: notify_data
  type(c_funptr), value :: notify_func
end subroutine

! void g_closure_add_marshal_guards (GClosure *closure, gpointer pre_marshal_data, GClosureNotify pre_marshal_notify, gpointer post_marshal_data, GClosureNotify post_marshal_notify);
subroutine g_closure_add_marshal_guards(closure, pre_marshal_data, pre_marshal_&
&notify, post_marshal_data, post_marshal_notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: pre_marshal_data
  type(c_funptr), value :: pre_marshal_notify
  type(c_ptr), value :: post_marshal_data
  type(c_funptr), value :: post_marshal_notify
end subroutine

! void g_closure_set_marshal (GClosure *closure, GClosureMarshal marshal);
subroutine g_closure_set_marshal(closure, marshal) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_funptr), value :: marshal
end subroutine

! void g_closure_set_meta_marshal (GClosure *closure, gpointer marshal_data, GClosureMarshal meta_marshal);
subroutine g_closure_set_meta_marshal(closure, marshal_data, meta_marshal) bind&
&(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: closure
  type(c_ptr), value :: marshal_data
  type(c_funptr), value :: meta_marshal
end subroutine

! void g_closure_invalidate (GClosure *closure);
subroutine g_closure_invalidate(closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: closure
end subroutine

! void g_closure_invoke (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint);
subroutine g_closure_invoke(closure, return_value, n_param_values, param_values&
&, invocation_hint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
end subroutine

!   gpointer g_boxed_copy (GType boxed_type, gconstpointer src_boxed);
function g_boxed_copy(boxed_type, src_boxed) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_boxed_copy
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: src_boxed
end function

! void g_boxed_free (GType boxed_type, gpointer boxed);
subroutine g_boxed_free(boxed_type, boxed) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: boxed_type
  type(c_ptr), value :: boxed
end subroutine

! void g_value_set_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! void g_value_set_static_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_static_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

! gpointer g_value_get_boxed (const GValue *value);
function g_value_get_boxed(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_boxed
  type(c_ptr), value :: value
end function

! gpointer g_value_dup_boxed (const GValue *value);
function g_value_dup_boxed(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_boxed
  type(c_ptr), value :: value
end function

!  GType g_boxed_type_register_static (const gchar *name, GBoxedCopyFunc boxed_copy, GBoxedFreeFunc boxed_free);
function g_boxed_type_register_static(name, boxed_copy, boxed_free) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_funptr
  integer(c_size_t) :: g_boxed_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_funptr), value :: boxed_copy
  type(c_funptr), value :: boxed_free
end function

!  void g_value_take_boxed (GValue *value, gconstpointer v_boxed);
subroutine g_value_take_boxed(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

!  void g_value_set_boxed_take_ownership (GValue *value, gconstpointer v_boxed);
subroutine g_value_set_boxed_take_ownership(value, v_boxed) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_boxed
end subroutine

!  GType g_closure_get_type (void) G_GNUC_CONST;
function g_closure_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_closure_get_type
end function

! GType g_value_get_type (void) G_GNUC_CONST;
function g_value_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_value_get_type
end function

! GType g_value_array_get_type (void) G_GNUC_CONST;
function g_value_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_value_array_get_type
end function

! GType g_date_get_type (void) G_GNUC_CONST;
function g_date_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_date_get_type
end function

! GType g_strv_get_type (void) G_GNUC_CONST;
function g_strv_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_strv_get_type
end function

! GType g_gstring_get_type (void) G_GNUC_CONST;
function g_gstring_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_gstring_get_type
end function

! GType g_hash_table_get_type (void) G_GNUC_CONST;
function g_hash_table_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_hash_table_get_type
end function

! GType g_array_get_type (void) G_GNUC_CONST;
function g_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_array_get_type
end function

! GType g_byte_array_get_type (void) G_GNUC_CONST;
function g_byte_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_byte_array_get_type
end function

! GType g_ptr_array_get_type (void) G_GNUC_CONST;
function g_ptr_array_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_ptr_array_get_type
end function

! GType g_variant_type_get_gtype(void) G_GNUC_CONST;
function g_variant_type_get_gtype() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_variant_type_get_gtype
end function

! GType g_regex_get_type (void) G_GNUC_CONST;
function g_regex_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_regex_get_type
end function

! GType g_error_get_type (void) G_GNUC_CONST;
function g_error_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_error_get_type
end function

! GType g_date_time_get_type (void) G_GNUC_CONST;
function g_date_time_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_date_time_get_type
end function

!  GType g_variant_get_gtype (void) G_GNUC_CONST;
function g_variant_get_gtype() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_variant_get_gtype
end function

!   union  GValue* g_value_init (GValue *value, GType g_type);
function g_value_init(value, g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_value_init
  type(c_ptr), value :: value
  integer(c_size_t), value :: g_type
end function

! void g_value_copy (const GValue *src_value, GValue *dest_value);
subroutine g_value_copy(src_value, dest_value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end subroutine

! GValue* g_value_reset (GValue *value);
function g_value_reset(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_reset
  type(c_ptr), value :: value
end function

! void g_value_unset (GValue *value);
subroutine g_value_unset(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
end subroutine

! void g_value_set_instance (GValue *value, gpointer instance);
subroutine g_value_set_instance(value, instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: instance
end subroutine

!  gboolean g_value_fits_pointer (const GValue *value);
function g_value_fits_pointer(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_fits_pointer
  type(c_ptr), value :: value
end function

! gpointer g_value_peek_pointer (const GValue *value);
function g_value_peek_pointer(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_peek_pointer
  type(c_ptr), value :: value
end function

!  gboolean g_value_type_compatible (GType src_type, GType dest_type);
function g_value_type_compatible(src_type, dest_type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_value_type_compatible
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! gboolean g_value_type_transformable (GType src_type, GType dest_type);
function g_value_type_transformable(src_type, dest_type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_value_type_transformable
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
end function

! gboolean g_value_transform (const GValue *src_value, GValue *dest_value);
function g_value_transform(src_value, dest_value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_transform
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
end function

! void g_value_register_transform_func (GType src_type, GType dest_type, GValueTransform transform_func);
subroutine g_value_register_transform_func(src_type, dest_type, transform_func)&
& bind(c) 
  use iso_c_binding, only: c_size_t, c_funptr
  integer(c_size_t), value :: src_type
  integer(c_size_t), value :: dest_type
  type(c_funptr), value :: transform_func
end subroutine

!   GType g_binding_flags_get_type (void) G_GNUC_CONST;
function g_binding_flags_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_binding_flags_get_type
end function

! GType g_binding_get_type (void) G_GNUC_CONST;
function g_binding_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_binding_get_type
end function

!  GBindingFlags g_binding_get_flags (GBinding *binding);
function g_binding_get_flags(binding) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_binding_get_flags
  type(c_ptr), value :: binding
end function

! GObject * g_binding_get_source (GBinding *binding);
function g_binding_get_source(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_source
  type(c_ptr), value :: binding
end function

! GObject * g_binding_get_target (GBinding *binding);
function g_binding_get_target(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_target
  type(c_ptr), value :: binding
end function

! G_CONST_RETURN gchar *g_binding_get_source_property (GBinding *binding);
function g_binding_get_source_property(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_source_property
  type(c_ptr), value :: binding
end function

! G_CONST_RETURN gchar *g_binding_get_target_property (GBinding *binding);
function g_binding_get_target_property(binding) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_binding_get_target_property
  type(c_ptr), value :: binding
end function

!  GBinding *g_object_bind_property (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags);
function g_object_bind_property(source, source_property, target, target_propert&
&y, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
end function

! GBinding *g_object_bind_property_full (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GBindingTransformFunc transform_to, GBindingTransformFunc transform_from, gpointer user_data, GDestroyNotify notify);
function g_object_bind_property_full(source, source_property, target, target_pr&
&operty, flags, transform_to, transform_from, user_data, notify) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int, c_funptr
  type(c_ptr) :: g_object_bind_property_full
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_funptr), value :: transform_to
  type(c_funptr), value :: transform_from
  type(c_ptr), value :: user_data
  type(c_funptr), value :: notify
end function

! GBinding *g_object_bind_property_with_closures (gpointer source, const gchar *source_property, gpointer target, const gchar *target_property, GBindingFlags flags, GClosure *transform_to, GClosure *transform_from);
function g_object_bind_property_with_closures(source, source_property, target, &
&target_property, flags, transform_to, transform_from) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_object_bind_property_with_closures
  type(c_ptr), value :: source
  character(kind=c_char), dimension(*) :: source_property
  type(c_ptr), value :: target
  character(kind=c_char), dimension(*) :: target_property
  integer(c_int), value :: flags
  type(c_ptr), value :: transform_to
  type(c_ptr), value :: transform_from
end function

!   GEnumValue* g_enum_get_value (GEnumClass *enum_class, gint value);
function g_enum_get_value(enum_class, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_enum_get_value
  type(c_ptr), value :: enum_class
  integer(c_int), value :: value
end function

! GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class, const gchar *name);
function g_enum_get_value_by_name(enum_class, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_name
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: name
end function

! GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class, const gchar *nick);
function g_enum_get_value_by_nick(enum_class, nick) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_enum_get_value_by_nick
  type(c_ptr), value :: enum_class
  character(kind=c_char), dimension(*) :: nick
end function

! GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class, guint value);
function g_flags_get_first_value(flags_class, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_flags_get_first_value
  type(c_ptr), value :: flags_class
  integer(c_int), value :: value
end function

! GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class, const gchar *name);
function g_flags_get_value_by_name(flags_class, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_name
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: name
end function

! GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class, const gchar *nick);
function g_flags_get_value_by_nick(flags_class, nick) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_flags_get_value_by_nick
  type(c_ptr), value :: flags_class
  character(kind=c_char), dimension(*) :: nick
end function

! void g_value_set_enum (GValue *value, gint v_enum);
subroutine g_value_set_enum(value, v_enum) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_enum
end subroutine

! gint g_value_get_enum (const GValue *value);
function g_value_get_enum(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_enum
  type(c_ptr), value :: value
end function

! void g_value_set_flags (GValue *value, guint v_flags);
subroutine g_value_set_flags(value, v_flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_flags
end subroutine

! guint g_value_get_flags (const GValue *value);
function g_value_get_flags(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_flags
  type(c_ptr), value :: value
end function

!  GType g_enum_register_static (const gchar *name, const GEnumValue *const_static_values);
function g_enum_register_static(name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_enum_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GType g_flags_register_static (const gchar *name, const GFlagsValue *const_static_values);
function g_flags_register_static(name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_flags_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

!  void g_enum_complete_type_info (GType g_enum_type, GTypeInfo *info, const GEnumValue *const_values);
subroutine g_enum_complete_type_info(g_enum_type, info, const_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: g_enum_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

! void g_flags_complete_type_info (GType g_flags_type, GTypeInfo *info, const GFlagsValue *const_values);
subroutine g_flags_complete_type_info(g_flags_type, info, const_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: g_flags_type
  type(c_ptr), value :: info
  type(c_ptr), value :: const_values
end subroutine

!   GType g_type_module_get_type (void) G_GNUC_CONST;
function g_type_module_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_module_get_type
end function

! gboolean g_type_module_use (GTypeModule *module);
function g_type_module_use(module) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_type_module_use
  type(c_ptr), value :: module
end function

! void g_type_module_unuse (GTypeModule *module);
subroutine g_type_module_unuse(module) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: module
end subroutine

! void g_type_module_set_name (GTypeModule *module, const gchar *name);
subroutine g_type_module_set_name(module, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
end subroutine

! GType g_type_module_register_type (GTypeModule *module, GType parent_type, const gchar *type_name, const GTypeInfo *type_info, GTypeFlags flags);
function g_type_module_register_type(module, parent_type, type_name, type_info,&
& flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char, c_int
  integer(c_size_t) :: g_type_module_register_type
  type(c_ptr), value :: module
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: type_info
  integer(c_int), value :: flags
end function

! void g_type_module_add_interface (GTypeModule *module, GType instance_type, GType interface_type, const GInterfaceInfo *interface_info);
subroutine g_type_module_add_interface(module, instance_type, interface_type, i&
&nterface_info) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: module
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: interface_info
end subroutine

! GType g_type_module_register_enum (GTypeModule *module, const gchar *name, const GEnumValue *const_static_values);
function g_type_module_register_enum(module, name, const_static_values) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_enum
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

! GType g_type_module_register_flags (GTypeModule *module, const gchar *name, const GFlagsValue *const_static_values);
function g_type_module_register_flags(module, name, const_static_values) bind(c&
&) 
  use iso_c_binding, only: c_size_t, c_ptr, c_char
  integer(c_size_t) :: g_type_module_register_flags
  type(c_ptr), value :: module
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: const_static_values
end function

!   void g_source_set_closure (GSource *source, GClosure *closure);
subroutine g_source_set_closure(source, closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
  type(c_ptr), value :: closure
end subroutine

!  void g_source_set_dummy_callback (GSource *source);
subroutine g_source_set_dummy_callback(source) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: source
end subroutine

!  GType g_io_channel_get_type (void);
function g_io_channel_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_channel_get_type
end function

! GType g_io_condition_get_type (void);
function g_io_condition_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_io_condition_get_type
end function

!   GParamSpec* g_param_spec_char (const gchar *name, const gchar *nick, const gchar *blurb, gint8 minimum, gint8 maximum, gint8 default_value, GParamFlags flags);
function g_param_spec_char(name, nick, blurb, minimum, maximum, default_value, &
&flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_char
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uchar (const gchar *name, const gchar *nick, const gchar *blurb, guint8 minimum, guint8 maximum, guint8 default_value, GParamFlags flags);
function g_param_spec_uchar(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int8_t, c_int
  type(c_ptr) :: g_param_spec_uchar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int8_t), value :: minimum
  integer(c_int8_t), value :: maximum
  integer(c_int8_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_boolean (const gchar *name, const gchar *nick, const gchar *blurb, gboolean default_value, GParamFlags flags);
function g_param_spec_boolean(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_boolean
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_int (const gchar *name, const gchar *nick, const gchar *blurb, gint minimum, gint maximum, gint default_value, GParamFlags flags);
function g_param_spec_int(name, nick, blurb, minimum, maximum, default_value, f&
&lags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_int
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uint (const gchar *name, const gchar *nick, const gchar *blurb, guint minimum, guint maximum, guint default_value, GParamFlags flags);
function g_param_spec_uint(name, nick, blurb, minimum, maximum, default_value, &
&flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_uint
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: minimum
  integer(c_int), value :: maximum
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_long (const gchar *name, const gchar *nick, const gchar *blurb, glong minimum, glong maximum, glong default_value, GParamFlags flags);
function g_param_spec_long(name, nick, blurb, minimum, maximum, default_value, &
&flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_long
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_ulong (const gchar *name, const gchar *nick, const gchar *blurb, gulong minimum, gulong maximum, gulong default_value, GParamFlags flags);
function g_param_spec_ulong(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_long, c_int
  type(c_ptr) :: g_param_spec_ulong
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_long), value :: minimum
  integer(c_long), value :: maximum
  integer(c_long), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_int64 (const gchar *name, const gchar *nick, const gchar *blurb, gint64 minimum, gint64 maximum, gint64 default_value, GParamFlags flags);
function g_param_spec_int64(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_int64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_uint64 (const gchar *name, const gchar *nick, const gchar *blurb, guint64 minimum, guint64 maximum, guint64 default_value, GParamFlags flags);
function g_param_spec_uint64(name, nick, blurb, minimum, maximum, default_value&
&, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int64_t, c_int
  type(c_ptr) :: g_param_spec_uint64
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int64_t), value :: minimum
  integer(c_int64_t), value :: maximum
  integer(c_int64_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_unichar (const gchar *name, const gchar *nick, const gchar *blurb, gunichar default_value, GParamFlags flags);
function g_param_spec_unichar(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int32_t, c_int
  type(c_ptr) :: g_param_spec_unichar
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int32_t), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_enum (const gchar *name, const gchar *nick, const gchar *blurb, GType enum_type, gint default_value, GParamFlags flags);
function g_param_spec_enum(name, nick, blurb, enum_type, default_value, flags) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_enum
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: enum_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_flags (const gchar *name, const gchar *nick, const gchar *blurb, GType flags_type, guint default_value, GParamFlags flags);
function g_param_spec_flags(name, nick, blurb, flags_type, default_value, flags&
&) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_flags
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: flags_type
  integer(c_int), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_float (const gchar *name, const gchar *nick, const gchar *blurb, gfloat minimum, gfloat maximum, gfloat default_value, GParamFlags flags);
function g_param_spec_float(name, nick, blurb, minimum, maximum, default_value,&
& flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_float, c_int
  type(c_ptr) :: g_param_spec_float
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_float), value :: minimum
  real(c_float), value :: maximum
  real(c_float), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_double (const gchar *name, const gchar *nick, const gchar *blurb, gdouble minimum, gdouble maximum, gdouble default_value, GParamFlags flags);
function g_param_spec_double(name, nick, blurb, minimum, maximum, default_value&
&, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_double, c_int
  type(c_ptr) :: g_param_spec_double
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  real(c_double), value :: minimum
  real(c_double), value :: maximum
  real(c_double), value :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_string (const gchar *name, const gchar *nick, const gchar *blurb, const gchar *default_value, GParamFlags flags);
function g_param_spec_string(name, nick, blurb, default_value, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_string
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  character(kind=c_char), dimension(*) :: default_value
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_param (const gchar *name, const gchar *nick, const gchar *blurb, GType param_type, GParamFlags flags);
function g_param_spec_param(name, nick, blurb, param_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_param
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: param_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_boxed (const gchar *name, const gchar *nick, const gchar *blurb, GType boxed_type, GParamFlags flags);
function g_param_spec_boxed(name, nick, blurb, boxed_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_boxed
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: boxed_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_pointer (const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_pointer(name, nick, blurb, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_pointer
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_value_array (const gchar *name, const gchar *nick, const gchar *blurb, GParamSpec *element_spec, GParamFlags flags);
function g_param_spec_value_array(name, nick, blurb, element_spec, flags) bind(&
&c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_value_array
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: element_spec
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_object (const gchar *name, const gchar *nick, const gchar *blurb, GType object_type, GParamFlags flags);
function g_param_spec_object(name, nick, blurb, object_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_object
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: object_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_override (const gchar *name, GParamSpec *overridden);
function g_param_spec_override(name, overridden) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_param_spec_override
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: overridden
end function

! GParamSpec* g_param_spec_gtype (const gchar *name, const gchar *nick, const gchar *blurb, GType is_a_type, GParamFlags flags);
function g_param_spec_gtype(name, nick, blurb, is_a_type, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_gtype
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_size_t), value :: is_a_type
  integer(c_int), value :: flags
end function

! GParamSpec* g_param_spec_variant (const gchar *name, const gchar *nick, const gchar *blurb, const GVariantType *type, GVariant *default_value, GParamFlags flags);
function g_param_spec_variant(name, nick, blurb, type, default_value, flags) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr, c_char, c_int
  type(c_ptr) :: g_param_spec_variant
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  type(c_ptr), value :: type
  type(c_ptr), value :: default_value
  integer(c_int), value :: flags
end function

!   guint g_signal_newv (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, GType *param_types);
function g_signal_newv(signal_name, itype, signal_flags, class_closure, accumul&
&ator, accu_data, c_marshaller, return_type, n_params, param_types) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_newv
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: param_types
end function

! guint g_signal_new_valist (const gchar *signal_name, GType itype, GSignalFlags signal_flags, GClosure *class_closure, GSignalAccumulator accumulator, gpointer accu_data, GSignalCMarshaller c_marshaller, GType return_type, guint n_params, va_list args);
function g_signal_new_valist(signal_name, itype, signal_flags, class_closure, a&
&ccumulator, accu_data, c_marshaller, return_type, n_params, args) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr, c_funptr
  integer(c_int) :: g_signal_new_valist
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: itype
  integer(c_int), value :: signal_flags
  type(c_ptr), value :: class_closure
  type(c_funptr), value :: accumulator
  type(c_ptr), value :: accu_data
  type(c_ptr), value :: c_marshaller
  integer(c_size_t), value :: return_type
  integer(c_int), value :: n_params
  type(c_ptr), value :: args
end function

!  void g_signal_emitv (const GValue *instance_and_params, guint signal_id, GQuark detail, GValue *return_value);
subroutine g_signal_emitv(instance_and_params, signal_id, detail, return_value)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance_and_params
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: return_value
end subroutine

! void g_signal_emit_valist (gpointer instance, guint signal_id, GQuark detail, va_list var_args);
subroutine g_signal_emit_valist(instance, signal_id, detail, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: var_args
end subroutine

! guint g_signal_lookup (const gchar *name, GType itype);
function g_signal_lookup(name, itype) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t
  integer(c_int) :: g_signal_lookup
  character(kind=c_char), dimension(*) :: name
  integer(c_size_t), value :: itype
end function

! G_CONST_RETURN gchar* g_signal_name (guint signal_id);
function g_signal_name(signal_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_signal_name
  integer(c_int), value :: signal_id
end function

! void g_signal_query (guint signal_id, GSignalQuery *query);
subroutine g_signal_query(signal_id, query) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int), value :: signal_id
  type(c_ptr), value :: query
end subroutine

! guint* g_signal_list_ids (GType itype, guint *n_ids);
function g_signal_list_ids(itype, n_ids) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_signal_list_ids
  integer(c_size_t), value :: itype
  type(c_ptr), value :: n_ids
end function

! gboolean g_signal_parse_name (const gchar *detailed_signal, GType itype, guint *signal_id_p, GQuark *detail_p, gboolean force_detail_quark);
function g_signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, for&
&ce_detail_quark) bind(c) 
  use iso_c_binding, only: c_int, c_char, c_size_t, c_ptr
  integer(c_int) :: g_signal_parse_name
  character(kind=c_char), dimension(*) :: detailed_signal
  integer(c_size_t), value :: itype
  type(c_ptr), value :: signal_id_p
  type(c_ptr), value :: detail_p
  integer(c_int), value :: force_detail_quark
end function

! GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);
function g_signal_get_invocation_hint(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_signal_get_invocation_hint
  type(c_ptr), value :: instance
end function

!  void g_signal_stop_emission (gpointer instance, guint signal_id, GQuark detail);
subroutine g_signal_stop_emission(instance, signal_id, detail) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_int32_t
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
end subroutine

! void g_signal_stop_emission_by_name (gpointer instance, const gchar *detailed_signal);
subroutine g_signal_stop_emission_by_name(instance, detailed_signal) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
end subroutine

! gulong g_signal_add_emission_hook (guint signal_id, GQuark detail, GSignalEmissionHook hook_func, gpointer hook_data, GDestroyNotify data_destroy);
function g_signal_add_emission_hook(signal_id, detail, hook_func, hook_data, da&
&ta_destroy) bind(c) 
  use iso_c_binding, only: c_long, c_int, c_int32_t, c_funptr, c_ptr
  integer(c_long) :: g_signal_add_emission_hook
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_funptr), value :: hook_func
  type(c_ptr), value :: hook_data
  type(c_funptr), value :: data_destroy
end function

! void g_signal_remove_emission_hook (guint signal_id, gulong hook_id);
subroutine g_signal_remove_emission_hook(signal_id, hook_id) bind(c) 
  use iso_c_binding, only: c_int, c_long
  integer(c_int), value :: signal_id
  integer(c_long), value :: hook_id
end subroutine

!  gboolean g_signal_has_handler_pending (gpointer instance, guint signal_id, GQuark detail, gboolean may_be_blocked);
function g_signal_has_handler_pending(instance, signal_id, detail, may_be_block&
&ed) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_has_handler_pending
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  integer(c_int), value :: may_be_blocked
end function

! gulong g_signal_connect_closure_by_id (gpointer instance, guint signal_id, GQuark detail, GClosure *closure, gboolean after);
function g_signal_connect_closure_by_id(instance, signal_id, detail, closure, a&
&fter) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int, c_int32_t
  integer(c_long) :: g_signal_connect_closure_by_id
  type(c_ptr), value :: instance
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  integer(c_int), value :: after
end function

! gulong g_signal_connect_closure (gpointer instance, const gchar *detailed_signal, GClosure *closure, gboolean after);
function g_signal_connect_closure(instance, detailed_signal, closure, after) bi&
&nd(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_int
  integer(c_long) :: g_signal_connect_closure
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_ptr), value :: closure
  integer(c_int), value :: after
end function

! gulong g_signal_connect_data (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer data, GClosureNotify destroy_data, GConnectFlags connect_flags);
function g_signal_connect_data(instance, detailed_signal, c_handler, data, dest&
&roy_data, connect_flags) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_data
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy_data
  integer(c_int), value :: connect_flags
end function

! void g_signal_handler_block (gpointer instance, gulong handler_id);
subroutine g_signal_handler_block(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! void g_signal_handler_unblock (gpointer instance, gulong handler_id);
subroutine g_signal_handler_unblock(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! void g_signal_handler_disconnect (gpointer instance, gulong handler_id);
subroutine g_signal_handler_disconnect(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end subroutine

! gboolean g_signal_handler_is_connected (gpointer instance, gulong handler_id);
function g_signal_handler_is_connected(instance, handler_id) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_long
  integer(c_int) :: g_signal_handler_is_connected
  type(c_ptr), value :: instance
  integer(c_long), value :: handler_id
end function

! gulong g_signal_handler_find (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handler_find(instance, mask, signal_id, detail, closure, func&
&, data) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_int, c_int32_t
  integer(c_long) :: g_signal_handler_find
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_block_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_block_matched(instance, mask, signal_id, detail, clo&
&sure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_block_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_unblock_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_unblock_matched(instance, mask, signal_id, detail, c&
&losure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_unblock_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

! guint g_signal_handlers_disconnect_matched (gpointer instance, GSignalMatchType mask, guint signal_id, GQuark detail, GClosure *closure, gpointer func, gpointer data);
function g_signal_handlers_disconnect_matched(instance, mask, signal_id, detail&
&, closure, func, data) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_int32_t
  integer(c_int) :: g_signal_handlers_disconnect_matched
  type(c_ptr), value :: instance
  integer(c_int), value :: mask
  integer(c_int), value :: signal_id
  integer(c_int32_t), value :: detail
  type(c_ptr), value :: closure
  type(c_ptr), value :: func
  type(c_ptr), value :: data
end function

!  void g_signal_override_class_closure (guint signal_id, GType instance_type, GClosure *class_closure);
subroutine g_signal_override_class_closure(signal_id, instance_type, class_clos&
&ure) bind(c) 
  use iso_c_binding, only: c_int, c_size_t, c_ptr
  integer(c_int), value :: signal_id
  integer(c_size_t), value :: instance_type
  type(c_ptr), value :: class_closure
end subroutine

! void g_signal_override_class_handler (const gchar *signal_name, GType instance_type, GCallback class_handler);
subroutine g_signal_override_class_handler(signal_name, instance_type, class_ha&
&ndler) bind(c) 
  use iso_c_binding, only: c_char, c_size_t, c_funptr
  character(kind=c_char), dimension(*) :: signal_name
  integer(c_size_t), value :: instance_type
  type(c_funptr), value :: class_handler
end subroutine

! void g_signal_chain_from_overridden (const GValue *instance_and_params, GValue *return_value);
subroutine g_signal_chain_from_overridden(instance_and_params, return_value) bi&
&nd(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance_and_params
  type(c_ptr), value :: return_value
end subroutine

!  gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
function g_signal_accumulator_true_handled(ihint, return_accu, handler_return, &
&dummy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_signal_accumulator_true_handled
  type(c_ptr), value :: ihint
  type(c_ptr), value :: return_accu
  type(c_ptr), value :: handler_return
  type(c_ptr), value :: dummy
end function

!  gboolean g_signal_accumulator_first_wins (GSignalInvocationHint *ihint, GValue *return_accu, const GValue *handler_return, gpointer dummy);
function g_signal_accumulator_first_wins(ihint, return_accu, handler_return, du&
&mmy) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_signal_accumulator_first_wins
  type(c_ptr), value :: ihint
  type(c_ptr), value :: return_accu
  type(c_ptr), value :: handler_return
  type(c_ptr), value :: dummy
end function

!  void g_signal_handlers_destroy (gpointer instance);
subroutine g_signal_handlers_destroy(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance
end subroutine

!   void g_cclosure_marshal_VOID__VOID (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VOID(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOOLEAN(closure, return_value, n_param_valu&
&es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__CHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__CHAR(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UCHAR (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UCHAR(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__INT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__INT(closure, return_value, n_param_values, &
&param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UINT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__LONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__LONG(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__ULONG (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ULONG(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__ENUM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__ENUM(closure, return_value, n_param_values,&
& param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLAGS(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__FLOAT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__FLOAT(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__DOUBLE(closure, return_value, n_param_value&
&s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__STRING (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__STRING(closure, return_value, n_param_value&
&s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__PARAM (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__PARAM(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__BOXED(closure, return_value, n_param_values&
&, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__POINTER(closure, return_value, n_param_valu&
&es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__OBJECT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__OBJECT(closure, return_value, n_param_value&
&s, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__VARIANT (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__VARIANT(closure, return_value, n_param_valu&
&es, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_VOID__UINT_POINTER(closure, return_value, n_param&
&_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__FLAGS(closure, return_value, n_param_val&
&ues, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_STRING__OBJECT_POINTER(closure, return_value, n_p&
&aram_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!  void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure *closure, GValue *return_value, guint n_param_values, const GValue *param_values, gpointer invocation_hint, gpointer marshal_data);
subroutine g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure, return_value, n_par&
&am_values, param_values, invocation_hint, marshal_data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: closure
  type(c_ptr), value :: return_value
  integer(c_int), value :: n_param_values
  type(c_ptr), value :: param_values
  type(c_ptr), value :: invocation_hint
  type(c_ptr), value :: marshal_data
end subroutine

!   GType g_type_plugin_get_type (void) G_GNUC_CONST;
function g_type_plugin_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_plugin_get_type
end function

! void g_type_plugin_use (GTypePlugin *plugin);
subroutine g_type_plugin_use(plugin) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! void g_type_plugin_unuse (GTypePlugin *plugin);
subroutine g_type_plugin_unuse(plugin) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: plugin
end subroutine

! void g_type_plugin_complete_type_info (GTypePlugin *plugin, GType g_type, GTypeInfo *info, GTypeValueTable *value_table);
subroutine g_type_plugin_complete_type_info(plugin, g_type, info, value_table) &
&bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: g_type
  type(c_ptr), value :: info
  type(c_ptr), value :: value_table
end subroutine

! void g_type_plugin_complete_interface_info (GTypePlugin *plugin, GType instance_type, GType interface_type, GInterfaceInfo *info);
subroutine g_type_plugin_complete_interface_info(plugin, instance_type, interfa&
&ce_type, info) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

!   void g_value_set_char (GValue *value, gchar v_char);
subroutine g_value_set_char(value, v_char) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr), value :: value
  integer(kind=c_int8_t), value :: v_char
end subroutine

! gchar g_value_get_char (const GValue *value);
function g_value_get_char(value) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_value_get_char
  type(c_ptr), value :: value
end function

! void g_value_set_uchar (GValue *value, guchar v_uchar);
subroutine g_value_set_uchar(value, v_uchar) bind(c) 
  use iso_c_binding, only: c_ptr, c_int8_t
  type(c_ptr), value :: value
  integer(kind=c_int8_t), value :: v_uchar
end subroutine

! guchar g_value_get_uchar (const GValue *value);
function g_value_get_uchar(value) bind(c) 
  use iso_c_binding, only: c_int8_t, c_ptr
  integer(kind=c_int8_t) :: g_value_get_uchar
  type(c_ptr), value :: value
end function

! void g_value_set_boolean (GValue *value, gboolean v_boolean);
subroutine g_value_set_boolean(value, v_boolean) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_boolean
end subroutine

! gboolean g_value_get_boolean (const GValue *value);
function g_value_get_boolean(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_boolean
  type(c_ptr), value :: value
end function

! void g_value_set_int (GValue *value, gint v_int);
subroutine g_value_set_int(value, v_int) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_int
end subroutine

! gint g_value_get_int (const GValue *value);
function g_value_get_int(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_int
  type(c_ptr), value :: value
end function

! void g_value_set_uint (GValue *value, guint v_uint);
subroutine g_value_set_uint(value, v_uint) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: value
  integer(c_int), value :: v_uint
end subroutine

! guint g_value_get_uint (const GValue *value);
function g_value_get_uint(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_value_get_uint
  type(c_ptr), value :: value
end function

! void g_value_set_long (GValue *value, glong v_long);
subroutine g_value_set_long(value, v_long) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_long
end subroutine

! glong g_value_get_long (const GValue *value);
function g_value_get_long(value) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: g_value_get_long
  type(c_ptr), value :: value
end function

! void g_value_set_ulong (GValue *value, gulong v_ulong);
subroutine g_value_set_ulong(value, v_ulong) bind(c) 
  use iso_c_binding, only: c_ptr, c_long
  type(c_ptr), value :: value
  integer(c_long), value :: v_ulong
end subroutine

! gulong g_value_get_ulong (const GValue *value);
function g_value_get_ulong(value) bind(c) 
  use iso_c_binding, only: c_long, c_ptr
  integer(c_long) :: g_value_get_ulong
  type(c_ptr), value :: value
end function

! void g_value_set_int64 (GValue *value, gint64 v_int64);
subroutine g_value_set_int64(value, v_int64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_int64
end subroutine

! gint64 g_value_get_int64 (const GValue *value);
function g_value_get_int64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_int64
  type(c_ptr), value :: value
end function

! void g_value_set_uint64 (GValue *value, guint64 v_uint64);
subroutine g_value_set_uint64(value, v_uint64) bind(c) 
  use iso_c_binding, only: c_ptr, c_int64_t
  type(c_ptr), value :: value
  integer(c_int64_t), value :: v_uint64
end subroutine

! guint64 g_value_get_uint64 (const GValue *value);
function g_value_get_uint64(value) bind(c) 
  use iso_c_binding, only: c_int64_t, c_ptr
  integer(c_int64_t) :: g_value_get_uint64
  type(c_ptr), value :: value
end function

! void g_value_set_float (GValue *value, gfloat v_float);
subroutine g_value_set_float(value, v_float) bind(c) 
  use iso_c_binding, only: c_ptr, c_float
  type(c_ptr), value :: value
  real(c_float), value :: v_float
end subroutine

! gfloat g_value_get_float (const GValue *value);
function g_value_get_float(value) bind(c) 
  use iso_c_binding, only: c_float, c_ptr
  real(c_float) :: g_value_get_float
  type(c_ptr), value :: value
end function

! void g_value_set_double (GValue *value, gdouble v_double);
subroutine g_value_set_double(value, v_double) bind(c) 
  use iso_c_binding, only: c_ptr, c_double
  type(c_ptr), value :: value
  real(c_double), value :: v_double
end subroutine

! gdouble g_value_get_double (const GValue *value);
function g_value_get_double(value) bind(c) 
  use iso_c_binding, only: c_double, c_ptr
  real(c_double) :: g_value_get_double
  type(c_ptr), value :: value
end function

! void g_value_set_string (GValue *value, const gchar *v_string);
subroutine g_value_set_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! void g_value_set_static_string (GValue *value, const gchar *v_string);
subroutine g_value_set_static_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

! G_CONST_RETURN gchar* g_value_get_string (const GValue *value);
function g_value_get_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_string
  type(c_ptr), value :: value
end function

! gchar* g_value_dup_string (const GValue *value);
function g_value_dup_string(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_string
  type(c_ptr), value :: value
end function

! void g_value_set_pointer (GValue *value, gpointer v_pointer);
subroutine g_value_set_pointer(value, v_pointer) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_pointer
end subroutine

! gpointer g_value_get_pointer (const GValue *value);
function g_value_get_pointer(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_pointer
  type(c_ptr), value :: value
end function

! GType g_gtype_get_type (void);
function g_gtype_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_gtype_get_type
end function

! void g_value_set_gtype (GValue *value, GType v_gtype);
subroutine g_value_set_gtype(value, v_gtype) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: value
  integer(c_size_t), value :: v_gtype
end subroutine

! GType g_value_get_gtype (const GValue *value);
function g_value_get_gtype(value) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_value_get_gtype
  type(c_ptr), value :: value
end function

! void g_value_set_variant (GValue *value, GVariant *variant);
subroutine g_value_set_variant(value, variant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! void g_value_take_variant (GValue *value, GVariant *variant);
subroutine g_value_take_variant(value, variant) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: variant
end subroutine

! GVariant* g_value_get_variant (const GValue *value);
function g_value_get_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_variant
  type(c_ptr), value :: value
end function

! GVariant* g_value_dup_variant (const GValue *value);
function g_value_dup_variant(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_variant
  type(c_ptr), value :: value
end function

!  GType g_pointer_type_register_static (const gchar *name);
function g_pointer_type_register_static(name) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_pointer_type_register_static
  character(kind=c_char), dimension(*) :: name
end function

!  gchar* g_strdup_value_contents (const GValue *value);
function g_strdup_value_contents(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_strdup_value_contents
  type(c_ptr), value :: value
end function

!  void g_value_take_string (GValue *value, gchar *v_string);
subroutine g_value_take_string(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

!  void g_value_set_string_take_ownership (GValue *value, gchar *v_string);
subroutine g_value_set_string_take_ownership(value, v_string) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: value
  character(kind=c_char), dimension(*) :: v_string
end subroutine

!     GParamSpec* g_param_spec_ref (GParamSpec *pspec);
function g_param_spec_ref(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_ref
  type(c_ptr), value :: pspec
end function

! void g_param_spec_unref (GParamSpec *pspec);
subroutine g_param_spec_unref(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! void g_param_spec_sink (GParamSpec *pspec);
subroutine g_param_spec_sink(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
function g_param_spec_ref_sink(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_ref_sink
  type(c_ptr), value :: pspec
end function

! gpointer g_param_spec_get_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_get_qdata(pspec, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_get_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! void g_param_spec_set_qdata (GParamSpec *pspec, GQuark quark, gpointer data);
subroutine g_param_spec_set_qdata(pspec, quark, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! void g_param_spec_set_qdata_full (GParamSpec *pspec, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_param_spec_set_qdata_full(pspec, quark, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_param_spec_steal_qdata (GParamSpec *pspec, GQuark quark);
function g_param_spec_steal_qdata(pspec, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_param_spec_steal_qdata
  type(c_ptr), value :: pspec
  integer(c_int32_t), value :: quark
end function

! GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);
function g_param_spec_get_redirect_target(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_redirect_target
  type(c_ptr), value :: pspec
end function

!  void g_param_value_set_default (GParamSpec *pspec, GValue *value);
subroutine g_param_value_set_default(pspec, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end subroutine

! gboolean g_param_value_defaults (GParamSpec *pspec, GValue *value);
function g_param_value_defaults(pspec, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_param_value_defaults
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! gboolean g_param_value_validate (GParamSpec *pspec, GValue *value);
function g_param_value_validate(pspec, value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_param_value_validate
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value
end function

! gboolean g_param_value_convert (GParamSpec *pspec, const GValue *src_value, GValue *dest_value, gboolean strict_validation);
function g_param_value_convert(pspec, src_value, dest_value, strict_validation)&
& bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_param_value_convert
  type(c_ptr), value :: pspec
  type(c_ptr), value :: src_value
  type(c_ptr), value :: dest_value
  integer(c_int), value :: strict_validation
end function

! gint g_param_values_cmp (GParamSpec *pspec, const GValue *value1, const GValue *value2);
function g_param_values_cmp(pspec, value1, value2) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_param_values_cmp
  type(c_ptr), value :: pspec
  type(c_ptr), value :: value1
  type(c_ptr), value :: value2
end function

! G_CONST_RETURN gchar* g_param_spec_get_name (GParamSpec *pspec);
function g_param_spec_get_name(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_name
  type(c_ptr), value :: pspec
end function

! G_CONST_RETURN gchar* g_param_spec_get_nick (GParamSpec *pspec);
function g_param_spec_get_nick(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_nick
  type(c_ptr), value :: pspec
end function

! G_CONST_RETURN gchar* g_param_spec_get_blurb (GParamSpec *pspec);
function g_param_spec_get_blurb(pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_param_spec_get_blurb
  type(c_ptr), value :: pspec
end function

! void g_value_set_param (GValue *value, GParamSpec *param);
subroutine g_value_set_param(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

! GParamSpec* g_value_get_param (const GValue *value);
function g_value_get_param(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_param
  type(c_ptr), value :: value
end function

! GParamSpec* g_value_dup_param (const GValue *value);
function g_value_dup_param(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_param
  type(c_ptr), value :: value
end function

!  void g_value_take_param (GValue *value, GParamSpec *param);
subroutine g_value_take_param(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

!  void g_value_set_param_take_ownership (GValue *value, GParamSpec *param);
subroutine g_value_set_param_take_ownership(value, param) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: param
end subroutine

!  GType g_param_type_register_static (const gchar *name, const GParamSpecTypeInfo *pspec_info);
function g_param_type_register_static(name, pspec_info) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr
  integer(c_size_t) :: g_param_type_register_static
  character(kind=c_char), dimension(*) :: name
  type(c_ptr), value :: pspec_info
end function

!  gpointer g_param_spec_internal (GType param_type, const gchar *name, const gchar *nick, const gchar *blurb, GParamFlags flags);
function g_param_spec_internal(param_type, name, nick, blurb, flags) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char, c_int
  type(c_ptr) :: g_param_spec_internal
  integer(c_size_t), value :: param_type
  character(kind=c_char), dimension(*) :: name
  character(kind=c_char), dimension(*) :: nick
  character(kind=c_char), dimension(*) :: blurb
  integer(c_int), value :: flags
end function

! GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
function g_param_spec_pool_new(type_prefixing) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_param_spec_pool_new
  integer(c_int), value :: type_prefixing
end function

! void g_param_spec_pool_insert (GParamSpecPool *pool, GParamSpec *pspec, GType owner_type);
subroutine g_param_spec_pool_insert(pool, pspec, owner_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
  integer(c_size_t), value :: owner_type
end subroutine

! void g_param_spec_pool_remove (GParamSpecPool *pool, GParamSpec *pspec);
subroutine g_param_spec_pool_remove(pool, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: pool
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool, const gchar *param_name, GType owner_type, gboolean walk_ancestors);
function g_param_spec_pool_lookup(pool, param_name, owner_type, walk_ancestors)&
& bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_size_t, c_int
  type(c_ptr) :: g_param_spec_pool_lookup
  type(c_ptr), value :: pool
  character(kind=c_char), dimension(*) :: param_name
  integer(c_size_t), value :: owner_type
  integer(c_int), value :: walk_ancestors
end function

! GList* g_param_spec_pool_list_owned (GParamSpecPool *pool, GType owner_type);
function g_param_spec_pool_list_owned(pool, owner_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list_owned
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
end function

! GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool, GType owner_type, guint *n_pspecs_p);
function g_param_spec_pool_list(pool, owner_type, n_pspecs_p) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_param_spec_pool_list
  type(c_ptr), value :: pool
  integer(c_size_t), value :: owner_type
  type(c_ptr), value :: n_pspecs_p
end function

!   GValue* g_value_array_get_nth (GValueArray *value_array, guint index_);
function g_value_array_get_nth(value_array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_get_nth
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GValueArray* g_value_array_new (guint n_prealloced);
function g_value_array_new(n_prealloced) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_new
  integer(c_int), value :: n_prealloced
end function

! void g_value_array_free (GValueArray *value_array);
subroutine g_value_array_free(value_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value_array
end subroutine

! GValueArray* g_value_array_copy (const GValueArray *value_array);
function g_value_array_copy(value_array) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_copy
  type(c_ptr), value :: value_array
end function

! GValueArray* g_value_array_prepend (GValueArray *value_array, const GValue *value);
function g_value_array_prepend(value_array, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_prepend
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_append (GValueArray *value_array, const GValue *value);
function g_value_array_append(value_array, value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_array_append
  type(c_ptr), value :: value_array
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_insert (GValueArray *value_array, guint index_, const GValue *value);
function g_value_array_insert(value_array, index_, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_insert
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
  type(c_ptr), value :: value
end function

! GValueArray* g_value_array_remove (GValueArray *value_array, guint index_);
function g_value_array_remove(value_array, index_) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_value_array_remove
  type(c_ptr), value :: value_array
  integer(c_int), value :: index_
end function

! GValueArray* g_value_array_sort (GValueArray *value_array, GCompareFunc compare_func);
function g_value_array_sort(value_array, compare_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
end function

! GValueArray* g_value_array_sort_with_data (GValueArray *value_array, GCompareDataFunc compare_func, gpointer user_data);
function g_value_array_sort_with_data(value_array, compare_func, user_data) bin&
&d(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_value_array_sort_with_data
  type(c_ptr), value :: value_array
  type(c_funptr), value :: compare_func
  type(c_ptr), value :: user_data
end function

!   void g_type_init (void);
subroutine g_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
subroutine g_type_init_with_debug_flags(debug_flags) bind(c) 
  use iso_c_binding, only: c_int
  integer(c_int), value :: debug_flags
end subroutine

! G_CONST_RETURN gchar* g_type_name (GType type);
function g_type_name(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_name
  integer(c_size_t), value :: type
end function

! GQuark g_type_qname (GType type);
function g_type_qname(type) bind(c) 
  use iso_c_binding, only: c_int32_t, c_size_t
  integer(c_int32_t) :: g_type_qname
  integer(c_size_t), value :: type
end function

! GType g_type_from_name (const gchar *name);
function g_type_from_name(name) bind(c) 
  use iso_c_binding, only: c_size_t, c_char
  integer(c_size_t) :: g_type_from_name
  character(kind=c_char), dimension(*) :: name
end function

! GType g_type_parent (GType type);
function g_type_parent(type) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_parent
  integer(c_size_t), value :: type
end function

! guint g_type_depth (GType type);
function g_type_depth(type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_type_depth
  integer(c_size_t), value :: type
end function

! GType g_type_next_base (GType leaf_type, GType root_type);
function g_type_next_base(leaf_type, root_type) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_next_base
  integer(c_size_t), value :: leaf_type
  integer(c_size_t), value :: root_type
end function

! gboolean g_type_is_a (GType type, GType is_a_type);
function g_type_is_a(type, is_a_type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_type_is_a
  integer(c_size_t), value :: type
  integer(c_size_t), value :: is_a_type
end function

! gpointer g_type_class_ref (GType type);
function g_type_class_ref(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_ref
  integer(c_size_t), value :: type
end function

! gpointer g_type_class_peek (GType type);
function g_type_class_peek(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek
  integer(c_size_t), value :: type
end function

! gpointer g_type_class_peek_static (GType type);
function g_type_class_peek_static(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_peek_static
  integer(c_size_t), value :: type
end function

! void g_type_class_unref (gpointer g_class);
subroutine g_type_class_unref(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_class
end subroutine

! gpointer g_type_class_peek_parent (gpointer g_class);
function g_type_class_peek_parent(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_class_peek_parent
  type(c_ptr), value :: g_class
end function

! gpointer g_type_interface_peek (gpointer instance_class, GType iface_type);
function g_type_interface_peek(instance_class, iface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_peek
  type(c_ptr), value :: instance_class
  integer(c_size_t), value :: iface_type
end function

! gpointer g_type_interface_peek_parent (gpointer g_iface);
function g_type_interface_peek_parent(g_iface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_interface_peek_parent
  type(c_ptr), value :: g_iface
end function

!  gpointer g_type_default_interface_ref (GType g_type);
function g_type_default_interface_ref(g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_ref
  integer(c_size_t), value :: g_type
end function

! gpointer g_type_default_interface_peek (GType g_type);
function g_type_default_interface_peek(g_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_default_interface_peek
  integer(c_size_t), value :: g_type
end function

! void g_type_default_interface_unref (gpointer g_iface);
subroutine g_type_default_interface_unref(g_iface) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_iface
end subroutine

!  GType* g_type_children (GType type, guint *n_children);
function g_type_children(type, n_children) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_children
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_children
end function

! GType* g_type_interfaces (GType type, guint *n_interfaces);
function g_type_interfaces(type, n_interfaces) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interfaces
  integer(c_size_t), value :: type
  type(c_ptr), value :: n_interfaces
end function

!  void g_type_set_qdata (GType type, GQuark quark, gpointer data);
subroutine g_type_set_qdata(type, quark, data) bind(c) 
  use iso_c_binding, only: c_size_t, c_int32_t, c_ptr
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! gpointer g_type_get_qdata (GType type, GQuark quark);
function g_type_get_qdata(type, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int32_t
  type(c_ptr) :: g_type_get_qdata
  integer(c_size_t), value :: type
  integer(c_int32_t), value :: quark
end function

! void g_type_query (GType type, GTypeQuery *query);
subroutine g_type_query(type, query) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: type
  type(c_ptr), value :: query
end subroutine

!  GType g_type_register_static (GType parent_type, const gchar *type_name, const GTypeInfo *info, GTypeFlags flags);
function g_type_register_static(parent_type, type_name, info, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_static
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  integer(c_int), value :: flags
end function

! GType g_type_register_static_simple (GType parent_type, const gchar *type_name, guint class_size, GClassInitFunc class_init, guint instance_size, GInstanceInitFunc instance_init, GTypeFlags flags);
function g_type_register_static_simple(parent_type, type_name, class_size, clas&
&s_init, instance_size, instance_init, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_int, c_funptr
  integer(c_size_t) :: g_type_register_static_simple
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  integer(c_int), value :: class_size
  type(c_funptr), value :: class_init
  integer(c_int), value :: instance_size
  type(c_funptr), value :: instance_init
  integer(c_int), value :: flags
end function

!  GType g_type_register_dynamic (GType parent_type, const gchar *type_name, GTypePlugin *plugin, GTypeFlags flags);
function g_type_register_dynamic(parent_type, type_name, plugin, flags) bind(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_dynamic
  integer(c_size_t), value :: parent_type
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: plugin
  integer(c_int), value :: flags
end function

! GType g_type_register_fundamental (GType type_id, const gchar *type_name, const GTypeInfo *info, const GTypeFundamentalInfo *finfo, GTypeFlags flags);
function g_type_register_fundamental(type_id, type_name, info, finfo, flags) bi&
&nd(c) 
  use iso_c_binding, only: c_size_t, c_char, c_ptr, c_int
  integer(c_size_t) :: g_type_register_fundamental
  integer(c_size_t), value :: type_id
  character(kind=c_char), dimension(*) :: type_name
  type(c_ptr), value :: info
  type(c_ptr), value :: finfo
  integer(c_int), value :: flags
end function

! void g_type_add_interface_static (GType instance_type, GType interface_type, const GInterfaceInfo *info);
subroutine g_type_add_interface_static(instance_type, interface_type, info) bin&
&d(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: info
end subroutine

! void g_type_add_interface_dynamic (GType instance_type, GType interface_type, GTypePlugin *plugin);
subroutine g_type_add_interface_dynamic(instance_type, interface_type, plugin) &
&bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: plugin
end subroutine

! void g_type_interface_add_prerequisite (GType interface_type, GType prerequisite_type);
subroutine g_type_interface_add_prerequisite(interface_type, prerequisite_type)&
& bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t), value :: interface_type
  integer(c_size_t), value :: prerequisite_type
end subroutine

! GType*g_type_interface_prerequisites (GType interface_type, guint *n_prerequisites);
function g_type_interface_prerequisites(interface_type, n_prerequisites) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_prerequisites
  integer(c_size_t), value :: interface_type
  type(c_ptr), value :: n_prerequisites
end function

! void g_type_class_add_private (gpointer g_class, gsize private_size);
subroutine g_type_class_add_private(g_class, private_size) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: private_size
end subroutine

! gpointer g_type_instance_get_private (GTypeInstance *instance, GType private_type);
function g_type_instance_get_private(instance, private_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_instance_get_private
  type(c_ptr), value :: instance
  integer(c_size_t), value :: private_type
end function

!  void g_type_add_class_private (GType class_type, gsize private_size);
subroutine g_type_add_class_private(class_type, private_size) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t), value :: class_type
  integer(c_size_t), value :: private_size
end subroutine

! gpointer g_type_class_get_private (GTypeClass *klass, GType private_type);
function g_type_class_get_private(klass, private_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_class_get_private
  type(c_ptr), value :: klass
  integer(c_size_t), value :: private_type
end function

!  GTypePlugin* g_type_get_plugin (GType type);
function g_type_get_plugin(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_get_plugin
  integer(c_size_t), value :: type
end function

! GTypePlugin* g_type_interface_get_plugin (GType instance_type, GType interface_type);
function g_type_interface_get_plugin(instance_type, interface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_interface_get_plugin
  integer(c_size_t), value :: instance_type
  integer(c_size_t), value :: interface_type
end function

! GType g_type_fundamental_next (void);
function g_type_fundamental_next() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_fundamental_next
end function

! GType g_type_fundamental (GType type_id);
function g_type_fundamental(type_id) bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_type_fundamental
  integer(c_size_t), value :: type_id
end function

! GTypeInstance* g_type_create_instance (GType type);
function g_type_create_instance(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_create_instance
  integer(c_size_t), value :: type
end function

! void g_type_free_instance (GTypeInstance *instance);
subroutine g_type_free_instance(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: instance
end subroutine

!  void g_type_add_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_add_class_cache_func(cache_data, cache_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! void g_type_remove_class_cache_func (gpointer cache_data, GTypeClassCacheFunc cache_func);
subroutine g_type_remove_class_cache_func(cache_data, cache_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: cache_data
  type(c_funptr), value :: cache_func
end subroutine

! void g_type_class_unref_uncached (gpointer g_class);
subroutine g_type_class_unref_uncached(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_class
end subroutine

!  void g_type_add_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_add_interface_check(check_data, check_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

! void g_type_remove_interface_check (gpointer check_data, GTypeInterfaceCheckFunc check_func);
subroutine g_type_remove_interface_check(check_data, check_func) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: check_data
  type(c_funptr), value :: check_func
end subroutine

!  GTypeValueTable* g_type_value_table_peek (GType type);
function g_type_value_table_peek(type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_value_table_peek
  integer(c_size_t), value :: type
end function

!  gboolean g_type_check_instance (GTypeInstance *instance) G_GNUC_PURE;
function g_type_check_instance(instance) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_type_check_instance
  type(c_ptr), value :: instance
end function

! GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance, GType iface_type);
function g_type_check_instance_cast(instance, iface_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_instance_cast
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! gboolean g_type_check_instance_is_a (GTypeInstance *instance, GType iface_type) G_GNUC_PURE;
function g_type_check_instance_is_a(instance, iface_type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_instance_is_a
  type(c_ptr), value :: instance
  integer(c_size_t), value :: iface_type
end function

! GTypeClass* g_type_check_class_cast (GTypeClass *g_class, GType is_a_type);
function g_type_check_class_cast(g_class, is_a_type) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t
  type(c_ptr) :: g_type_check_class_cast
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! gboolean g_type_check_class_is_a (GTypeClass *g_class, GType is_a_type) G_GNUC_PURE;
function g_type_check_class_is_a(g_class, is_a_type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_class_is_a
  type(c_ptr), value :: g_class
  integer(c_size_t), value :: is_a_type
end function

! gboolean g_type_check_is_value_type (GType type) G_GNUC_CONST;
function g_type_check_is_value_type(type) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_type_check_is_value_type
  integer(c_size_t), value :: type
end function

! gboolean g_type_check_value (GValue *value) G_GNUC_PURE;
function g_type_check_value(value) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_type_check_value
  type(c_ptr), value :: value
end function

! gboolean g_type_check_value_holds (GValue *value, GType type) G_GNUC_PURE;
function g_type_check_value_holds(value, type) bind(c) 
  use iso_c_binding, only: c_int, c_ptr, c_size_t
  integer(c_int) :: g_type_check_value_holds
  type(c_ptr), value :: value
  integer(c_size_t), value :: type
end function

! gboolean g_type_test_flags (GType type, guint flags) G_GNUC_CONST;
function g_type_test_flags(type, flags) bind(c) 
  use iso_c_binding, only: c_int, c_size_t
  integer(c_int) :: g_type_test_flags
  integer(c_size_t), value :: type
  integer(c_int), value :: flags
end function

!  G_CONST_RETURN gchar* g_type_name_from_instance (GTypeInstance *instance);
function g_type_name_from_instance(instance) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_name_from_instance
  type(c_ptr), value :: instance
end function

! G_CONST_RETURN gchar* g_type_name_from_class (GTypeClass *g_class);
function g_type_name_from_class(g_class) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_type_name_from_class
  type(c_ptr), value :: g_class
end function

!  G_GNUC_INTERNAL void g_value_c_init (void);
subroutine g_value_c_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_value_types_init (void);
subroutine g_value_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_enum_types_init (void);
subroutine g_enum_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_param_type_init (void);
subroutine g_param_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_boxed_type_init (void);
subroutine g_boxed_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_object_type_init (void);
subroutine g_object_type_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_param_spec_types_init (void);
subroutine g_param_spec_types_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_value_transforms_init (void);
subroutine g_value_transforms_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

! G_GNUC_INTERNAL void g_signal_init (void);
subroutine g_signal_init() bind(c) 
  use iso_c_binding, only: 
end subroutine

!   GType g_initially_unowned_get_type (void);
function g_initially_unowned_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_initially_unowned_get_type
end function

! void g_object_class_install_property (GObjectClass *oclass, guint property_id, GParamSpec *pspec);
subroutine g_object_class_install_property(oclass, property_id, pspec) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_object_class_find_property (GObjectClass *oclass, const gchar *property_name);
function g_object_class_find_property(oclass, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_class_find_property
  type(c_ptr), value :: oclass
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec**g_object_class_list_properties (GObjectClass *oclass, guint *n_properties);
function g_object_class_list_properties(oclass, n_properties) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_class_list_properties
  type(c_ptr), value :: oclass
  type(c_ptr), value :: n_properties
end function

! void g_object_class_override_property (GObjectClass *oclass, guint property_id, const gchar *name);
subroutine g_object_class_override_property(oclass, property_id, name) bind(c) 
  use iso_c_binding, only: c_ptr, c_int, c_char
  type(c_ptr), value :: oclass
  integer(c_int), value :: property_id
  character(kind=c_char), dimension(*) :: name
end subroutine

! void g_object_class_install_properties (GObjectClass *oclass, guint n_pspecs, GParamSpec **pspecs);
subroutine g_object_class_install_properties(oclass, n_pspecs, pspecs) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr), value :: oclass
  integer(c_int), value :: n_pspecs
  type(c_ptr), value :: pspecs
end subroutine

!  void g_object_interface_install_property (gpointer g_iface, GParamSpec *pspec);
subroutine g_object_interface_install_property(g_iface, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: pspec
end subroutine

! GParamSpec* g_object_interface_find_property (gpointer g_iface, const gchar *property_name);
function g_object_interface_find_property(g_iface, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_interface_find_property
  type(c_ptr), value :: g_iface
  character(kind=c_char), dimension(*) :: property_name
end function

! GParamSpec**g_object_interface_list_properties (gpointer g_iface, guint *n_properties_p);
function g_object_interface_list_properties(g_iface, n_properties_p) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_interface_list_properties
  type(c_ptr), value :: g_iface
  type(c_ptr), value :: n_properties_p
end function

!  GType g_object_get_type (void) G_GNUC_CONST;
function g_object_get_type() bind(c) 
  use iso_c_binding, only: c_size_t
  integer(c_size_t) :: g_object_get_type
end function

! gpointer g_object_newv (GType object_type, guint n_parameters, GParameter *parameters);
function g_object_newv(object_type, n_parameters, parameters) bind(c) 
  use iso_c_binding, only: c_ptr, c_size_t, c_int
  type(c_ptr) :: g_object_newv
  integer(c_size_t), value :: object_type
  integer(c_int), value :: n_parameters
  type(c_ptr), value :: parameters
end function

! GObject* g_object_new_valist (GType object_type, const gchar *first_property_name, va_list var_args);
function g_object_new_valist(object_type, first_property_name, var_args) bind(c&
&) 
  use iso_c_binding, only: c_ptr, c_size_t, c_char
  type(c_ptr) :: g_object_new_valist
  integer(c_size_t), value :: object_type
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end function

! void g_object_set_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_set_valist(object, first_property_name, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void g_object_get_valist (GObject *object, const gchar *first_property_name, va_list var_args);
subroutine g_object_get_valist(object, first_property_name, var_args) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: first_property_name
  type(c_ptr), value :: var_args
end subroutine

! void g_object_set_property (GObject *object, const gchar *property_name, const GValue *value);
subroutine g_object_set_property(object, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void g_object_get_property (GObject *object, const gchar *property_name, GValue *value);
subroutine g_object_get_property(object, property_name, value) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
  type(c_ptr), value :: value
end subroutine

! void g_object_freeze_notify (GObject *object);
subroutine g_object_freeze_notify(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_notify (GObject *object, const gchar *property_name);
subroutine g_object_notify(object, property_name) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: property_name
end subroutine

! void g_object_notify_by_pspec (GObject *object, GParamSpec *pspec);
subroutine g_object_notify_by_pspec(object, pspec) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: pspec
end subroutine

! void g_object_thaw_notify (GObject *object);
subroutine g_object_thaw_notify(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! gboolean g_object_is_floating (gpointer object);
function g_object_is_floating(object) bind(c) 
  use iso_c_binding, only: c_int, c_ptr
  integer(c_int) :: g_object_is_floating
  type(c_ptr), value :: object
end function

! gpointer g_object_ref_sink (gpointer object);
function g_object_ref_sink(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_ref_sink
  type(c_ptr), value :: object
end function

! gpointer g_object_ref (gpointer object);
function g_object_ref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_object_ref
  type(c_ptr), value :: object
end function

! void g_object_unref (gpointer object);
subroutine g_object_unref(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_weak_ref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_weak_unref (GObject *object, GWeakNotify notify, gpointer data);
subroutine g_object_weak_unref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_add_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_add_weak_pointer(object, weak_pointer_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

! void g_object_remove_weak_pointer (GObject *object, gpointer *weak_pointer_location);
subroutine g_object_remove_weak_pointer(object, weak_pointer_location) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: weak_pointer_location
end subroutine

!  void g_object_add_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_add_toggle_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

! void g_object_remove_toggle_ref (GObject *object, GToggleNotify notify, gpointer data);
subroutine g_object_remove_toggle_ref(object, notify, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr), value :: object
  type(c_funptr), value :: notify
  type(c_ptr), value :: data
end subroutine

!  gpointer g_object_get_qdata (GObject *object, GQuark quark);
function g_object_get_qdata(object, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_object_get_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! void g_object_set_qdata (GObject *object, GQuark quark, gpointer data);
subroutine g_object_set_qdata(object, quark, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
end subroutine

! void g_object_set_qdata_full (GObject *object, GQuark quark, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_qdata_full(object, quark, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t, c_funptr
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_object_steal_qdata (GObject *object, GQuark quark);
function g_object_steal_qdata(object, quark) bind(c) 
  use iso_c_binding, only: c_ptr, c_int32_t
  type(c_ptr) :: g_object_steal_qdata
  type(c_ptr), value :: object
  integer(c_int32_t), value :: quark
end function

! gpointer g_object_get_data (GObject *object, const gchar *key);
function g_object_get_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_get_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! void g_object_set_data (GObject *object, const gchar *key, gpointer data);
subroutine g_object_set_data(object, key, data) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
end subroutine

! void g_object_set_data_full (GObject *object, const gchar *key, gpointer data, GDestroyNotify destroy);
subroutine g_object_set_data_full(object, key, data, destroy) bind(c) 
  use iso_c_binding, only: c_ptr, c_char, c_funptr
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
  type(c_ptr), value :: data
  type(c_funptr), value :: destroy
end subroutine

! gpointer g_object_steal_data (GObject *object, const gchar *key);
function g_object_steal_data(object, key) bind(c) 
  use iso_c_binding, only: c_ptr, c_char
  type(c_ptr) :: g_object_steal_data
  type(c_ptr), value :: object
  character(kind=c_char), dimension(*) :: key
end function

! void g_object_watch_closure (GObject *object, GClosure *closure);
subroutine g_object_watch_closure(object, closure) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
  type(c_ptr), value :: closure
end subroutine

! GClosure* g_cclosure_new_object (GCallback callback_func, GObject *object);
function g_cclosure_new_object(callback_func, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GClosure* g_cclosure_new_object_swap (GCallback callback_func, GObject *object);
function g_cclosure_new_object_swap(callback_func, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_funptr
  type(c_ptr) :: g_cclosure_new_object_swap
  type(c_funptr), value :: callback_func
  type(c_ptr), value :: object
end function

! GClosure* g_closure_new_object (guint sizeof_closure, GObject *object);
function g_closure_new_object(sizeof_closure, object) bind(c) 
  use iso_c_binding, only: c_ptr, c_int
  type(c_ptr) :: g_closure_new_object
  integer(c_int), value :: sizeof_closure
  type(c_ptr), value :: object
end function

! void g_value_set_object (GValue *value, gpointer v_object);
subroutine g_value_set_object(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

! gpointer g_value_get_object (const GValue *value);
function g_value_get_object(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_get_object
  type(c_ptr), value :: value
end function

! gpointer g_value_dup_object (const GValue *value);
function g_value_dup_object(value) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr) :: g_value_dup_object
  type(c_ptr), value :: value
end function

! gulong g_signal_connect_object (gpointer instance, const gchar *detailed_signal, GCallback c_handler, gpointer gobject, GConnectFlags connect_flags);
function g_signal_connect_object(instance, detailed_signal, c_handler, gobject,&
& connect_flags) bind(c) 
  use iso_c_binding, only: c_long, c_ptr, c_char, c_funptr, c_int
  integer(c_long) :: g_signal_connect_object
  type(c_ptr), value :: instance
  character(kind=c_char), dimension(*) :: detailed_signal
  type(c_funptr), value :: c_handler
  type(c_ptr), value :: gobject
  integer(c_int), value :: connect_flags
end function

!  void g_object_force_floating (GObject *object);
subroutine g_object_force_floating(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

! void g_object_run_dispose (GObject *object);
subroutine g_object_run_dispose(object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object
end subroutine

!  void g_value_take_object (GValue *value, gpointer v_object);
subroutine g_value_take_object(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

!  void g_value_set_object_take_ownership (GValue *value, gpointer v_object);
subroutine g_value_set_object_take_ownership(value, v_object) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: value
  type(c_ptr), value :: v_object
end subroutine

!  gsize g_object_compat_control (gsize what, gpointer data);
function g_object_compat_control(what, data) bind(c) 
  use iso_c_binding, only: c_size_t, c_ptr
  integer(c_size_t) :: g_object_compat_control
  integer(c_size_t), value :: what
  type(c_ptr), value :: data
end function

!  void g_clear_object (volatile GObject **object_ptr);
subroutine g_clear_object(object_ptr) bind(c) 
  use iso_c_binding, only: c_ptr
  type(c_ptr), value :: object_ptr
end subroutine

end interface
end module g
